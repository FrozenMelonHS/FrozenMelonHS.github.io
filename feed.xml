<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[blog of purplebamboo]]></title>
    <link>http://purplebamboo.github.com/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <description><![CDATA[前端码农个人博客。]]></description>
    <pubDate>Tue, 22 Nov 2016 05:36:37 GMT</pubDate>
    <generator>http://zespia.tw/hexo/</generator>
    
    <item>
      <title><![CDATA[iconfont字体生成原理及使用技巧]]></title>
      <link>http://purplebamboo.github.com/2016/08/16/iconfont_code_and_use/</link>
      <guid>http://purplebamboo.github.com/2016/08/16/iconfont_code_and_use/</guid>
      <pubDate>Tue, 16 Aug 2016 13:55:18 GMT</pubDate>
      <description>
      <![CDATA[<p>好久不写文章了，罪过罪过，最近一直在忙iconfont改版的事情，各种焦头烂额。今天做了次iconfont的分享，所以整理下，发一篇水文。</p>
<p>主要给大家同步下iconfont的字体生成原理，以及解答下使用上的一些比较常见的问题</p>
<h2 id="原理篇">]]>
      </description>
      <content:encoded><![CDATA[<p>好久不写文章了，罪过罪过，最近一直在忙iconfont改版的事情，各种焦头烂额。今天做了次iconfont的分享，所以整理下，发一篇水文。</p>
<p>主要给大家同步下iconfont的字体生成原理，以及解答下使用上的一些比较常见的问题</p>
<h2 id="原理篇">原理篇</h2>
<p>iconfont技术早就不是什么新技术了，我们iconfont.cn也已经做了快三年了。后来陆陆续续的来了很多新同学，可能只知道用这个，却不知道它内部的原理，这里给大家同步下，知道了原理可以更好的去使用。</p>
<h3 id="css加载自定义字体">css加载自定义字体</h3>
<p>首先前端都知道我们可以定义web上面文字的fontfamily。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>css:

.test{
 font-size: 16px;
 font-family: '微软雅黑';
}

html:

&lt;span class="test"&gt;iconfont字体原理&lt;/span&gt;
</pre></td></tr></table></figure>

<p>但是这种情况下我们只能用系统默认的一些字体，限制比较大。比如微软雅黑就是windows下面才有。</p>
<p>其实css是可以自定义字体的，所以我们可以加载自己的字体。</p>
<p>使用 @font-face 定义一个字体family：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre>css<span class="value">:

@font-face {
  font-family: <span class="string">'iconfont'</span>;</span>
  src<span class="value">: url(<span class="string">'//at.alicdn.com/t/font_1453702746_9938898.eot'</span>);</span> <span class="comment">/* IE9*/</span>
  src<span class="value">: url(<span class="string">'//at.alicdn.com/t/font_1453702746_9938898.eot?#iefix'</span>) format(<span class="string">'embedded-opentype'</span>), /* IE6-IE8 */
  url(<span class="string">'//at.alicdn.com/t/font_1453702746_9938898.woff'</span>) format(<span class="string">'woff'</span>), /* chrome、firefox */
  url(<span class="string">'//at.alicdn.com/t/font_1453702746_9938898.ttf'</span>) format(<span class="string">'truetype'</span>), /* chrome、firefox、opera、Safari, Android, iOS <span class="number">4.2</span>+*/
  url(<span class="string">'//at.alicdn.com/t/font_1453702746_9938898.svg#iconfont'</span>) format(<span class="string">'svg'</span>);</span> <span class="comment">/* iOS 4.1- */</span>
}


<span class="class">.test</span>{
 <span class="attribute">font-size</span><span class="value">: <span class="number">16</span>px;</span>
 <span class="attribute">font-family</span><span class="value">: <span class="string">'iconfont'</span>;</span>
}

<span class="tag">html</span><span class="value">:

&lt;span class=<span class="string">"test"</span>&gt;iconfont字体原理&lt;/span&gt;</span>
</pre></td></tr></table></figure>

<p>这样我们就可以用自定义字体渲染这些文字了。<br>每一个字都有对应的unicode。比如我们在web上输入<code>我</code>跟输入<code>&amp;#x6211;</code>是一样的。浏览器会自动帮你找到对应的图形去渲染。</p>
<blockquote>
<p>当然因为兼容性的问题，不同的浏览器需要加载不同格式的字体，所以我们要同时支持四种字体。</p>
</blockquote>
<h3 id="字体内部">字体内部</h3>
<p>我们来看下一个字体的样子。</p>
<p>我们可以通过一些软件打开字体，比如fontforge，fontlab。</p>
<p>比如下面的方正大草字体：</p>
<p><img src="http://alp.alicdn.com/1471379333241.png" alt="方正"></p>
<p>我们打开看下：</p>
<p><img src="http://alp.alicdn.com/1471379393101.png" alt="方正"></p>
<p>可以看到<code>我</code>这个字对应的的图形就是我们在网页上看到的样子。另外注意左上角的unicode。是6211，也就是我们的另一种表现形式。</p>
<p>再双击可以看到我这个图形的样子:</p>
<p><img src="http://alp.alicdn.com/1471379343171.png" alt="方正"></p>
<p>其实就是一些路径。而这个路径可以用ai，ps，sketch等等来画，画完粘贴到这里。</p>
<h3 id="iconfont1-0">iconfont1.0</h3>
<p>所以我们就可以做一些事情了，我们可以去改造字体，把一个字对应的图形换成我们设计师设计的样子，处理好兼容性就成了我们iconfont的1.0。</p>
<p>当年iconfont1.0是怎样的流程呢：</p>
<p><img src="http://alp.alicdn.com/1471380111315.png" alt="iconfont1.0"></p>
<p>由设计师手动修改ttf字体对应的图形，我们人工转换出另外四种字体。<br>这样前台就可以用unicode去引用，就是我们第一代的iconfont的原理。这个成本有点大。</p>
<h3 id="iconfont2-0">iconfont2.0</h3>
<p>其实我们注意到里面有个svg的字体。你用文本编辑器打开会发现他是xml格式的，每个字的图形对应了一个路径。这个路径就是我们svg里面的path对应的序列。</p>
<p><img src="http://alp.alicdn.com/1471380485040.png" alt="svg font"></p>
<p>好了于是我们有了一个全新的思路，由设计师上传svg，我们存储下来，然后大家自由组合，由平台拼出对应的svg字体，然后再转换到不同的其他格式的字体。</p>
<p><img src="http://alp.alicdn.com/1471380113401.png" alt="iconfont2.0"></p>
<p>这里面的难点主要在，我们要分析svg。转换出对应的path序列。用户上传的svg格式太多，大小不一。要做各种转换，这里不展开了。</p>
<p>这就是我们的iconfont2.0，也就是目前线上跑的版本。</p>
<h3 id="font-carrier">font-carrier</h3>
<p>当然这一切都封装好了，做了一个工具库，<a href="http://purplebamboo.github.io/font-carrier/" target="_blank">font-carrier</a>。</p>
<p><img src="http://alp.alicdn.com/1471380754109.png" alt="font-carrier"></p>
<p>语法比较简单，可以直接往一个字体里面添加svg，也可以拿到某个字对应的svg，最终导出四种兼容字体。</p>
<p>知道了原理，以后大家调试就比较简单了，直接自己打开对应的svg字体，去看看你们对应的unicode的图形是不是有问题就行了,下面我们说说使用上一些常见的问题。</p>
<h2 id="使用">使用</h2>
<p>下面就可能会遇到的一些问题，做些简单的解答。</p>
<h3 id="字体冲突的问题">字体冲突的问题</h3>
<p>iconfont.cn平台给出的font-face定义默认都是 <code>iconfont</code>的<code>fontfamily</code>，建议大家改掉，避免与其他项目字体（比如引用的公共组件里面的字体）冲突。</p>
<p><img src="http://alp.alicdn.com/1471380985155.png" alt="chongtu"></p>
<h3 id="unicode取值的问题">unicode取值的问题</h3>
<p>unicode其实没有特别的规定。</p>
<p>字体有几个<a href="https://en.wikipedia.org/wiki/Private_Use_Areas" target="_blank">私有平面</a>:</p>
<p><img src="http://alp.alicdn.com/1471381668684.png" alt="pingm"></p>
<p>很早以前我们使用的五位数的，结果现在chrome支持不太好，后面建议大家使用第一个平面里的。</p>
<p>这样用的好处是，字体没有加载的时候，显示的是一个框 <code>口</code>。而不是乱码。</p>
<h3 id="字体基线的问题">字体基线的问题</h3>
<p>这是个艰难的决定。一脸无辜.jpg</p>
<p>中文字体没有严格意义上的基线。我们参考了方正字体的基线：<br><img src="https://img.alicdn.com/tps/TB1GfUJJFXXXXabXpXXXXXXXXXX-598-574.png" alt="mm"></p>
<p>中间的线是baseline,这个就是0这条线。对于一个字体来说，可以设置上边界（ascent）跟下边界（descent）。比如我们iconfont设置的是812，-212。</p>
<p>所以如果我们的图标这么设计：</p>
<p><img src="https://img.alicdn.com/tps/TB1e_n1JFXXXXbeXXXXXXXXXXXX-802-637.png" alt="mm"></p>
<p>那么是可以基本对齐的。</p>
<p>但是我们发现用户上传图标时喜欢撑满整个框：</p>
<p><img src="https://img.alicdn.com/tps/TB1.5DIJFXXXXbCXFXXXXXXXXXX-599-587.png" alt="mm"></p>
<p>可以想像下，这种图标跟字体一起展现，就会变得偏下了。</p>
<p>所以在支付宝的要求下，我们修改了基线。当我们把下偏移量设置的比较小，这样基线相对就会在比较下面的位置。 这样就算用户上传的图标撑满也没关系了，因为普通的汉子是差不多三分之一，我们迁就一下，偏少一点，这样基本就能对齐了。</p>
<p>于是带来了一群不明真相的群众的吐槽。但是又不得不做这个事情。</p>
<h3 id="单个icon撑开的问题">单个icon撑开的问题</h3>
<p>有的时候设计师设计的icon会有多余的点，也可能当前上传的svg边界太大，于是导致我们的整个字体被撑开。</p>
<p>表现如下：</p>
<p><img src="http://alp.alicdn.com/1471382640883.png" alt="bx"></p>
<p>可以看到由于最左边的icon把字体撑开了。导致大家展示除了问题，表现在页面上是：</p>
<p><img src="http://alp.alicdn.com/1471382773166.png" alt="zy"></p>
<p>注意看里面的阴影，由于被撑开，导致它的边界是不对的。我们删掉这个图标再生成字体就好了。</p>
<p>当然这里还有各种问题，字体清晰度，icon上传svg规范问题，字体跨域问题，锯齿问题等等。这些平台基本都可以内部优化掉了，就不展开了。</p>
<h2 id="结语">结语</h2>
<p>iconfont解决了我们以前大量使用图片带来的种种问题，但是也有自身的各种缺陷。比如不支持多色就是一个最大的致命伤，另外在不同浏览器下的表现不同，需要做各种兼容。</p>
<p>不久的将来iconfont应该会被svg symbol技术替换。可以参考这篇<a href="https://zhuanlan.zhihu.com/p/20753791?refer=FrontendMagazine" target="_blank">文章</a>。<br>淘积木目前接入了webfont，直接用svg当作字体展现，实时预览，也是一种新的突破。</p>
<p>iconfont.cn平台目前也在做相关的改造，期待带来新一轮的字体使用方式变革。</p>
]]></content:encoded>
      <comments>http://purplebamboo.github.com/2016/08/16/iconfont_code_and_use/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[局部刷新模板那些事]]></title>
      <link>http://purplebamboo.github.com/2016/04/21/about-partial-refresh/</link>
      <guid>http://purplebamboo.github.com/2016/04/21/about-partial-refresh/</guid>
      <pubDate>Thu, 21 Apr 2016 08:26:17 GMT</pubDate>
      <description>
      <![CDATA[<p>模板是每个前端工作者都会接触到的东西，近几年前端的工程化，发展的如火如荼。从基本的字符串拼接到字符串模板，再到现在各种框架给出的“伪模板”解决方案，前端模板经历了种种变革。</p>
<p>下面就不同时期的模板做一下回顾。</p>
<blockquote>
<p>本文假定读者]]>
      </description>
      <content:encoded><![CDATA[<p>模板是每个前端工作者都会接触到的东西，近几年前端的工程化，发展的如火如荼。从基本的字符串拼接到字符串模板，再到现在各种框架给出的“伪模板”解决方案，前端模板经历了种种变革。</p>
<p>下面就不同时期的模板做一下回顾。</p>
<blockquote>
<p>本文假定读者已经对<code>underscore</code>, <code>mustache</code>，<code>angularjs</code>，<code>reactjs</code>等技术有了一定的了解。否则请先看看相关资料了解下。</p>
</blockquote>
<h2 id="原始的模板">原始的模板</h2>
<p>提到模板，不得不提到每个前端都会经历的字符串拼接的阶段。</p>
<p>看下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre>
&lt;ul id=<span class="string">"test"</span>&gt;


<span class="xml"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span>

<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">

<span class="keyword">var</span> students = [{
    name:<span class="string">'张三'</span>,
    age:<span class="string">'19'</span>
},{
    name:<span class="string">'李四'</span>,
    age:<span class="string">'17'</span>
},{
    name:<span class="string">'王五'</span>,
    age:<span class="string">'21'</span>
}]

<span class="keyword">var</span> htmlArray = [],tmplStr

<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;students.length;i++){
    tmplStr = <span class="string">'&lt;li&gt;'</span>
    tmplStr += <span class="string">'姓名：'</span>+ students[i].name +<span class="string">'年龄：'</span> + students[i].age
    tmplStr += <span class="string">'&lt;/li&gt;'</span>
    htmlArray.push(tmplStr)
}

document.getElementById(<span class="string">'test'</span>).innerHTML = htmlArray.join(<span class="string">' '</span>)
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span>
</pre></td></tr></table></figure>

<p>代码逻辑很简单，将一份数据循环拼接好字符串最后组装好html字符串塞到页面上。</p>
<p>可以看到这种写法，模板部分跟逻辑部分很容易耦合在一起，非常的不清晰，可读性也很差。在大规模项目中是不建议这么用的。</p>
<h2 id="字符串模板的兴起">字符串模板的兴起</h2>
<p>因为上面的写法有太多的缺点，所以先辈们开始实现基本的模板引擎。实现展示与逻辑的分离。</p>
<p>比较典型的是underscore类型的模板，它其实很简单，就是把一个基本的模板语法转换成一个可执行的javascript代码。</p>
<p>我们看下上面的功能使用underscore的语法怎么写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre>

&lt;ul id=<span class="string">"test"</span>&gt;


<span class="xml"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span>

<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">

<span class="keyword">var</span> students = [{
    name:<span class="string">'张三'</span>
},{
    name:<span class="string">'李四'</span>
},{
    name:<span class="string">'王五'</span>
}]


<span class="keyword">var</span> tmpl = <span class="string">'&lt;% for(var i=0;i&lt;students.length;i++){ %&gt; 姓名： &lt;% students[i].name %&gt;   &lt;% } %&gt;'</span>

<span class="comment">//假设template可以实现类似underscore的语法</span>
<span class="keyword">var</span> tplCompile = template(tmpl) <span class="comment">//先生成执行函数</span>

document.getElementById(<span class="string">'test'</span>).innerHTML = tplCompile(students)<span class="comment">//执行渲染</span>
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span>
</pre></td></tr></table></figure>

<p>template，作为实现了underscore功能的函数，传入一个模板还有一份数据，就可以把模板渲染出来。</p>
<p>这样写的好处是，实现了模板与字符串逻辑的分离。ui层，也就是渲染逻辑看起来会比较清晰。</p>
<p>下面我们来看看如何实现一个最基本的template：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td><td class="code"><pre>
<span class="function"><span class="keyword">function</span> <span class="title">template</span><span class="params">(tpl)</span>{</span>
    <span class="comment">//用来匹配出我们的特殊语法</span>
    <span class="keyword">var</span> tplReg = <span class="regexp">/&lt;%([^%&gt;]+)?%&gt;/g</span>

    <span class="keyword">var</span> match;
    <span class="keyword">var</span> cursor=<span class="number">0</span>;
    <span class="keyword">var</span> regOut = <span class="regexp">/(^( )?(if|for|else|switch|case|break|{|}))(.*)?/g</span>;

    <span class="comment">//需要拼接的代码，这里注意with的用法，用来使渲染的数据应用在模板里</span>
    <span class="keyword">var</span> code = <span class="string">'var codes=[];\nwith(renderData){\n'</span>;

    <span class="keyword">var</span> addLine = <span class="function"><span class="keyword">function</span><span class="params">(line,js)</span>{</span>
        <span class="comment">//普通文本，这时候加上一个双引号就可以了</span>
        <span class="keyword">if</span>(!js){
            code += <span class="string">'codes.push("'</span> + line.replace(<span class="regexp">/"/g</span>, <span class="string">'\\"'</span>) + <span class="string">'");\n'</span>
            <span class="keyword">return</span>
        }

        <span class="comment">//特殊语法特殊处理</span>
        <span class="comment">//对于有js特殊逻辑比如for,if这种代码，不适用push。直接打出。</span>
        <span class="keyword">if</span>(regOut.test(line)){
            code += line + <span class="string">'\n'</span>;
        }<span class="keyword">else</span>{
            <span class="comment">//普通的特殊语法，跟上面的普通的文本唯一的区别就是少了双引号，这样以后执行时就会是变量。</span>
            code += <span class="string">'codes.push('</span> + line + <span class="string">');\n'</span>
        }

    }
    <span class="comment">//通过正则不停的去匹配特殊语法</span>
    <span class="keyword">while</span>(match = tplReg.exec(tpl)) {
        <span class="comment">//截取前面的普通文本</span>
        addLine(tpl.slice(cursor, match.index)); <span class="comment">//普通文本</span>
        <span class="comment">//将当前的特殊语法加入</span>
        addLine(match[<span class="number">1</span>],<span class="literal">true</span>);  <span class="comment">//特殊逻辑</span>
        cursor = match.index + match[<span class="number">0</span>].length; <span class="comment">//更新游标</span>
    }
    <span class="comment">//末尾可能还剩下些语法</span>
    addLine(tpl.substr(cursor, tpl.length - cursor)); <span class="comment">//剩下的代码</span>

    code += <span class="string">'};return codes.join("")'</span>;
    code = code.replace(<span class="regexp">/[\r\t\n]/g</span>, <span class="string">''</span>)

    <span class="keyword">var</span> compileFn = <span class="function"><span class="keyword">function</span><span class="params">(data)</span>{</span>
        <span class="comment">//使用function执行拼好的代码，将data传到函数里。</span>
        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'renderData'</span>,code)(data);
    }

    <span class="keyword">return</span> compileFn

}
</pre></td></tr></table></figure>

<p>实现很简单，主要就是通过正则替换，拼凑出最终的js执行语句，然后使用function来执行得到结果。</p>
<p>我们通过tplReg这个正则匹配出所有的<code>&lt;% ... %&gt;</code>特殊语法，<code>addLine</code>负责生成javascript可执行语句。</p>
<p><code>addLine</code>添加的语句需要分三种情况：</p>
<ol>
<li>特殊语法之外的普通文本，比如上面的<code>姓名：</code>这种文本。这个时候直接push到codes里面就行，最后会原样输出。这边需要加上双引号代表是个普通字符串。</li>
<li>对于特殊语法里面的普通语法，比如上面的<code>students[i].name</code>，这种时候直接push到codes里面，跟上面不同的是，这时不需要加双引号,这样最后这些codes执行时就会把它作为变量去处理。</li>
<li>还有一种特殊的语法，就是<code>for(var i=0;i&lt;students.length;i++){</code>这种带for的<br>。这个时候不能放到codes里面，因为我们本身需要它的循环功能。</li>
</ol>
<p>最后拼接好codes后，使用function一次执行得到最终渲染好的字符串。</p>
<p>当然我们这边的实现超级简陋，仅供参考原理。实际的模板还需要考虑缓存，兼容性，xss等等。</p>
<p>字符串模板使用很广泛，也踊跃出了若干实现。mustache，Underscore templates，Dust.js等等，前端真的是能折腾。如果有选择困难症，可以看看这里：<a href="http://garann.github.io/template-chooser/" target="_blank">http://garann.github.io/template-chooser/</a></p>
<p>这个阶段的模板或多或少都是相同的原理。</p>
<ul>
<li>解析字符串模板，有的是直接正则分析，有的是用语法树分析。</li>
<li>渲染出结果，直接改造成原生的javascript语句执行拿到结果。</li>
</ul>
<p>这在很长一段时间里对于前端工程师来说已经够用了。通过模板的dsl，很好的实现了前端逻辑与ui的分离。</p>
<h2 id="字符串模板的局部刷新">字符串模板的局部刷新</h2>
<p>但是随着前端的发展，特别是富客户端应用的兴起。单纯的字符串模板已经很难满足需求了。</p>
<p>比如一个学生个人信息界面，分为个人姓名，还有个人成绩两块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre>
&lt;div&gt;个人信息：&lt;/div&gt;
&lt;div id="test"&gt;


&lt;/div&gt;

&lt;script&gt;

var student = {
    name:'张三',
    score:89
}


var tmpl = '&lt;div&gt;姓名: &lt;% name %&gt; &lt;/div&gt;&lt;div&gt;成绩: &lt;% score %&gt; &lt;/div&gt;'

//假设template方法可以实现underscore的语法
document.getElementById('test').innerHTML = template(tmpl)(student)
&lt;/script&gt;
</pre></td></tr></table></figure>

<p>如果我们初次渲染后需要去更新成绩。我们期待的情况肯定是只更新成绩，个人姓名不要重复刷新。这对于普通字符串模板是做不到的。只能自己使用dom操作去修改，而这样就违背了我们的初衷，逻辑又跟展现耦合变的不可控了。</p>
<blockquote>
<p>实际情况会更复杂,页面内容更多，需要局部刷新的地方更多，这里为了方便，只举一个最简单的例子。</p>
</blockquote>
<p>如果不自己使用dom操作，还希望用模板，那么每次要改点东西都需要整个页面全部重新渲染，在通过innerHTML一次性更新。</p>
<ul>
<li>首先这会造成页面的整体刷新，用户体验差</li>
<li>其次，每次innerHTML，浏览器都需要重新渲染dom结构，造成性能浪费</li>
</ul>
<p>我们其实是需要一种局部刷新的东西，在初次渲染后仍然保持模板与dom的联系。通过一些方法，只改变页面中的一小部分html。差异化的去更新。其实是一种innerHTML的优化。</p>
<p>我们团队很久之前就做了这方面的尝试，可以先看下我们是怎么用的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>
&lt;script&gt;

<span class="keyword">var</span> student = {
    name:<span class="string">'张三'</span>,
    score:<span class="number">89</span>
}

<span class="comment">//注意下面的模板里面多了 tpl-name="sc"  tpl-key="score"</span>
<span class="keyword">var</span> tmpl = <span class="string">'&lt;div&gt;姓名: &lt;% name %&gt; &lt;/div&gt;&lt;div tpl-name="sc" tpl-key="score"&gt;成绩: &lt;% score %&gt; &lt;/div&gt;'</span>


<span class="comment">//第一次渲染，会自动绑定到test的div上</span>
<span class="keyword">var</span> node = render(<span class="string">'test'</span>, tmpl, student)

<span class="comment">//如果我们需要更新成绩只需要调用setChunkData来局部刷新页面</span>
node.setChunkData(score,<span class="number">100</span>)

&lt;<span class="regexp">/script&gt;</span>
</pre></td></tr></table></figure>

<p>首先我们会在需要更新的局部dom上打上标签<code>tpl-name=&quot;sc&quot; tpl-key=&quot;score&quot;</code>,代表这里的dom第二次渲染需要依赖score这个变量,并且这个局部模板有了唯一标识sc。然后当我们需要更新成绩的时候只需要调用<code>node.setChunkData(score,100)</code>就可以找到依赖score这个变量对应的dom并且自动使用局部模板去刷新页面了。</p>
<p>可以看到这样带来了不少好处，我们可以继续享受模板带来的便利性，也可以局部刷新页面中的某个区块。而这一切都是建立在数据上的，我们的逻辑处理永远在数据这一层，面向数据编程。而渲染，局部渲染都会自动帮忙完成。</p>
<p>那么达到这样的功能我们需要做什么呢？</p>
<ul>
<li>首先我们需要先解析模板，对于<code>tpl-key</code>这样的标签，我们需要特殊处理，把子模板记录下来，并且记录tpl-name，作为对应。</li>
<li>在调用setChunkData时，我们需要去找到对应的局部模板，还有对应的dom。重新渲染后局部innerHTML。</li>
</ul>
<p>我们看一个最简单的实现（基于上面的template增强而来）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="code"><pre>
<span class="comment">//此函数依赖上面的template函数</span>
<span class="keyword">var</span> render = <span class="function"><span class="keyword">function</span><span class="params">(id, tpl,data)</span>{</span>

    <span class="comment">//初次渲染，直接使用以前的template函数</span>
    document.getElementById(id).innerHTML = template(tpl)(data)


    <span class="comment">//下面都是局部渲染需要的逻辑</span>
    <span class="keyword">var</span> tpls = []<span class="comment">//存放局部刷新的模板</span>
    <span class="comment">//解析模板，找到局部模板 这边的getSubTpls可以先不管，只需要知道返回结果为：</span>
    <span class="comment">//[{name:'sc',key:score,tpl:'&lt;span&gt;成绩:&lt;/span&gt; &lt;% score %&gt; '}]</span>
    tpls = getSubTpls(tpl)


    <span class="comment">//用于根据依赖的key找到对应的那些模板</span>
    <span class="function"><span class="keyword">function</span> <span class="title">getChunkTpl</span><span class="params">(key)</span>{</span>
        <span class="keyword">var</span> results = []

        <span class="keyword">for</span>(<span class="keyword">var</span> i= tpls.length-<span class="number">1</span>;i&gt;-<span class="number">1</span>;i--){
            <span class="keyword">if</span>(tpls[i].key === key){
                results.push(tpls[i])
            }
        }
        <span class="keyword">return</span> results
    }

    <span class="keyword">return</span> {
        setChunkData:<span class="function"><span class="keyword">function</span><span class="params">(key,value)</span>{</span>
            <span class="keyword">var</span> subData = {}
            subData[key] = value


            <span class="keyword">var</span> subNode
            <span class="keyword">var</span> subTpls = getChunkTpl(key) <span class="comment">//匹配到对应的局部模板,可能有多个</span>

            <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;subTpls.length;i++){
                <span class="comment">//这里为了图方便直接用querySelector了</span>
                subNode = document.querySelector(<span class="string">'[tpl-name="'</span> + subTpls[i].name + <span class="string">'"]'</span>)
                <span class="comment">//渲染好，刷新局部dom</span>
                subNode.innerHTML = template(subTpls[i].tpl)(subData)

            }

        }
    }

}
</pre></td></tr></table></figure>

<p>基本实现了我们需要的功能，逻辑上也不复杂，提前准备好局部模板，在setChunkData时通过key找出对应的局部模板还有dom节点，这样就可以达到局部刷新的目的。</p>
<p>下面看下getSubTpls的实现，这个如果不感兴趣可以直接跳过，毕竟已经是过时的技术了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td><td class="code"><pre>
<span class="comment">//这个方法是用来获取一个tag下面的字符串</span>
<span class="comment">//getTagInnerHtml('&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;div id='1'&gt;&lt;/div&gt;&lt;/div&gt;',div,0,0)</span>
<span class="comment">//可以匹配出&lt;span&gt;&lt;/span&gt;&lt;div id='1'&gt;&lt;/div&gt;</span>
<span class="function"><span class="keyword">function</span> <span class="title">getTagInnerHtml</span><span class="params">(tpl, tag, s_pos, offset)</span> {</span>
    <span class="keyword">var</span> s_tag = <span class="string">'&lt;'</span> + tag
    <span class="keyword">var</span> e_tag = <span class="string">'&lt;/'</span> + tag + <span class="string">'&gt;'</span>

    <span class="keyword">var</span> s_or_pos = s_pos + offset

    <span class="keyword">var</span> e_pos = s_pos
    <span class="keyword">var</span> e_next_pos = s_pos

    s_pos = tpl.indexOf(s_tag, s_pos)
    <span class="keyword">var</span> s_next_pos = s_pos + <span class="number">1</span>

    <span class="keyword">while</span> (<span class="literal">true</span>) {
        s_pos = tpl.indexOf(s_tag, s_next_pos);
        e_pos = tpl.indexOf(e_tag, e_next_pos);

        <span class="keyword">if</span> (s_pos == -<span class="number">1</span> || s_pos &gt; e_pos) {
            <span class="keyword">break</span>
        }
        s_next_pos = s_pos + <span class="number">1</span>
        e_next_pos = e_pos + <span class="number">1</span>
    }
    <span class="keyword">return</span> {
        html: tpl.substring(s_or_pos, e_pos)
    }
}


<span class="function"><span class="keyword">function</span> <span class="title">getSubTpls</span><span class="params">(tpl)</span>{</span>
    <span class="comment">//用来匹配带有标签的tag的正则</span>
    <span class="keyword">var</span> tplTagReg = <span class="regexp">/&lt;([\w]+)\s+[^&gt;]*?tpl-name=["\']([^"\']+)["\']\s+[^&gt;]*?tpl-key=["\']([^"\']+)["\']\s*[^&gt;]*?&gt;/g</span>

    <span class="keyword">var</span> match,tagInfo
    <span class="keyword">var</span> tpls = []

    <span class="keyword">while</span>(match = tplTagReg.exec(tpl)) {

        tagInfo = getTagInnerHtml(tpl,match[<span class="number">1</span>],match.index,match[<span class="number">0</span>].length)

        tpls.push({
            name:match[<span class="number">2</span>],
            key:match[<span class="number">3</span>],
            tpl: tagInfo.html
        })
    }
    <span class="keyword">return</span> tpls
}
</pre></td></tr></table></figure>

<p>关键是getTagInnerHtml的实现，由于javascript没有平衡组的概念，所以不得不写这么一长串的处理逻辑，具体参考</p>
<p><a href="http://lf-6666.blog.163.com/blog/static/3123705200942155416430/" target="_blank">http://lf-6666.blog.163.com/blog/static/3123705200942155416430/</a></p>
<p><a href="http://thx.github.io/brix-core/articles/tpl-3/" target="_blank">http://thx.github.io/brix-core/articles/tpl-3/</a></p>
<p>至此基本功能就完成了。在一段时间里也够用了。</p>
<blockquote>
<p>实际的代码，需要处理的问题更多，需要处理好父子级局部模板，多个数据并列依赖等等问题，由于已经是过时的技术了，这里就不详细展开了，有兴趣的可以到<a href="https://github.com/etaoux/brix/blob/master/dist/2.0/brix.js" target="_blank">这里</a>了解。</p>
</blockquote>
<p>但是其实还是有些显而易见的问题：</p>
<ul>
<li>局部刷新需要自己去指定标签，也很难处理父子包含，同级数据并列等问题</li>
<li>使用<code>setChunkData</code>私有方法，需要到模板找到对应的依赖数据，需要自己去把握逻辑</li>
<li>局部刷新其实只是局部的innerHTML,有的时候没法力度太细。跟真正的dom操作比起来，消耗、闪烁都是要大的。</li>
</ul>
<p>这个时候我们渐渐发现字符串模板已经走到头了。面对日新月异的前端开发，尤其是单页应用，普通的字符串模板已经不能满足需求了。</p>
<h2 id="新时代的“模板”">新时代的“模板”</h2>
<p>因为字符串模板的种种缺陷，在新的大时代背景下，尤其是前端各种框架的井喷时代。各种各样的框架实现了很多很有意思的东西，跳出了传统字符串模板的概念，但是的确实现了模板的功能。这个时候已经不适合称之为模板了。</p>
<p>我们先想想，我们上面探索局部刷新时遇到了什么问题。</p>
<p>首先我们需要保持跟模板的联系，这样我们下次需要局部刷新时才能找到对应的节点。比如我们上面是通过在dom节点上打标来实现的。</p>
<p>其次我们需要监听数据的变化，我们上面是直接使用私有方法<code>setChunkData</code>来通知引擎数据变化了，可以开始更新了。这样其实很不好，需要我们关注太多的东西。</p>
<p>另外如果我们多次调用setChunkData，那么就会渲染多次，除了最后一次前面的渲染都是没有必要的，所以我们还需要个批量更新的东西，前面的那些改动不需要真实的反应到dom上。</p>
<p>事实上，目前的主流框架虽然已经脱离了模板的范畴，但是也是紧紧围绕这几个方面来实现的。</p>
<p>当然目前还兴起了双向绑定的热潮，不过在传统的字符串模板里是难以实现的。</p>
<p>下面我们大概介绍下主流的几个框架的是如何实现<code>模板</code>功能的，具体分为下面这几点：</p>
<ul>
<li>如何监听数据的变化</li>
<li>如何渲染更新页面定位节点位置<ul>
<li>初次渲染的逻辑</li>
<li>后来的更新机制</li>
</ul>
</li>
<li>如何实现双向绑定</li>
<li>如何实现批量更新</li>
</ul>
<h3 id="angularjs">angularjs</h3>
<p>angularjs带来了很多前端界的新概念，指令，脏检测，filter等等等。</p>
<h4 id="原理">原理</h4>
<p>我们看下angularjs的大致图形</p>
<p>几个概念：</p>
<ul>
<li>watcher 用来监听一个表达式的变更，然后有一个回调。</li>
<li>directive  具有link方法，存放所有的指令逻辑。一般会使用watcher的功能。</li>
<li>scope   作用域，angular的所有方法，数据都会在这个上面。</li>
<li>digest  用来执行脏检测，开始递归检查scope上的所有watcher发现当前的值跟以前的不一样时就做出dom改变。</li>
</ul>
<p>三个大模块：</p>
<p><img src="http://blog.mgechev.com/images/lightweight-ng/main-components.png" alt="dd"></p>
<p>Provider:</p>
<ul>
<li>注册组件（directives, services 和 controllers）</li>
<li>解决各个组件之间的依赖关系</li>
<li>初始化所有组件</li>
</ul>
<p>DOMCompiler:</p>
<ul>
<li>遍历dom树的所有节点</li>
<li>找到注册的属性类型的directives指令</li>
<li>调用对应的directive对应的link逻辑</li>
<li>管理scope</li>
</ul>
<p>Scope：</p>
<ul>
<li>监控表达式</li>
<li>在每次$digest循环的时候执行所有的表达式，直到稳定，稳定就是说，表达式的值不再改变的时候</li>
<li>在表达式的值发生改变时，调用对应的所有的回调函数</li>
</ul>
<p>怎么串起来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>&lt;span ng-bind=<span class="string">"a + 'hello'"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="title">span</span>&gt;</span></span>
</pre></td></tr></table></figure>

<p>我们看看<code>ng-bind</code>这个指令的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>Provider.directive(<span class="string">'ng-bind'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> {
    link: <span class="function"><span class="keyword">function</span> <span class="params">(el, scope, exp)</span> {</span>
      <span class="comment">//初次渲染的逻辑</span>
      el.innerHTML = scope.$<span class="built_in">eval</span>(exp);
      <span class="comment">//添加一个观察者，当在下一次脏检测发现数据改变时就执行回调逻辑</span>
      scope.$watch(exp, <span class="function"><span class="keyword">function</span> <span class="params">(val)</span> {</span>
        el.innerHTML = val;
      });
    }
  };
});
</pre></td></tr></table></figure>

<p>初始化时：DOMCompiler遍历dom节点，找到指令定义，执行link,写dom。并且通过scope的方法增加watcher观察者。</p>
<p>更新时：调用scope的digest，这个时候会遍历所有watchers，拿新的值跟旧的值做对比，如果不同就执行回调。</p>
<p>所以对于我们这边的简单例子来说，第一次初始化时，通过link函数我们第一次使用innerHTML来渲染dom。同时添加了一个watcher,这样在框架下次脏检测时，检测到数据变化就会调用回调里的逻辑，这里就是重新innerHTML。</p>
<p>具体可以看看<a href="http://purplebamboo.github.io/2015/05/27/use-200-line-code-to-implementation-a-simple-angular/" target="_blank">这篇文章</a>了解下它内部的渲染逻辑。</p>
<blockquote>
<p>当然这里只是给出了最简单的实现，其实这类模板的难点在于for,if这种指令的实现。这里受限于篇幅就不详细展开了。</p>
</blockquote>
<h4 id="分析">分析</h4>
<p>所以，angular的局部刷新，就是通过指令的私有逻辑来实现的。提出了一些比较好玩的概念。<br>我们再对比下之前说的那几个点：</p>
<ul>
<li><p>如何监听数据的变化：通过脏检测，用户在代码中调用<code>scope.$digest()</code>方法,在angularjs里面框架会在某些时候帮你调用。脏检测会负责遍历scope上面的所有观察者watcher。对比表达式的上一次值与现在的值，如果发现数据变化就会调用添加的回调逻辑。</p>
</li>
<li><p>如何渲染更新页面定位节点位置：通过指令，本身已经有了dom引用，一些特殊情况，会使用注释节点做占位符。</p>
</li>
<li><p>如何实现双向绑定：实现model指令，监听数据改变后先修改data数据，之后调用digest来一次脏检测更新就行了。</p>
</li>
<li><p>如何实现批量更新：脏检测本身就是批量的，因为是一次性调用digest才开始统一检查数据变化。</p>
</li>
</ul>
<h4 id="优点">优点</h4>
<ul>
<li>angular大而全，功能特别强大。集成了很多概念，社区也比较强大。</li>
<li>开发体验比较好。模板里的expression使用了自己的编译器去解析，所以支持很强大的语法。</li>
<li>提出了很多很好的概念，如filter，watcher。</li>
</ul>
<h4 id="缺点">缺点</h4>
<ul>
<li>很多功能不需要，难以单独拿出来跟业务结合</li>
<li>脏检测导致的性能问题，特别是大列表的局部刷新情况，watcher太多，导致性能巨差</li>
<li>直接解析现有dom带来不少问题，闪烁，属性错误等等</li>
<li>页面有多个实例时会经常出现脏检测的冲突</li>
<li>指令的写法，相对于传统的字符串模板，可读性差</li>
</ul>
<h3 id="vuejs">vuejs</h3>
<p>vue在学习angular的基础上，做了些精简还有优化。vue只负责处理view，其实是模板+组件方案+动画。我们这里主要看他的模板方面的原理</p>
<h4 id="原理-1">原理</h4>
<p>原理其实类似，也是有指令还有watcher的概念，只是去掉了scope，去掉了脏检测而是使用get set来做数据的变化监听。</p>
<p><img src="http://cn.vuejs.org/images/data.png" alt="222"></p>
<p>首先你需要先了解下<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank">defineProperty</a>,这个特性，可以达到在你对一个属性读或者写的时候写上自己的钩子函数。</p>
<p>整个原理是这样：</p>
<ul>
<li>先给数据注入get，set。递归注入，这样可以注入自己的钩子逻辑。</li>
<li>第一次compile的时候，找到页面上的指令，并且初始化指令，同时new一个watcher，第一次获取值。获取值的时候，触发get的钩子。这样就把key跟对应的watcher绑定起来。</li>
<li>watcher的回调不像angular那样自己写自己的私有逻辑，而是默认都是调用指令的update方法。</li>
<li>所以指令也是不同的，vue的指令有bind，update，destroy三个方法，分别负责初始化，更新，销毁需要做的事情。</li>
<li>当用户修改了值，会触发set，这样会通知对应绑定的watcher进行两次数据的校验，不同就触发回调，也就是对应指令的update方法。</li>
</ul>
<p>可以看到跟angular不同的地方主要在于，指令职责更细，另外有暴力的全部watcher检测，变成了通过set的钩子来指向性的找到对应的watcher做数据变更检测。所以在更新性能上会明显优于脏检测。</p>
<p>具体原理可以参考：<a href="http://cn.vuejs.org/guide/reactivity.html" target="_blank">http://cn.vuejs.org/guide/reactivity.html</a><br>还有：<a href="http://jiongks.name/blog/vue-code-review/" target="_blank">http://jiongks.name/blog/vue-code-review/</a></p>
<h4 id="分析-1">分析</h4>
<ul>
<li>如何监听数据的变化：通过defineproperties注入钩子，修改了数据就会出发钩子，然后通知对应的watcher进行检测</li>
<li>如何渲染更新页面定位节点位置： 也是通过指令，本身已经有了dom引用。而且vue很创新的使用了空白节点来占位。</li>
<li>如何实现双向绑定： 实现model指令，也是有私有逻辑，监听dom改变后，修改对应的data，钩子会自动触发完成更新。</li>
<li>如何实现批量更新：vue使用settimeOut,延迟watcher的check。通过去重watcher。达到批量更新的目的。当你多次调用赋值时不会立即去check数据的变更，而是在一次setTimeout后，开始检测队列。</li>
</ul>
<h4 id="特点">特点</h4>
<ul>
<li>相对angular来说，职责更清晰，去掉了很多不必要的东西，更加轻量</li>
<li>使用defineproperties解决了脏检测的性能问题，从暴力全量检测变成了指向性的检测</li>
<li>提出了空白占位节点的概念，解决了angular里面一堆注释节点的问题</li>
<li>动画功能很强大</li>
</ul>
<h4 id="缺点-1">缺点</h4>
<ul>
<li>defineproperties必须提前写好属性，侵入的改写get set。</li>
<li>不支持ie8</li>
<li>直接解析dom节点，（造成额外的404请求，一些写法有问题。因为提前渲染）</li>
<li>一直保留着对dom的引用。是否是一种浪费</li>
<li>初次渲染并不会比脏检测快，因为需要各种递归的注入。</li>
<li>指令写多了模板可读性太差。</li>
<li>暂时没有服务端渲染方案，因为依赖dom。</li>
</ul>
<p>其实这些缺点也都是angular会有的缺点，可以说vue已经解决了大部分的angular会有的问题。不过为了使用defineproperties放弃了支持ie8，对于国内的环境来说，ie8还是难以割舍。</p>
<h3 id="reactjs">reactjs</h3>
<p>reactjs创造性的提出了虚拟dom的概念，完全改变了前端的开发方式</p>
<h4 id="原理-2">原理</h4>
<p>react，其实就是虚拟dom与真实dom的互动。</p>
<p><img src="https://img.alicdn.com/tps/TB1NPA_JpXXXXcVXXXXXXXXXXXX-1024-768.jpg" alt="ddd"></p>
<p>最上面的<code>text,basic element,custom element</code>都是我们通常说的<code>virtual dom</code>。我们先不管红色的自定义组件节点<code>custom element</code>。</p>
<p>每一个<code>virtual dom</code>都有一个对应的<code>Component</code>来管理。<code>Component</code>具有两个方法：<code>mountComponent</code>还有<code>receiveComponent</code>分别负责处理初次渲染还有更新的逻辑。</p>
<p>react初次渲染就是拼接出字符串。每种<code>virtual dom</code>会调用自己的<code>Component</code>对应的<code>mountComponent</code>来得到渲染之后的内容。比如对于text就直接返回个span包裹的文本，对于basic element，需要先处理自身属性，再调用子节点对应的Component的mountComponent，最后全部拼接好，一次性的innerHTMl到页面上。</p>
<p>更新的时候，react里面一般是通过setState来赋予一个新的值，这样内部再调用receiveComponent来处理逻辑。对于basic element，就是先更新属性，再去更新子节点。这里有套算法，能复用的就直接调用子节点的receiveComponent。否则就是一次重新的mountComponent渲染（diff,patch）。对于text节点，直接是innerHTML更新。</p>
<p>具体原理参考：<a href="http://purplebamboo.github.io/2015/09/15/reactjs_source_analyze_part_one/" target="_blank">http://purplebamboo.github.io/2015/09/15/reactjs_source_analyze_part_one/</a></p>
<h4 id="分析-2">分析</h4>
<ul>
<li><p>如何监听数据的变化：很原始的get set（setState），跟我们最上面的<code>setChunkData</code>类似</p>
</li>
<li><p>如何渲染更新页面定位节点位置：不需要直接引用真实dom，引用虚拟dom就行。虚拟dom根据id来跟真实dom一一对应。</p>
</li>
<li><p>如何实现双向绑定：原生不支持双向绑定，不过有插件形式的替代方案。</p>
</li>
<li><p>如何实现批量更新：执行方法时会包裹一个batchUpdate。这样所有的setState会执行完以后再统一去diff。</p>
</li>
</ul>
<h4 id="特点-1">特点</h4>
<ul>
<li>创造性的提出了virtual dom的概念</li>
<li>支持服务端渲染</li>
<li>通过dom的diff，加快了更新速度</li>
</ul>
<h4 id="缺点-2">缺点</h4>
<ul>
<li>本质上还是脏检测，虽然这个脏检测是可以优化的</li>
<li>其实不存在模板语法，if，for都是要写js代码。理解起来很困难。</li>
<li>全家桶没办法跟其他的技术结合</li>
<li>不允许自己修改dom</li>
</ul>
<h2 id="思考">思考</h2>
<p>不管是 angularjs，vuejs，或者是reactjs，总感觉用起来不是那么顺手，原因是我们已经习惯了传统意义上的模板写法。所以这种dom based的模板总会有这样那样的限制，导致我们不能很顺畅的去开发。</p>
<p>上面这几种，目前我是比较喜欢vue的设计理念的，但是它也有着我们难以接受的缺点。不能说vue不优秀，只是的确不适合我们的业务。</p>
<p>那么我们是不是可以改造下，是否可以结合virtual dom 跟 指令的优势？</p>
<p>vue的指令是直接操作dom的，如果加一层virtual dom，实现大部分dom方法。让指令引用virtual dom，由virtual dom来操作真实dom。这样其实就可以解决掉vue的大部分问题。</p>
<p>我们可以先把模板解析成一个ast（抽象语法树）结构的虚拟dom树。然后去解析这个树，分析出各种依赖信息。这比vue直接使用原生dom会好很多。</p>
<p>指令不会直接跟dom打交道，而是跟虚拟dom打交道。</p>
<p>对于初次的渲染来说，各个指令会调用虚拟dom的方法，此时虚拟dom知道是初次渲染，所以只会更新自己，而不会修改真实的dom。在最后全部执行好后，一次性的innerHTML到页面中。有点跟react类似？</p>
<p>而更新的时候，仍然是指令的逻辑，只不过这个时候虚拟dom不仅仅会更新自身，也会同时更新真实的dom。</p>
<p>可以看到因为加了一层虚拟dom，解决了很多问题。</p>
<p>我们的基本原理还是vue的原理，但是通过一层中间虚拟dom层。我们可以做到：</p>
<ul>
<li>可以把模板的解析前置到打包阶段。打包出虚拟的virtual dom，像react那样，而vue是放到一个documentfragment，先渲染再改动。</li>
<li>初次渲染不再依赖真实dom，从而使服务器渲染可以像react那样变得比较简单。</li>
<li>因为不依赖dom，所以不会出现vue那样的非法指令的问题。</li>
<li>因为有一层中间dom。所以理论上可以支持任何语法，只要后面打包时转成虚拟dom的语法。</li>
</ul>
<p>所以 我做了pat，在vue的基础上加上vd的概念，当然还支持了ie8等等，为了支持业务做了一些改动。</p>
<p>一句话概括pat:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="function"><span class="title">listener</span><span class="params">(define<span class="variable">Properties</span>/dirtycheck)</span> + <span class="title">directive</span> + <span class="title">virtual</span> <span class="title">dom</span></span>
</pre></td></tr></table></figure>

<p>地址：<a href="http://purplebamboo.github.io/pat/doc/views/index.html" target="_blank">http://purplebamboo.github.io/pat/doc/views/index.html</a></p>
<p>与目前主要的框架相比，pat具有以下特点：</p>
<ul>
<li>单一职责，pat只负责解决模板问题。使用者可以单独使用，也可以跟任何其他框架结合使用。</li>
<li>支持类mustache风格的模板语法，避免了指令写多了模板可读性差的问题。</li>
<li>具有指令型框架的特点，扩展性强，功能强大，可以扩展自己的指令。同时支持filter与自定义watcher。</li>
<li>具有virtual dom中间层，一方面加快了分析指令的速度，另一方面也为服务端渲染提供了可能。还解决了错误属性的问题。而且没有强引用。</li>
<li>考虑到目前国内情况，pat做了大量事情，兼容到了ie8。</li>
<li>同时支持脏检测与defineProperties的数据检测机制。在defineProperties模式下使用vbscript来做ie8兼容处理。</li>
</ul>
<h2 id="结语">结语</h2>
<p>目前的前端界各种框架满天飞，但是都或多或少的有所缺陷。有句话说的好，没有最完美的方案只有最适合的自己的方案。</p>
<p>在这样的背景下作为一个前端遇到问题该怎么办呢，我认为可以先找开源技术，但是当开源技术不能满足自己的需求时。可以在开源技术的基础上修改加上自己的东西从而更好的解决问题。</p>
<p>其实把模板解析成ast已经有很多框架在做了。都是看重了virtual dom的优势。比如下面这些：</p>
<ul>
<li><a href="https://github.com/ractivejs/ractive" target="_blank">htmlbar</a>: 运行在handlebar之后的二次编译</li>
<li><a href="http://examples.ractivejs.org/todos" target="_blank">ractivejs</a>: 也是分析成虚拟dom</li>
<li><a href="https://github.com/regularjs/regular" target="_blank">Regularjs</a>: 网易的框架，在angular基础上改造而来</li>
<li><a href="https://github.com/kof/diff-renderer" target="_blank">diff-render</a>: facebook的人开发的，可以直接diff两个渲染好的字符串的差异，然后去更新。本质上每次都会解析成虚拟dom，然后像react那样diff这两个虚拟dom树</li>
</ul>
<p>总之前端的轮子真的太多了，但是无外乎那些解决方案，我们要做的就是了解这些方案，找到合适自己的，当没有特别合适的就拿一个加以改造解决自己的问题（于是又会造个轮子＝ ＝）。</p>
<h2 id="相关引用">相关引用</h2>
<ul>
<li><a href="http://div.io/topic/636" target="_blank">http://div.io/topic/636</a></li>
<li><a href="http://www.liaoxuefeng.com/article/001426512790239f83bfb47b1134b63b09a57548d06e5c5000" target="_blank">http://www.liaoxuefeng.com/article/001426512790239f83bfb47b1134b63b09a57548d06e5c5000</a></li>
<li><a href="http://www.cnblogs.com/hustskyking/p/principle-of-javascript-template.html" target="_blank">http://www.cnblogs.com/hustskyking/p/principle-of-javascript-template.html</a></li>
<li><a href="http://www.html-js.com/article/Regularjs-Chinese-guidelines-for-a-comprehensive-summary-of-the-front-template-technology" target="_blank">http://www.html-js.com/article/Regularjs-Chinese-guidelines-for-a-comprehensive-summary-of-the-front-template-technology</a></li>
<li><a href="http://www.toobug.net/article/how_to_design_front_end_template_engine.html" target="_blank">http://www.toobug.net/article/how_to_design_front_end_template_engine.html</a></li>
<li><a href="https://www.zhihu.com/question/32524504" target="_blank">https://www.zhihu.com/question/32524504</a></li>
<li><a href="http://ejohn.org/blog/javascript-micro-templating/" target="_blank">http://ejohn.org/blog/javascript-micro-templating/</a></li>
<li><a href="http://nuysoft.com/bak/templating.html" target="_blank">http://nuysoft.com/bak/templating.html</a></li>
</ul>
]]></content:encoded>
      <comments>http://purplebamboo.github.com/2016/04/21/about-partial-refresh/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[reactjs源码分析-下篇（更新机制实现原理）]]></title>
      <link>http://purplebamboo.github.com/2015/09/15/reactjs_source_analyze_part_two/</link>
      <guid>http://purplebamboo.github.com/2015/09/15/reactjs_source_analyze_part_two/</guid>
      <pubDate>Tue, 15 Sep 2015 05:23:13 GMT</pubDate>
      <description>
      <![CDATA[<p>reactjs是目前比较火的前端框架，但是目前并没有很好的解释原理的项目。reactjs源码比较复杂不适合初学者去学习。所以本文通过实现一套简易版的reactjs，使得理解原理更加容易。包括：</p>
<ul>
<li><a href="http://purplebambo]]>
      </description>
      <content:encoded><![CDATA[<p>reactjs是目前比较火的前端框架，但是目前并没有很好的解释原理的项目。reactjs源码比较复杂不适合初学者去学习。所以本文通过实现一套简易版的reactjs，使得理解原理更加容易。包括：</p>
<ul>
<li><a href="http://purplebamboo.github.io/2015/09/15/reactjs_source_analyze_part_one" target="_blank">reactjs源码分析-上篇（首次渲染实现原理）</a></li>
<li><a href="http://purplebamboo.github.io/2015/09/15/reactjs_source_analyze_part_two" target="_blank">reactjs源码分析-下篇（更新机制实现原理）</a></li>
</ul>
<p>声明：</p>
<ul>
<li>本文假定你已经对reactjs有了一定的了解，如果没有至少看下ruanyifeng老师的<a href="http://www.ruanyifeng.com/blog/2015/03/react.html" target="_blank">入门demo</a>。</li>
<li>jsx不在本文的讨论范围，所有的例子原理都是使用原生的javascript。</li>
<li>篇幅限制，服务器端的reactjs也不在本文讨论范围内。</li>
<li>为了演示方便，本文以jQuery作为基本工具库。</li>
<li>为了更清晰的演示原理，本文会忽略很多细节的东西，千万不要用于生产环境。</li>
</ul>
<p>所有实例源码都托管在github。<a href="https://github.com/purplebamboo/little-reactjs" target="_blank">点这里</a>里面有分步骤的例子，可以一边看一边运行例子。</p>
<h2 id="前言">前言</h2>
<p>紧接上文，虚拟dom差异化算法（diff algorithm）是reactjs最核心的东西，按照官方的说法。他非常快，非常高效。目前已经有一些分析此算法的文章，但是仅仅停留在表面。大部分小白看完并不能了解（博主就是 ＝ ＝）。所以我们下面自己动手实现一遍，等你完全实现了，再去看那些文字图片流的介绍文章，就会发现容易理解多了。</p>
<h2 id="实现更新机制">实现更新机制</h2>
<p>下面我们探讨下更新的机制。</p>
<p>一般在reactjs中我们需要更新时都是调用的setState。看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre>
<span class="keyword">var</span> HelloMessage = React.createClass({
  getInitialState: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> {type: <span class="string">'say:'</span>};
  },
  changeType:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">this</span>.setState({type:<span class="string">'shout:'</span>})
  },
  render: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> React.createElement(<span class="string">"div"</span>, {onclick:<span class="keyword">this</span>.changeType},<span class="keyword">this</span>.state.type, <span class="string">"Hello "</span>, <span class="keyword">this</span>.props.name);
  }
});


React.render(React.createElement(HelloMessage, {name: <span class="string">"John"</span>}), document.getElementById(<span class="string">"container"</span>));



<span class="comment">/**

//生成的html为：

&lt;div data-reactid="0" id="test"&gt;
    &lt;span data-reactid="0.0"&gt;hello world&lt;/span&gt;
&lt;/div&gt;

点击文字，say会变成shout

*/</span>
</pre></td></tr></table></figure>

<p>点击文字，调用setState就会更新，所以我们扩展下ReactClass，看下setState的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>
<span class="comment">//定义ReactClass类</span>
<span class="keyword">var</span> ReactClass = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
}

ReactClass.prototype.render = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>}

<span class="comment">//setState</span>
ReactClass.prototype.setState = <span class="function"><span class="keyword">function</span><span class="params">(newState)</span> {</span>

    <span class="comment">//还记得我们在ReactCompositeComponent里面mount的时候 做了赋值</span>
    <span class="comment">//所以这里可以拿到 对应的ReactCompositeComponent的实例_reactInternalInstance</span>
    <span class="keyword">this</span>._reactInternalInstance.receiveComponent(<span class="literal">null</span>, newState);
}
</pre></td></tr></table></figure>

<p>可以看到setState主要调用了对应的component的receiveComponent来实现更新。所有的挂载，更新都应该交给对应的component来管理。</p>
<p>就像所有的component都实现了mountComponent来处理第一次渲染，所有的componet类都应该实现receiveComponent用来处理自己的更新。</p>
<h3 id="自定义元素的receiveComponent">自定义元素的receiveComponent</h3>
<p>所以我们照葫芦画瓢来给自定义元素的对应component类（ReactCompositeComponent）实现一个receiveComponent方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
</pre></td><td class="code"><pre>
<span class="comment">//更新</span>
ReactCompositeComponent.prototype.receiveComponent = <span class="function"><span class="keyword">function</span><span class="params">(nextElement, newState)</span> {</span>

    <span class="comment">//如果接受了新的，就使用最新的element</span>
    <span class="keyword">this</span>._currentElement = nextElement || <span class="keyword">this</span>._currentElement

    <span class="keyword">var</span> inst = <span class="keyword">this</span>._instance;
    <span class="comment">//合并state</span>
    <span class="keyword">var</span> nextState = $.extend(inst.state, newState);
    <span class="keyword">var</span> nextProps = <span class="keyword">this</span>._currentElement.props;


    <span class="comment">//改写state</span>
    inst.state = nextState;


    <span class="comment">//如果inst有shouldComponentUpdate并且返回false。说明组件本身判断不要更新，就直接返回。</span>
    <span class="keyword">if</span> (inst.shouldComponentUpdate && (inst.shouldComponentUpdate(nextProps, nextState) === <span class="literal">false</span>)) <span class="keyword">return</span>;

    <span class="comment">//生命周期管理，如果有componentWillUpdate，就调用，表示开始要更新了。</span>
    <span class="keyword">if</span> (inst.componentWillUpdate) inst.componentWillUpdate(nextProps, nextState);


    <span class="keyword">var</span> prevComponentInstance = <span class="keyword">this</span>._renderedComponent;
    <span class="keyword">var</span> prevRenderedElement = prevComponentInstance._currentElement;
    <span class="comment">//重新执行render拿到对应的新element;</span>
    <span class="keyword">var</span> nextRenderedElement = <span class="keyword">this</span>._instance.render();


    <span class="comment">//判断是需要更新还是直接就重新渲染</span>
    <span class="comment">//注意这里的_shouldUpdateReactComponent跟上面的不同哦 这个是全局的方法</span>
    <span class="keyword">if</span> (_shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
        <span class="comment">//如果需要更新，就继续调用子节点的receiveComponent的方法，传入新的element更新子节点。</span>
        prevComponentInstance.receiveComponent(nextRenderedElement);
        <span class="comment">//调用componentDidUpdate表示更新完成了</span>
        inst.componentDidUpdate && inst.componentDidUpdate();

    } <span class="keyword">else</span> {
        <span class="comment">//如果发现完全是不同的两种element，那就干脆重新渲染了</span>
        <span class="keyword">var</span> thisID = <span class="keyword">this</span>._rootNodeID;
        <span class="comment">//重新new一个对应的component，</span>
        <span class="keyword">this</span>._renderedComponent = <span class="keyword">this</span>._instantiateReactComponent(nextRenderedElement);
        <span class="comment">//重新生成对应的元素内容</span>
        <span class="keyword">var</span> nextMarkup = _renderedComponent.mountComponent(thisID);
        <span class="comment">//替换整个节点</span>
        $(<span class="string">'[data-reactid="'</span> + <span class="keyword">this</span>._rootNodeID + <span class="string">'"]'</span>).replaceWith(nextMarkup);

    }

}

<span class="comment">//用来判定两个element需不需要更新</span>
<span class="comment">//这里的key是我们createElement的时候可以选择性的传入的。用来标识这个element，当发现key不同时，我们就可以直接重新渲染，不需要去更新了。</span>
<span class="keyword">var</span> _shouldUpdateReactComponent ＝ <span class="function"><span class="keyword">function</span><span class="params">(prevElement, nextElement)</span>{</span>
    <span class="keyword">if</span> (prevElement != <span class="literal">null</span> && nextElement != <span class="literal">null</span>) {
    <span class="keyword">var</span> prevType = <span class="keyword">typeof</span> prevElement;
    <span class="keyword">var</span> nextType = <span class="keyword">typeof</span> nextElement;
    <span class="keyword">if</span> (prevType === <span class="string">'string'</span> || prevType === <span class="string">'number'</span>) {
      <span class="keyword">return</span> nextType === <span class="string">'string'</span> || nextType === <span class="string">'number'</span>;
    } <span class="keyword">else</span> {
      <span class="keyword">return</span> nextType === <span class="string">'object'</span> && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
    }
  }
  <span class="keyword">return</span> <span class="literal">false</span>;
}
</pre></td></tr></table></figure>

<p>不要被这么多代码吓到，其实流程很简单。<br>它主要做了什么事呢？首先会合并改动，生成最新的state,props然后拿以前的render返回的element跟现在最新调用render生成的element进行对比（_shouldUpdateReactComponent），看看需不需要更新，如果要更新就继续调用对应的component类对应的receiveComponent就好啦，其实就是直接当甩手掌柜，事情直接丢给手下去办了。当然还有种情况是，两次生成的element差别太大，就不是一个类型的，那好办直接重新生成一份新的代码重新渲染一次就o了。</p>
<p>本质上还是递归调用receiveComponent的过程。</p>
<p>这里注意两个函数：</p>
<ul>
<li>inst.shouldComponentUpdate是实例方法，当我们不希望某次setState后更新，我们就可以重写这个方法，返回false就好了。</li>
<li>_shouldUpdateReactComponent是一个全局方法，这个是一种reactjs的优化机制。用来决定是直接全部替换，还是使用很细微的改动。当两次render出来的子节点key不同，直接全部重新渲染一遍，替换就好了。否则，我们就得来个递归的更新，保证最小化的更新机制，这样可以不会有太大的闪烁。</li>
</ul>
<p>另外可以看到这里还处理了一套更新的生命周期调用机制。</p>
<h3 id="文本节点的receiveComponent">文本节点的receiveComponent</h3>
<p>我们再看看文本节点的，比较简单：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>
ReactDOMTextComponent.prototype.receiveComponent = <span class="function"><span class="keyword">function</span><span class="params">(nextText)</span> {</span>
    <span class="keyword">var</span> nextStringText = <span class="string">''</span> + nextText;
    <span class="comment">//跟以前保存的字符串比较</span>
    <span class="keyword">if</span> (nextStringText !== <span class="keyword">this</span>._currentElement) {
        <span class="keyword">this</span>._currentElement = nextStringText;
        <span class="comment">//替换整个节点</span>
        $(<span class="string">'[data-reactid="'</span> + <span class="keyword">this</span>._rootNodeID + <span class="string">'"]'</span>).html(<span class="keyword">this</span>._currentElement);

    }
}
</pre></td></tr></table></figure>

<p>没什么好说的，如果不同的话，直接找到对应的节点，更新就好了。</p>
<h3 id="基本元素element的receiveComponent">基本元素element的receiveComponent</h3>
<p>最后我们开始看比较复杂的浏览器基本元素的更新机制。<br>比如我们看看下面的html:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"test"</span> <span class="attribute">name</span>=<span class="value">"hello"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">span</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>
    <span class="tag">&lt;<span class="title">span</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>

<p>想一下我们怎么以最小代价去更新这段html呢。不难发现其实主要包括两个部分：</p>
<ol>
<li>属性的更新，包括对特殊属性比如事件的处理</li>
<li>子节点的更新,这个比较复杂，为了得到最好的效率，我们需要处理下面这些问题：<ul>
<li>拿新的子节点树跟以前老的子节点树对比，找出他们之间的差别。我们称之为diff</li>
<li>所有差别找出后，再一次性的去更新。我们称之为patch</li>
</ul>
</li>
</ol>
<p>所以更新代码结构如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>
ReactDOMComponent.prototype.receiveComponent = <span class="function"><span class="keyword">function</span><span class="params">(nextElement)</span> {</span>
    <span class="keyword">var</span> lastProps = <span class="keyword">this</span>._currentElement.props;
    <span class="keyword">var</span> nextProps = nextElement.props;

    <span class="keyword">this</span>._currentElement = nextElement;
    <span class="comment">//需要单独的更新属性</span>
    <span class="keyword">this</span>._updateDOMProperties(lastProps, nextProps);
    <span class="comment">//再更新子节点</span>
    <span class="keyword">this</span>._updateDOMChildren(nextElement.props.children);
}
</pre></td></tr></table></figure>

<p>整体上也不复杂，先是处理当前节点属性的变动，后面再去处理子节点的变动</p>
<p>我们一步步来，先看看，更新属性怎么变更：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="code"><pre>
ReactDOMComponent.prototype._updateDOMProperties = <span class="function"><span class="keyword">function</span><span class="params">(lastProps, nextProps)</span> {</span>
    <span class="keyword">var</span> propKey;
    <span class="comment">//遍历，当一个老的属性不在新的属性集合里时，需要删除掉。</span>

    <span class="keyword">for</span> (propKey <span class="keyword">in</span> lastProps) {
        <span class="comment">//新的属性里有，或者propKey是在原型上的直接跳过。这样剩下的都是不在新属性集合里的。需要删除</span>
        <span class="keyword">if</span> (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
            <span class="keyword">continue</span>;
        }
        <span class="comment">//对于那种特殊的，比如这里的事件监听的属性我们需要去掉监听</span>
        <span class="keyword">if</span> (<span class="regexp">/^on[A-Za-z]/</span>.test(propKey)) {
            <span class="keyword">var</span> eventType = propKey.replace(<span class="string">'on'</span>, <span class="string">''</span>);
            <span class="comment">//针对当前的节点取消事件代理</span>
            $(document).undelegate(<span class="string">'[data-reactid="'</span> + <span class="keyword">this</span>._rootNodeID + <span class="string">'"]'</span>, eventType, lastProps[propKey]);
            <span class="keyword">continue</span>;
        }

        <span class="comment">//从dom上删除不需要的属性</span>
        $(<span class="string">'[data-reactid="'</span> + <span class="keyword">this</span>._rootNodeID + <span class="string">'"]'</span>).removeAttr(propKey)
    }

    <span class="comment">//对于新的属性，需要写到dom节点上</span>
    <span class="keyword">for</span> (propKey <span class="keyword">in</span> nextProps) {
        <span class="comment">//对于事件监听的属性我们需要特殊处理</span>
        <span class="keyword">if</span> (<span class="regexp">/^on[A-Za-z]/</span>.test(propKey)) {
            <span class="keyword">var</span> eventType = propKey.replace(<span class="string">'on'</span>, <span class="string">''</span>);
            <span class="comment">//以前如果已经有，说明有了监听，需要先去掉</span>
            lastProps[propKey] && $(document).undelegate(<span class="string">'[data-reactid="'</span> + <span class="keyword">this</span>._rootNodeID + <span class="string">'"]'</span>, eventType, lastProps[propKey]);
            <span class="comment">//针对当前的节点添加事件代理,以_rootNodeID为命名空间</span>
            $(document).delegate(<span class="string">'[data-reactid="'</span> + <span class="keyword">this</span>._rootNodeID + <span class="string">'"]'</span>, eventType + <span class="string">'.'</span> + <span class="keyword">this</span>._rootNodeID, nextProps[propKey]);
            <span class="keyword">continue</span>;
        }

        <span class="keyword">if</span> (propKey == <span class="string">'children'</span>) <span class="keyword">continue</span>;

        <span class="comment">//添加新的属性，或者是更新老的同名属性</span>
        $(<span class="string">'[data-reactid="'</span> + <span class="keyword">this</span>._rootNodeID + <span class="string">'"]'</span>).prop(propKey, nextProps[propKey])
    }

}
</pre></td></tr></table></figure>

<p>属性的变更并不是特别复杂，主要就是找到以前老的不用的属性直接去掉，新的属性赋值，并且注意其中特殊的事件属性做出特殊处理就行了。</p>
<p>下面我们看子节点的更新，也是最复杂的部分。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre>
ReactDOMComponent.prototype.receiveComponent = <span class="function"><span class="keyword">function</span><span class="params">(nextElement)</span>{</span>
    <span class="keyword">var</span> lastProps = <span class="keyword">this</span>._currentElement.props;
    <span class="keyword">var</span> nextProps = nextElement.props;

    <span class="keyword">this</span>._currentElement = nextElement;
    <span class="comment">//需要单独的更新属性</span>
    <span class="keyword">this</span>._updateDOMProperties(lastProps,nextProps);
    <span class="comment">//再更新子节点</span>
    <span class="keyword">this</span>._updateDOMChildren(nextProps.children);
}

<span class="comment">//全局的更新深度标识</span>
<span class="keyword">var</span> updateDepth = <span class="number">0</span>;
<span class="comment">//全局的更新队列，所有的差异都存在这里</span>
<span class="keyword">var</span> diffQueue = [];

ReactDOMComponent.prototype._updateDOMChildren = <span class="function"><span class="keyword">function</span><span class="params">(nextChildrenElements)</span>{</span>
    updateDepth++
    <span class="comment">//_diff用来递归找出差别,组装差异对象,添加到更新队列diffQueue。</span>
    <span class="keyword">this</span>._diff(diffQueue,nextChildrenElements);
    updateDepth--
    <span class="keyword">if</span>(updateDepth == <span class="number">0</span>){
        <span class="comment">//在需要的时候调用patch，执行具体的dom操作</span>
        <span class="keyword">this</span>._patch(diffQueue);
        diffQueue = [];
    }
}
</pre></td></tr></table></figure>

<p>就像我们之前说的一样，更新子节点包含两个部分，一个是递归的分析差异，把差异添加到队列中。然后在合适的时机调用<code>_patch</code>把差异应用到dom上。</p>
<p>那么什么是合适的时机，updateDepth又是干嘛的？</p>
<p>这里需要注意的是，<code>_diff</code>内部也会递归调用子节点的receiveComponent于是当某个子节点也是浏览器普通节点，就也会走_updateDOMChildren这一步。所以这里使用了updateDepth来记录递归的过程，只有等递归回来updateDepth为0时，代表整个差异已经分析完毕，可以开始使用patch来处理差异队列了。</p>
<p>所以我们关键是实现<code>_diff</code>与<code>_patch</code>两个方法。</p>
<p>我们先看_diff的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
</pre></td><td class="code"><pre><span class="comment">//差异更新的几种类型</span>
<span class="keyword">var</span> UPATE_TYPES = {
    MOVE_EXISTING: <span class="number">1</span>,
    REMOVE_NODE: <span class="number">2</span>,
    INSERT_MARKUP: <span class="number">3</span>
}


<span class="comment">//普通的children是一个数组，此方法把它转换成一个map,key就是element的key,如果是text节点或者element创建时并没有传入key,就直接用在数组里的index标识</span>
<span class="function"><span class="keyword">function</span> <span class="title">flattenChildren</span><span class="params">(componentChildren)</span> {</span>
    <span class="keyword">var</span> child;
    <span class="keyword">var</span> name;
    <span class="keyword">var</span> childrenMap = {};
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; componentChildren.length; i++) {
        child = componentChildren[i];
        name = child && child._currentelement && child._currentelement.key ? child._currentelement.key : i.toString(<span class="number">36</span>);
        childrenMap[name] = child;
    }
    <span class="keyword">return</span> childrenMap;
}


<span class="comment">//主要用来生成子节点elements的component集合</span>
<span class="comment">//这边注意，有个判断逻辑，如果发现是更新，就会继续使用以前的componentInstance,调用对应的receiveComponent。</span>
<span class="comment">//如果是新的节点，就会重新生成一个新的componentInstance，</span>
<span class="function"><span class="keyword">function</span> <span class="title">generateComponentChildren</span><span class="params">(prevChildren, nextChildrenElements)</span> {</span>
    <span class="keyword">var</span> nextChildren = {};
    nextChildrenElements = nextChildrenElements || [];
    $.each(nextChildrenElements, <span class="function"><span class="keyword">function</span><span class="params">(index, element)</span> {</span>
        <span class="keyword">var</span> name = element.key ? element.key : index;
        <span class="keyword">var</span> prevChild = prevChildren && prevChildren[name];
        <span class="keyword">var</span> prevElement = prevChild && prevChild._currentElement;
        <span class="keyword">var</span> nextElement = element;

        <span class="comment">//调用_shouldUpdateReactComponent判断是否是更新</span>
        <span class="keyword">if</span> (_shouldUpdateReactComponent(prevElement, nextElement)) {
            <span class="comment">//更新的话直接递归调用子节点的receiveComponent就好了</span>
            prevChild.receiveComponent(nextElement);
            <span class="comment">//然后继续使用老的component</span>
            nextChildren[name] = prevChild;
        } <span class="keyword">else</span> {
            <span class="comment">//对于没有老的，那就重新新增一个，重新生成一个component</span>
            <span class="keyword">var</span> nextChildInstance = instantiateReactComponent(nextElement, <span class="literal">null</span>);
            <span class="comment">//使用新的component</span>
            nextChildren[name] = nextChildInstance;
        }
    })

    <span class="keyword">return</span> nextChildren;
}



<span class="comment">//_diff用来递归找出差别,组装差异对象,添加到更新队列diffQueue。</span>
ReactDOMComponent.prototype._diff = <span class="function"><span class="keyword">function</span><span class="params">(diffQueue, nextChildrenElements)</span> {</span>
  <span class="keyword">var</span> self = <span class="keyword">this</span>;
  <span class="comment">//拿到之前的子节点的 component类型对象的集合,这个是在刚开始渲染时赋值的，记不得的可以翻上面</span>
  <span class="comment">//_renderedChildren 本来是数组，我们搞成map</span>
  <span class="keyword">var</span> prevChildren = flattenChildren(self._renderedChildren);
  <span class="comment">//生成新的子节点的component对象集合，这里注意，会复用老的component对象</span>
  <span class="keyword">var</span> nextChildren = generateComponentChildren(prevChildren, nextChildrenElements);
  <span class="comment">//重新赋值_renderedChildren，使用最新的。</span>
  self._renderedChildren = []
  $.each(nextChildren, <span class="function"><span class="keyword">function</span><span class="params">(key, instance)</span> {</span>
    self._renderedChildren.push(instance);
  })


  <span class="keyword">var</span> nextIndex = <span class="number">0</span>; <span class="comment">//代表到达的新的节点的index</span>
  <span class="comment">//通过对比两个集合的差异，组装差异节点添加到队列中</span>
  <span class="keyword">for</span> (name <span class="keyword">in</span> nextChildren) {
    <span class="keyword">if</span> (!nextChildren.hasOwnProperty(name)) {
      <span class="keyword">continue</span>;
    }
    <span class="keyword">var</span> prevChild = prevChildren && prevChildren[name];
    <span class="keyword">var</span> nextChild = nextChildren[name];
    <span class="comment">//相同的话，说明是使用的同一个component,所以我们需要做移动的操作</span>
    <span class="keyword">if</span> (prevChild === nextChild) {
      <span class="comment">//添加差异对象，类型：MOVE_EXISTING</span>
      diffQueue.push({
        parentId: self._rootNodeID,
        parentNode: $(<span class="string">'[data-reactid='</span> + self._rootNodeID + <span class="string">']'</span>),
        type: UPATE_TYPES.MOVE_EXISTING,
        fromIndex: prevChild._mountIndex,
        toIndex: nextIndex
      })
    } <span class="keyword">else</span> { <span class="comment">//如果不相同，说明是新增加的节点</span>
      <span class="comment">//但是如果老的还存在，就是element不同，但是component一样。我们需要把它对应的老的element删除。</span>
      <span class="keyword">if</span> (prevChild) {
        <span class="comment">//添加差异对象，类型：REMOVE_NODE</span>
        diffQueue.push({
          parentId: self._rootNodeID,
          parentNode: $(<span class="string">'[data-reactid='</span> + self._rootNodeID + <span class="string">']'</span>),
          type: UPATE_TYPES.REMOVE_NODE,
          fromIndex: prevChild._mountIndex,
          toIndex: <span class="literal">null</span>
        })

        <span class="comment">//如果以前已经渲染过了，记得先去掉以前所有的事件监听，通过命名空间全部清空</span>
        <span class="keyword">if</span> (prevChild._rootNodeID) {
            $(document).undelegate(<span class="string">'.'</span> + prevChild._rootNodeID);
        }

      }
      <span class="comment">//新增加的节点，也组装差异对象放到队列里</span>
      <span class="comment">//添加差异对象，类型：INSERT_MARKUP</span>
      diffQueue.push({
        parentId: self._rootNodeID,
        parentNode: $(<span class="string">'[data-reactid='</span> + self._rootNodeID + <span class="string">']'</span>),
        type: UPATE_TYPES.INSERT_MARKUP,
        fromIndex: <span class="literal">null</span>,
        toIndex: nextIndex,
        markup: nextChild.mountComponent() <span class="comment">//新增的节点，多一个此属性，表示新节点的dom内容</span>
      })
    }
    <span class="comment">//更新mount的index</span>
    nextChild._mountIndex = nextIndex;
    nextIndex++;
  }



  <span class="comment">//对于老的节点里有，新的节点里没有的那些，也全都删除掉</span>
  <span class="keyword">for</span> (name <span class="keyword">in</span> prevChildren) {
    <span class="keyword">if</span> (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
      <span class="comment">//添加差异对象，类型：REMOVE_NODE</span>
      diffQueue.push({
        parentId: self._rootNodeID,
        parentNode: $(<span class="string">'[data-reactid='</span> + self._rootNodeID + <span class="string">']'</span>),
        type: UPATE_TYPES.REMOVE_NODE,
        fromIndex: prevChild._mountIndex,
        toIndex: <span class="literal">null</span>
      })
      <span class="comment">//如果以前已经渲染过了，记得先去掉以前所有的事件监听</span>
      <span class="keyword">if</span> (prevChildren[name]._rootNodeID) {
        $(document).undelegate(<span class="string">'.'</span> + prevChildren[name]._rootNodeID);
      }
    }
  }
}
</pre></td></tr></table></figure>

<p>我们分析下上面的代码，咋一看好多，好复杂，不急我们从入口开始看。</p>
<p>首先我们拿到之前的component的集合，如果是第一次更新的话，这个值是我们在渲染时赋值的。然后我们调用generateComponentChildren生成最新的component集合。我们知道component是用来放element的，一个萝卜一个坑。</p>
<p>注意flattenChildren我们这里把数组集合转成了对象map,以element的key作为标识，当然对于text文本或者没有传入key的element,直接用index作为标识。通过这些标识，我们可以从类型的角度来判断两个component是否是一样的。</p>
<p>generateComponentChildren会尽量的复用以前的component，也就是那些坑，当发现可以复用component（也就是key一致）时，就还用以前的，只需要调用他对应的更新方法receiveComponent就行了，这样就会递归的去获取子节点的差异对象然后放到队列了。如果发现不能复用那就是新的节点，我们就需要instantiateReactComponent重新生成一个新的component。</p>
<blockquote>
<p>这里的flattenChildren需要给予很大的关注，比如对于一个表格列表，我们在最前面插入了一条数据，想一下如果我们创建element时没有传入key，所有的key都是null,这样reactjs在generateComponentChildren时就会默认通过顺序（index）来一一对应改变前跟改变后的子节点，这样变更前与变更后的对应节点判断（_shouldUpdateReactComponent）其实是不合适的。也就是说对于这种列表的情况，我们最好给予唯一的标识key，这样reactjs找对应关系时会更方便一点。</p>
</blockquote>
<p>当我们生成好新的component集合以后，我们需要做出对比。组装差异对象。</p>
<p>对比老的集合和新的集合。我们需要找出涵盖四种情况，包括三种类型（UPATE_TYPES）的变动：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>MOVE_EXISTING</td>
<td>新的component类型在老的集合里也有，并且element是可以更新的类型，在generateComponentChildren我们已经调用了receiveComponent，这种情况下prevChild=nextChild,那我们就需要做出移动的操作，可以复用以前的dom节点。</td>
</tr>
<tr>
<td>INSERT_MARKUP</td>
<td>新的component类型不在老的集合里，那么就是全新的节点，我们需要插入新的节点</td>
</tr>
<tr>
<td>REMOVE_NODE</td>
<td>老的component类型，在新的集合里也有，但是对应的element不同了不能直接复用直接更新，那我们也得删除。</td>
</tr>
<tr>
<td>REMOVE_NODE</td>
<td>老的component不在新的集合里的，我们需要删除</td>
</tr>
</tbody>
</table>
<p>所以我们找出了这三种类型的差异，组装成具体的差异对象，然后加到了差异队列里面。</p>
<p>比如我们看下面这个例子，假设下面这些是某个父元素的子元素集合，上面到下面代表了变动流程：</p>
<p><img src="https://img.alicdn.com/tps/TB1oUcQJpXXXXawXVXXXXXXXXXX-1024-768.jpg" alt="变动"></p>
<p>数字我们可以理解为给element的key。</p>
<p>正方形代表element。圆形代表了component。当然也是实际上的dom节点的位置。</p>
<p>从上到下，我们的4 2 1里 2 ，1可以复用之前的component,让他们通知自己的子节点更新后，再告诉2和1，他们在新的集合里需要移动的位置（在我们这里就是组装差异对象加到队列）。3需要删除，4需要新增。</p>
<p>好了，整个的diff就完成了，这个时候当递归完成，我们就需要开始做patch的动作了，把这些差异对象实打实的反映到具体的dom节点上。</p>
<p>我们看下_patch的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></td><td class="code"><pre>

<span class="comment">//用于将childNode插入到指定位置</span>
<span class="function"><span class="keyword">function</span> <span class="title">insertChildAt</span><span class="params">(parentNode, childNode, index)</span> {</span>
    <span class="keyword">var</span> beforeChild = parentNode.children().get(index);
    beforeChild ? childNode.insertBefore(beforeChild) : childNode.appendTo(parentNode);
}

ReactDOMComponent.prototype._patch = <span class="function"><span class="keyword">function</span><span class="params">(updates)</span> {</span>
    <span class="keyword">var</span> update;
    <span class="keyword">var</span> initialChildren = {};
    <span class="keyword">var</span> deleteChildren = [];
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; updates.length; i++) {
        update = updates[i];
        <span class="keyword">if</span> (update.type === UPATE_TYPES.MOVE_EXISTING || update.type === UPATE_TYPES.REMOVE_NODE) {
            <span class="keyword">var</span> updatedIndex = update.fromIndex;
            <span class="keyword">var</span> updatedChild = $(update.parentNode.children().get(updatedIndex));
            <span class="keyword">var</span> parentID = update.parentID;

            <span class="comment">//所有需要更新的节点都保存下来，方便后面使用</span>
            initialChildren[parentID] = initialChildren[parentID] || [];
            <span class="comment">//使用parentID作为简易命名空间</span>
            initialChildren[parentID][updatedIndex] = updatedChild;


            <span class="comment">//所有需要修改的节点先删除,对于move的，后面再重新插入到正确的位置即可</span>
            deleteChildren.push(updatedChild)
        }

    }

    <span class="comment">//删除所有需要先删除的</span>
    $.each(deleteChildren, <span class="function"><span class="keyword">function</span><span class="params">(index, child)</span> {</span>
        $(child).remove();
    })


    <span class="comment">//再遍历一次，这次处理新增的节点，还有修改的节点这里也要重新插入</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; updates.length; k++) {
        update = updates[k];
        <span class="keyword">switch</span> (update.type) {
            <span class="keyword">case</span> UPATE_TYPES.INSERT_MARKUP:
                insertChildAt(update.parentNode, $(update.markup), update.toIndex);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> UPATE_TYPES.MOVE_EXISTING:
                insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> UPATE_TYPES.REMOVE_NODE:
                <span class="comment">// 什么都不需要做，因为上面已经帮忙删除掉了</span>
                <span class="keyword">break</span>;
        }
    }
}
</pre></td></tr></table></figure>

<p><code>_patch</code>主要就是挨个遍历差异队列，遍历两次，第一次删除掉所有需要变动的节点，然后第二次插入新的节点还有修改的节点。这里为什么可以直接挨个的插入呢？原因就是我们在diff阶段添加差异节点到差异队列时，本身就是有序的，也就是说对于新增节点（包括move和insert的）在队列里的顺序就是最终dom的顺序，所以我们才可以挨个的直接根据index去塞入节点。</p>
<p>但是其实你会发现这里有个问题，就是所有的节点都会被删除，包括复用以前的component类型为<code>UPATE_TYPES.MOVE_EXISTING</code>的，所以闪烁会很严重。其实我们再看看上面的例子，其实2是不需要记录到差异队列的。这样后面patch也是ok的。想想是为什么呢？</p>
<p>我们来改造下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td><td class="code"><pre>
<span class="comment">//_diff用来递归找出差别,组装差异对象,添加到更新队列diffQueue。</span>
ReactDOMComponent.prototype._diff = <span class="function"><span class="keyword">function</span><span class="params">(diffQueue, nextChildrenElements)</span>{</span>
    。。。
    <span class="comment">/**注意新增代码**/</span>
    <span class="keyword">var</span> lastIndex = <span class="number">0</span>;<span class="comment">//代表访问的最后一次的老的集合的位置</span>
    <span class="keyword">var</span> nextIndex = <span class="number">0</span>;<span class="comment">//代表到达的新的节点的index</span>
    <span class="comment">//通过对比两个集合的差异，组装差异节点添加到队列中</span>
    <span class="keyword">for</span> (name <span class="keyword">in</span> nextChildren) {
        <span class="keyword">if</span> (!nextChildren.hasOwnProperty(name)) {
          <span class="keyword">continue</span>;
        }
        <span class="keyword">var</span> prevChild = prevChildren && prevChildren[name];
        <span class="keyword">var</span> nextChild = nextChildren[name];
        <span class="comment">//相同的话，说明是使用的同一个component,所以我们需要做移动的操作</span>
        <span class="keyword">if</span> (prevChild === nextChild) {
          <span class="comment">//添加差异对象，类型：MOVE_EXISTING</span>
          。。。。
          <span class="comment">/**注意新增代码**/</span>
          prevChild._mountIndex &lt; lastIndex && diffQueue.push({
                parentId:<span class="keyword">this</span>._rootNodeID,
                parentNode:$(<span class="string">'[data-reactid='</span>+<span class="keyword">this</span>._rootNodeID+<span class="string">']'</span>),
                type: UPATE_TYPES.REMOVE_NODE,
                fromIndex: prevChild._mountIndex,
                toIndex:<span class="literal">null</span>
          })
          lastIndex = <span class="built_in">Math</span>.max(prevChild._mountIndex, lastIndex);
        } <span class="keyword">else</span> {
          <span class="comment">//如果不相同，说明是新增加的节点，</span>
          <span class="keyword">if</span> (prevChild) {
            <span class="comment">//但是如果老的还存在，就是element不同，但是component一样。我们需要把它对应的老的element删除。</span>
            <span class="comment">//添加差异对象，类型：REMOVE_NODE</span>
            。。。。。
            <span class="comment">/**注意新增代码**/</span>
            lastIndex = <span class="built_in">Math</span>.max(prevChild._mountIndex, lastIndex);
          }
          。。。
        }
        <span class="comment">//更新mount的inddex</span>
        nextChild._mountIndex = nextIndex;
        nextIndex++;
      }

      <span class="comment">//对于老的节点里有，新的节点里没有的那些，也全都删除掉</span>
      。。。
}
</pre></td></tr></table></figure>

<p>可以看到我们多加了个lastIndex，这个代表最后一次访问的老集合节点的最大的位置。<br>而我们加了个判断，只有_mountIndex小于这个lastIndex的才会需要加入差异队列。有了这个判断上面的例子2就不需要move。而程序也可以好好的运行，实际上大部分都是2这种情况。</p>
<p>这是一种顺序优化，lastIndex一直在更新，代表了当前访问的最右的老的集合的元素。<br>我们假设上一个元素是A,添加后更新了lastIndex。<br>如果我们这时候来个新元素B，比lastIndex还大说明当前元素在老的集合里面就比上一个A靠后。所以这个元素就算不加入差异队列，也不会影响到其他人，不会影响到后面的path插入节点。因为我们从patch里面知道，新的集合都是按顺序从头开始插入元素的，只有当新元素比lastIndex小时才需要变更。其实只要仔细推敲下上面那个例子，就可以理解这种优化手段了。</p>
<p>这样整个的更新机制就完成了。我们再来简单回顾下reactjs的差异算法：</p>
<p>首先是所有的component都实现了receiveComponent来负责自己的更新，而浏览器默认元素的更新最为复杂，也就是经常说的 diff algorithm。</p>
<p>react有一个全局_shouldUpdateReactComponent用来根据element的key来判断是更新还是重新渲染，这是第一个差异判断。比如自定义元素里，就使用这个判断，通过这种标识判断，会变得特别高效。</p>
<p>每个类型的元素都要处理好自己的更新：</p>
<ol>
<li><p>自定义元素的更新，主要是更新render出的节点，做甩手掌柜交给render出的节点的对应component去管理更新。</p>
</li>
<li><p>text节点的更新很简单，直接更新文案。</p>
</li>
<li><p>浏览器基本元素的更新，分为两块：</p>
<ul>
<li>先是更新属性，对比出前后属性的不同，局部更新。并且处理特殊属性，比如事件绑定。</li>
<li>然后是子节点的更新，子节点更新主要是找出差异对象，找差异对象的时候也会使用上面的_shouldUpdateReactComponent来判断，如果是可以直接更新的就会递归调用子节点的更新，这样也会递归查找差异对象，这里还会使用lastIndex这种做一种优化，使一些节点保留位置，之后根据差异对象操作dom元素（位置变动，删除，添加等）。</li>
</ul>
</li>
</ol>
<p>整个reactjs的差异算法就是这个样子。最核心的两个_shouldUpdateReactComponent以及diff,patch算法。</p>
<h2 id="小试牛刀">小试牛刀</h2>
<p>有了上面简易版的reaactjs，我们来实现一个简单的todolist吧。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre>
<span class="keyword">var</span> TodoList = React.createClass({
  getInitialState: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> {items: []};
  },
  add:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> nextItems = <span class="keyword">this</span>.state.items.concat([<span class="keyword">this</span>.state.text]);
    <span class="keyword">this</span>.setState({items: nextItems, text: <span class="string">''</span>});
  },
  onChange: <span class="function"><span class="keyword">function</span><span class="params">(e)</span> {</span>
    <span class="keyword">this</span>.setState({text: e.target.value});
  },
  render: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> createItem = <span class="function"><span class="keyword">function</span><span class="params">(itemText)</span> {</span>
      <span class="keyword">return</span> React.createElement(<span class="string">"div"</span>, <span class="literal">null</span>, itemText);
    };

    <span class="keyword">var</span> lists = <span class="keyword">this</span>.state.items.map(createItem);
    <span class="keyword">var</span> input = React.createElement(<span class="string">"input"</span>, {onkeyup: <span class="keyword">this</span>.onChange.bind(<span class="keyword">this</span>),value: <span class="keyword">this</span>.state.text});
    <span class="keyword">var</span> button = React.createElement(<span class="string">"p"</span>, {onclick: <span class="keyword">this</span>.add.bind(<span class="keyword">this</span>)}, <span class="string">'Add#'</span> + (<span class="keyword">this</span>.state.items.length + <span class="number">1</span>))
    <span class="keyword">var</span> children = lists.concat([input,button])

    <span class="keyword">return</span> React.createElement(<span class="string">"div"</span>, <span class="literal">null</span>,children);
  }
});


React.render(React.createElement(TodoList), document.getElementById(<span class="string">"container"</span>));
</pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://img.alicdn.com/tps/TB1bPcWJpXXXXcwXFXXXXXXXXXX-537-228.gif" alt="todolist"></p>
<p>整个的流程是这样：</p>
<ul>
<li>初次渲染时先使用<code>ReactCompositeComponent</code>渲染自定义元素TodoList，调用getInitialState拿到初始值，然后使用<code>ReactDOMComponent</code>渲染render返回的div基本元素节点。div基本元素再一层层的使用<code>ReactDOMComponent</code>去渲染各个子节点,包括input,还有p。</li>
<li>在input框输入文字触发onchange事件，开始调用setState做出变更，直接变更render出来的节点，经过差异算法，一层层的往下。最后改变value值。</li>
<li>点击按钮，触发add然后开始更新，经过差异算法，添加一个节点。同时更新按钮上面的文案。</li>
</ul>
<p>基本上，整个流程都梳理清楚了</p>
<h1 id="结语">结语</h1>
<p>这只是个玩具，但实现了reactjs最核心的功能，虚拟节点，差异算法，单向数据更新都在这里了。还有很多reactjs优秀的东西没有实现，比如对象生成时内存的线程池管理，批量更新机制，事件的优化，服务端的渲染，immutable data等等。这些东西受限于篇幅就不具体展开了。</p>
<p>reactjs作为一种解决方案，虚拟节点的想法比较新奇，不过个人还是不能接受这种别扭的写法。使用reactjs，就要使用他那一整套的开发方式，而他核心的功能其实只是一个差异算法，而这种其实已经有相关的库实现了。</p>
<p>最后再吐槽下前端真是苦命，各种新技术，各种新知识脑细胞不够用了。也难怪前端永远都缺人。</p>
<p>相关资料：</p>
<ol>
<li><a href="http://freestyle21.cn/2015/06/21/react-diff-%E7%AE%97%E6%B3%95/" target="_blank">http://freestyle21.cn/2015/06/21/react-diff-%E7%AE%97%E6%B3%95/</a></li>
<li><a href="https://github.com/Matt-Esch/virtual-dom" target="_blank">https://github.com/Matt-Esch/virtual-dom</a></li>
<li><a href="http://zjumty.iteye.com/blog/2207030" target="_blank">http://zjumty.iteye.com/blog/2207030</a></li>
<li><a href="http://hao.jser.com/archive/7871/" target="_blank">http://hao.jser.com/archive/7871/</a></li>
<li><a href="https://github.com/miniflycn/qvd/issues/1" target="_blank">https://github.com/miniflycn/qvd/issues/1</a></li>
<li><a href="http://fluentconf.com/fluent2014/public/schedule/detail/32395" target="_blank">http://fluentconf.com/fluent2014/public/schedule/detail/32395</a></li>
<li><a href="http://calendar.perfplanet.com/2013/diff/" target="_blank">http://calendar.perfplanet.com/2013/diff/</a></li>
<li><a href="http://segmentfault.com/a/1190000000606216" target="_blank">http://segmentfault.com/a/1190000000606216</a></li>
<li><a href="http://hulufei.gitbooks.io/react-tutorial/content/introduction.html" target="_blank">http://hulufei.gitbooks.io/react-tutorial/content/introduction.html</a></li>
<li><a href="http://reactjs.cn/react/docs/multiple-components.html" target="_blank">http://reactjs.cn/react/docs/multiple-components.html</a></li>
<li><a href="http://facebook.github.io/react/docs/multiple-components.html" target="_blank">http://facebook.github.io/react/docs/multiple-components.html</a></li>
</ol>
]]></content:encoded>
      <comments>http://purplebamboo.github.com/2015/09/15/reactjs_source_analyze_part_two/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[reactjs源码分析-上篇（首次渲染实现原理）]]></title>
      <link>http://purplebamboo.github.com/2015/09/15/reactjs_source_analyze_part_one/</link>
      <guid>http://purplebamboo.github.com/2015/09/15/reactjs_source_analyze_part_one/</guid>
      <pubDate>Tue, 15 Sep 2015 05:23:08 GMT</pubDate>
      <description>
      <![CDATA[<p>reactjs是目前比较火的前端框架，但是目前并没有很好的解释原理的项目。reactjs源码比较复杂不适合初学者去学习。所以本文通过实现一套简易版的reactjs，使得理解原理更加容易。包括：</p>
<ul>
<li><a href="http://purplebambo]]>
      </description>
      <content:encoded><![CDATA[<p>reactjs是目前比较火的前端框架，但是目前并没有很好的解释原理的项目。reactjs源码比较复杂不适合初学者去学习。所以本文通过实现一套简易版的reactjs，使得理解原理更加容易。包括：</p>
<ul>
<li><a href="http://purplebamboo.github.io/2015/09/15/reactjs_source_analyze_part_one" target="_blank">reactjs源码分析-上篇（首次渲染实现原理）</a></li>
<li><a href="http://purplebamboo.github.io/2015/09/15/reactjs_source_analyze_part_two" target="_blank">reactjs源码分析-下篇（更新机制实现原理）</a></li>
</ul>
<p>声明：</p>
<ul>
<li>本文假定你已经对reactjs有了一定的了解，如果没有至少看下ruanyifeng老师的<a href="http://www.ruanyifeng.com/blog/2015/03/react.html" target="_blank">入门demo</a>。</li>
<li>jsx不在本文的讨论范围，所有的例子原理都是使用原生的javascript。</li>
<li>篇幅限制，服务器端的reactjs也不在本文讨论范围内。</li>
<li>为了演示方便，本文以jQuery作为基本工具库。</li>
<li>为了更清晰的演示原理，本文会忽略很多细节的东西，千万不要用于生产环境。</li>
</ul>
<p>所有实例源码都托管在github。<a href="https://github.com/purplebamboo/little-reactjs" target="_blank">点这里</a>里面有分步骤的例子，可以一边看一边运行例子。</p>
<h2 id="前言">前言</h2>
<p>前端的发展特别快，经历过jQuery一统天下的工具库时代后，现在各种框架又开始百家争鸣了。angular，ember，backbone，vue，avalon，ploymer还有reactjs，作为一个前端真是稍不留神就感觉要被淘汰了，就在去年大家还都是angularjs的粉丝，到了今年又开始各种狂追reactjs了。前端都是喜新厌旧的，不知道最后这些框架由谁来一统天下，用句很俗的话说，这是最好的时代也是最坏的时代。作为一个前端，只能多学点，尽量多的了解他们的原理。</p>
<p>reactjs的代码非常绕，对于没有后台开发经验的前端来说看起来会比较吃力。其实reactjs的核心内容并不多，主要是下面这些：</p>
<ul>
<li>虚拟dom对象(Virtual DOM)</li>
<li>虚拟dom差异化算法（diff algorithm）</li>
<li>单向数据流渲染（Data Flow）</li>
<li>组件生命周期</li>
<li>事件处理</li>
</ul>
<p>下面我们将一点点的来实现一个简易版的reactjs，实现上面的那些功能，最后用这个reactjs做一个todolist的小应用，看完这个，或者跟着敲一遍代码。希望让大家能够更好的理解reactjs的运行原理。</p>
<h2 id="先从最简单的开始">先从最简单的开始</h2>
<p>我们先从渲染hello world开始吧。</p>
<p>我们看下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>
&lt;script type="text/javascript"&gt;
React.render('hello world',document.getElementById("container"))
&lt;/script&gt;

/**
对应的html为

&lt;div id="container"&gt;&lt;/div&gt;


生成后的html为：

&lt;div id="container"&gt;
    &lt;span data-reactid="0"&gt;hello world&lt;/span&gt;
&lt;/div&gt;

*/
</pre></td></tr></table></figure>

<p>假定这一行代码,就可以把<code>hello world</code>渲染到对应的div里面。</p>
<p>我们来看看我们需要为此做些什么：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre>
<span class="comment">//component类，用来表示文本在渲染，更新，删除时应该做些什么事情</span>
<span class="function"><span class="keyword">function</span> <span class="title">ReactDOMTextComponent</span><span class="params">(text)</span> {</span>
    <span class="comment">//存下当前的字符串</span>
    <span class="keyword">this</span>._currentElement = <span class="string">''</span> + text;
    <span class="comment">//用来标识当前component</span>
    <span class="keyword">this</span>._rootNodeID = <span class="literal">null</span>;
}

<span class="comment">//component渲染时生成的dom结构</span>
ReactDOMTextComponent.prototype.mountComponent = <span class="function"><span class="keyword">function</span><span class="params">(rootID)</span> {</span>
    <span class="keyword">this</span>._rootNodeID = rootID;
    <span class="keyword">return</span> <span class="string">'&lt;span data-reactid="'</span> + rootID + <span class="string">'"&gt;'</span> + <span class="keyword">this</span>._currentElement + <span class="string">'&lt;/span&gt;'</span>;
}


<span class="comment">//component工厂  用来返回一个component实例</span>
<span class="function"><span class="keyword">function</span> <span class="title">instantiateReactComponent</span><span class="params">(node)</span>{</span>
    <span class="keyword">if</span>(<span class="keyword">typeof</span> node === <span class="string">'string'</span> || <span class="keyword">typeof</span> node === <span class="string">'number'</span>){
        <span class="keyword">return</span> <span class="keyword">new</span> ReactDOMTextComponent(node)
    }
}


React = {
    nextReactRootIndex:<span class="number">0</span>,
    render:<span class="function"><span class="keyword">function</span><span class="params">(element,container)</span>{</span>

        <span class="keyword">var</span> componentInstance = instantiateReactComponent(element);
        <span class="keyword">var</span> markup = componentInstance.mountComponent(React.nextReactRootIndex++);
        $(container).html(markup);
        <span class="comment">//触发完成mount的事件</span>
        $(document).trigger(<span class="string">'mountReady'</span>);    }
}
</pre></td></tr></table></figure>

<p>代码分为三个部分：</p>
<ol>
<li>React.render 作为入口负责调用渲染</li>
<li>我们引入了component类的概念，ReactDOMTextComponent是一个component类定义，定义对于这种<code>文本类型</code>的节点，在渲染，更新，删除时应该做什么操作，这边暂时只用到渲染，另外两个可以先忽略</li>
<li>instantiateReactComponent用来根据element的类型（现在只有一种string类型），返回一个component的实例。其实就是个类工厂。</li>
</ol>
<p>nextReactRootIndex作为每个component的标识id，不断加1，确保唯一性。这样我们以后可以通过这个标识找到这个元素。</p>
<p>可以看到我们把逻辑分为几个部分，主要的渲染逻辑放在了具体的componet类去定义。React.render负责调度整个流程，这里是调用instantiateReactComponent生成一个对应component类型的实例对象，然后调用此对象的mountComponent获取生成的内容。最后写到对应的container节点中。</p>
<p>可能有人问，这么p大点功能，有必要这么复杂嘛，别急。往下看才能体会这种分层的好处。</p>
<h2 id="引入基本elemetnt">引入基本elemetnt</h2>
<p>我们知道reactjs最大的卖点就是它的虚拟dom概念，我们一般使用<code>React.createElement</code>来创建一个虚拟dom元素。</p>
<p>虚拟dom元素分为两种，一种是浏览器自带的基本元素比如 div p input form 这种，一种是自定义的元素。</p>
<blockquote>
<p>这边需要说一下我们上节提到的文本节点，它不算虚拟dom，但是reacjs为了保持渲染的一致性。文本节点是在外面包了一层span标记，也给它配了个简化版component（ReactDOMTextComponent）。</p>
</blockquote>
<p>这节我们先讨论浏览器的基本元素。</p>
<p>在reactjs里，当我们希望在hello world外面包一层div,并且带上一些属性，甚至事件时我们可以这么写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre>
<span class="comment">//演示事件监听怎么用</span>
<span class="function"><span class="keyword">function</span> <span class="title">hello</span><span class="params">()</span>{</span>
    alert(<span class="string">'hello'</span>)
}


<span class="keyword">var</span> element = React.createElement(<span class="string">'div'</span>,{id:<span class="string">'test'</span>,onclick:hello},<span class="string">'click me'</span>)

React.render(element,document.getElementById(<span class="string">"container"</span>))


<span class="comment">/**

//生成的html为：

&lt;div data-reactid="0" id="test"&gt;
    &lt;span data-reactid="0.0"&gt;click me&lt;/span&gt;
&lt;/div&gt;


//点击文字，会弹出hello的对话框

*/</span>
</pre></td></tr></table></figure>

<p>上面使用<code>React.createElement</code>创建了一个基本元素，我们来看看简易版本<code>React.createElement</code>的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre></td><td class="code"><pre>
<span class="comment">//ReactElement就是虚拟dom的概念，具有一个type属性代表当前的节点类型，还有节点的属性props</span>
<span class="comment">//比如对于div这样的节点type就是div，props就是那些attributes</span>
<span class="comment">//另外这里的key,可以用来标识这个element，用于优化以后的更新，这里可以先不管，知道有这么个东西就好了</span>
<span class="function"><span class="keyword">function</span> <span class="title">ReactElement</span><span class="params">(type,key,props)</span>{</span>
  <span class="keyword">this</span>.type = type;
  <span class="keyword">this</span>.key = key;
  <span class="keyword">this</span>.props = props;
}


React = {
    nextReactRootIndex:<span class="number">0</span>,
    createElement:<span class="function"><span class="keyword">function</span><span class="params">(type,config,children)</span>{</span>
        <span class="keyword">var</span> props = {},propName;
        config = config || {}
        <span class="comment">//看有没有key，用来标识element的类型，方便以后高效的更新，这里可以先不管</span>
        <span class="keyword">var</span> key = config.key || <span class="literal">null</span>;

        <span class="comment">//复制config里的内容到props</span>
        <span class="keyword">for</span> (propName <span class="keyword">in</span> config) {
            <span class="keyword">if</span> (config.hasOwnProperty(propName) && propName !== <span class="string">'key'</span>) {
                props[propName] = config[propName];
            }
        }

        <span class="comment">//处理children,全部挂载到props的children属性上</span>
        <span class="comment">//支持两种写法，如果只有一个参数，直接赋值给children，否则做合并处理</span>
        <span class="keyword">var</span> childrenLength = <span class="built_in">arguments</span>.length - <span class="number">2</span>;
        <span class="keyword">if</span> (childrenLength === <span class="number">1</span>) {
            props.children = $.isArray(children) ? children : [children] ;
        } <span class="keyword">else</span> <span class="keyword">if</span> (childrenLength &gt; <span class="number">1</span>) {
            <span class="keyword">var</span> childArray = <span class="built_in">Array</span>(childrenLength);
            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; childrenLength; i++) {
                childArray[i] = <span class="built_in">arguments</span>[i + <span class="number">2</span>];
            }
            props.children = childArray;
        }

        <span class="keyword">return</span> <span class="keyword">new</span> ReactElement(type, key,props);

    },
    render:<span class="function"><span class="keyword">function</span><span class="params">(element,container)</span>{</span>
        <span class="keyword">var</span> componentInstance = instantiateReactComponent(element);
        <span class="keyword">var</span> markup = componentInstance.mountComponent(React.nextReactRootIndex++);
        $(container).html(markup);
        <span class="comment">//触发完成mount的事件</span>
        $(document).trigger(<span class="string">'mountReady'</span>);
    }
}
</pre></td></tr></table></figure>

<p>createElement只是做了简单的参数修正，最终返回一个ReactElement实例对象也就是我们说的虚拟元素的实例。</p>
<blockquote>
<p>这里注意key的定义，主要是为了以后更新时优化效率，这边可以先不管忽略。</p>
</blockquote>
<p>好了有了元素实例，我们得把他渲染出来，此时render接受的是一个ReactElement而不是文本，我们先改造下instantiateReactComponent：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>
<span class="function"><span class="keyword">function</span> <span class="title">instantiateReactComponent</span><span class="params">(node)</span>{</span>
    <span class="comment">//文本节点的情况</span>
    <span class="keyword">if</span>(<span class="keyword">typeof</span> node === <span class="string">'string'</span> || <span class="keyword">typeof</span> node === <span class="string">'number'</span>){
        <span class="keyword">return</span> <span class="keyword">new</span> ReactDOMTextComponent(node);
    }
    <span class="comment">//浏览器默认节点的情况</span>
    <span class="keyword">if</span>(<span class="keyword">typeof</span> node === <span class="string">'object'</span> && <span class="keyword">typeof</span> node.type === <span class="string">'string'</span>){
        <span class="comment">//注意这里，使用了一种新的component</span>
        <span class="keyword">return</span> <span class="keyword">new</span> ReactDOMComponent(node);

    }
}
</pre></td></tr></table></figure>

<p>我们增加了一个判断，这样当render的不是文本而是浏览器的基本元素时。我们使用另外一种component来处理它渲染时应该返回的内容。这里就体现了工厂方法instantiateReactComponent的好处了，不管来了什么类型的node，都可以负责生产出一个负责渲染的component实例。这样render完全不需要做任何修改，只需要再做一种对应的component类型（这里是ReactDOMComponent）就行了。</p>
<p>所以重点我们来看看<code>ReactDOMComponent</code>的具体实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
</pre></td><td class="code"><pre>
<span class="comment">//component类，用来表示文本在渲染，更新，删除时应该做些什么事情</span>
<span class="function"><span class="keyword">function</span> <span class="title">ReactDOMComponent</span><span class="params">(element)</span>{</span>
    <span class="comment">//存下当前的element对象引用</span>
    <span class="keyword">this</span>._currentElement = element;
    <span class="keyword">this</span>._rootNodeID = <span class="literal">null</span>;
}

<span class="comment">//component渲染时生成的dom结构</span>
ReactDOMComponent.prototype.mountComponent = <span class="function"><span class="keyword">function</span><span class="params">(rootID)</span>{</span>
    <span class="comment">//赋值标识</span>
    <span class="keyword">this</span>._rootNodeID = rootID;
    <span class="keyword">var</span> props = <span class="keyword">this</span>._currentElement.props;
    <span class="keyword">var</span> tagOpen = <span class="string">'&lt;'</span> + <span class="keyword">this</span>._currentElement.type;
    <span class="keyword">var</span> tagClose = <span class="string">'&lt;/'</span> + <span class="keyword">this</span>._currentElement.type + <span class="string">'&gt;'</span>;

    <span class="comment">//加上reactid标识</span>
    tagOpen += <span class="string">' data-reactid='</span> + <span class="keyword">this</span>._rootNodeID;

    <span class="comment">//拼凑出属性</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> propKey <span class="keyword">in</span> props) {

        <span class="comment">//这里要做一下事件的监听，就是从属性props里面解析拿出on开头的事件属性的对应事件监听</span>
        <span class="keyword">if</span> (<span class="regexp">/^on[A-Za-z]/</span>.test(propKey)) {
            <span class="keyword">var</span> eventType = propKey.replace(<span class="string">'on'</span>, <span class="string">''</span>);
            <span class="comment">//针对当前的节点添加事件代理,以_rootNodeID为命名空间</span>
            $(document).delegate(<span class="string">'[data-reactid="'</span> + <span class="keyword">this</span>._rootNodeID + <span class="string">'"]'</span>, eventType + <span class="string">'.'</span> + <span class="keyword">this</span>._rootNodeID, props[propKey]);
        }

        <span class="comment">//对于children属性以及事件监听的属性不需要进行字符串拼接</span>
        <span class="comment">//事件会代理到全局。这边不能拼到dom上不然会产生原生的事件监听</span>
        <span class="keyword">if</span> (props[propKey] && propKey != <span class="string">'children'</span> && !<span class="regexp">/^on[A-Za-z]/</span>.test(propKey)) {
            tagOpen += <span class="string">' '</span> + propKey + <span class="string">'='</span> + props[propKey];
        }
    }
    <span class="comment">//获取子节点渲染出的内容</span>
    <span class="keyword">var</span> content = <span class="string">''</span>;
    <span class="keyword">var</span> children = props.children || [];

    <span class="keyword">var</span> childrenInstances = []; <span class="comment">//用于保存所有的子节点的componet实例，以后会用到</span>
    <span class="keyword">var</span> that = <span class="keyword">this</span>;
    $.each(children, <span class="function"><span class="keyword">function</span><span class="params">(key, child)</span> {</span>
        <span class="comment">//这里再次调用了instantiateReactComponent实例化子节点component类，拼接好返回</span>
        <span class="keyword">var</span> childComponentInstance = instantiateReactComponent(child);
        childComponentInstance._mountIndex = key;

        childrenInstances.push(childComponentInstance);
        <span class="comment">//子节点的rootId是父节点的rootId加上新的key也就是顺序的值拼成的新值</span>
        <span class="keyword">var</span> curRootId = that._rootNodeID + <span class="string">'.'</span> + key;
        <span class="comment">//得到子节点的渲染内容</span>
        <span class="keyword">var</span> childMarkup = childComponentInstance.mountComponent(curRootId);
        <span class="comment">//拼接在一起</span>
        content += <span class="string">' '</span> + childMarkup;

    })

    <span class="comment">//留给以后更新时用的这边先不用管</span>
    <span class="keyword">this</span>._renderedChildren = childrenInstances;

    <span class="comment">//拼出整个html内容</span>
    <span class="keyword">return</span> tagOpen + <span class="string">'&gt;'</span> + content + tagClose;
}
</pre></td></tr></table></figure>

<p>我们增加了虚拟dom reactElement的定义，增加了一个新的componet类ReactDOMComponent。<br>这样我们就实现了渲染浏览器基本元素的功能了。</p>
<p>对于虚拟dom的渲染逻辑，本质上还是个递归渲染的东西，reactElement会递归渲染自己的子节点。可以看到我们通过instantiateReactComponent屏蔽了子节点的差异，只需要使用不同的componet类，这样都能保证通过mountComponent最终拿到渲染后的内容。</p>
<p>另外这边的事件也要说下，可以在传递props的时候传入{onClick:function(){}}这样的参数，这样就会在当前元素上添加事件，代理到document。由于reactjs本身全是在写js，所以监听的函数的传递变得特别简单。</p>
<blockquote>
<p>这里很多东西没有考虑，比如一些特殊的类型input select等等，再比如img不需要有对应的tagClose等。这里为了保持简单就不再扩展了。另外reactjs的事件处理其实很复杂，实现了一套标准的w3c事件。这里偷懒直接使用jQuery的事件代理到document上了。</p>
</blockquote>
<h2 id="自定义元素">自定义元素</h2>
<p>上面实现了基本的元素内容，我们下面实现自定义元素的功能。</p>
<p>随着前端技术的发展浏览器的那些基本元素已经满足不了我们的需求了，如果你对<a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components" target="_blank">webcomponents</a>有一定的了解，就会知道人们一直在尝试扩展一些自己的标记。</p>
<p>reactjs通过虚拟dom做到了类似的功能，还记得我们上面element.type只是个简单的字符串，如果是个类呢？如果这个类恰好还有自己的生命周期管理，那扩展性就很高了。</p>
<blockquote>
<p>如果对生命周期等概念不是很理解的，可以看看我以前的另一片文章：<a href="http://www.html-js.com/article/2760" target="_blank">javascript组件化</a></p>
</blockquote>
<p>我们看下reactjs怎么使用自定义元素：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre>
<span class="keyword">var</span> HelloMessage = React.createClass({
  getInitialState: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> {type: <span class="string">'say:'</span>};
  },
  componentWillMount: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    console.log(<span class="string">'我就要开始渲染了。。。'</span>)
  },
  componentDidMount: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    console.log(<span class="string">'我已经渲染好了。。。'</span>)
  },
  render: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> React.createElement(<span class="string">"div"</span>, <span class="literal">null</span>,<span class="keyword">this</span>.state.type, <span class="string">"Hello "</span>, <span class="keyword">this</span>.props.name);
  }
});


React.render(React.createElement(HelloMessage, {name: <span class="string">"John"</span>}), document.getElementById(<span class="string">"container"</span>));

<span class="comment">/**
结果为：

html:
&lt;div data-reactid="0"&gt;
    &lt;span data-reactid="0.0"&gt;say:&lt;/span&gt;
    &lt;span data-reactid="0.1"&gt;Hello &lt;/span&gt;
    &lt;span data-reactid="0.2"&gt;John&lt;/span&gt;
&lt;/div&gt;

console:
我就要开始渲染了。。。
我已经渲染好了。。。

*/</span>
</pre></td></tr></table></figure>

<p><code>React.createElement</code>接受的不再是字符串，而是一个class。</p>
<p><code>React.createClass</code>生成一个自定义标记类，带有基本的生命周期：</p>
<ul>
<li>getInitialState 获取最初的属性值this.state</li>
<li>componentWillmount 在组件准备渲染时调用</li>
<li>componentDidMount 在组件渲染完成后调用</li>
</ul>
<p>对reactjs稍微有点了解的应该都可以明白上面的用法。</p>
<p>我们先来看看React.createClass的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre>
<span class="comment">//定义ReactClass类,所有自定义的超级父类</span>
<span class="keyword">var</span> ReactClass = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
}
<span class="comment">//留给子类去继承覆盖</span>
ReactClass.prototype.render = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>}



React = {
    nextReactRootIndex:<span class="number">0</span>,
    createClass:<span class="function"><span class="keyword">function</span><span class="params">(spec)</span>{</span>
        <span class="comment">//生成一个子类</span>
        <span class="keyword">var</span> Constructor = <span class="function"><span class="keyword">function</span> <span class="params">(props)</span> {</span>
            <span class="keyword">this</span>.props = props;
            <span class="keyword">this</span>.state = <span class="keyword">this</span>.getInitialState ? <span class="keyword">this</span>.getInitialState() : <span class="literal">null</span>;
        }
        <span class="comment">//原型继承，继承超级父类</span>
        Constructor.prototype = <span class="keyword">new</span> ReactClass();
        Constructor.prototype.constructor = Constructor;
        <span class="comment">//混入spec到原型</span>
        $.extend(Constructor.prototype,spec);
        <span class="keyword">return</span> Constructor;

    },
    createElement:<span class="function"><span class="keyword">function</span><span class="params">(type,config,children)</span>{</span>
        ...
    },
    render:<span class="function"><span class="keyword">function</span><span class="params">(element,container)</span>{</span>
        ...
    }
}
</pre></td></tr></table></figure>

<p>可以看到createClass生成了一个继承ReactClass的子类，在构造函数里调用this.getInitialState获得最初的state。</p>
<blockquote>
<p>为了演示方便,我们这边的ReactClass相当简单，实际上原始的代码处理了很多东西，比如类的mixin的组合继承支持,比如componentDidMount等可以定义多次，需要合并调用等等，有兴趣的去翻源码吧，不是本文的主要目的，这里就不详细展开了。</p>
</blockquote>
<p>我们这里只是返回了一个继承类的定义，那么具体的componentWillmount，这些生命周期函数在哪里调用呢。</p>
<p>看看我们上面的两种类型就知道，我们是时候为自定义元素也提供一个componet类了，在那个类里我们会实例化ReactClass，并且管理生命周期，还有父子组件依赖。</p>
<p>好，我们老规矩先改造instantiateReactComponent</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">instantiateReactComponent</span><span class="params">(node)</span>{</span>
    <span class="comment">//文本节点的情况</span>
    <span class="keyword">if</span>(<span class="keyword">typeof</span> node === <span class="string">'string'</span> || <span class="keyword">typeof</span> node === <span class="string">'number'</span>){
        <span class="keyword">return</span> <span class="keyword">new</span> ReactDOMTextComponent(node);
    }
    <span class="comment">//浏览器默认节点的情况</span>
    <span class="keyword">if</span>(<span class="keyword">typeof</span> node === <span class="string">'object'</span> && <span class="keyword">typeof</span> node.type === <span class="string">'string'</span>){
        <span class="comment">//注意这里，使用了一种新的component</span>
        <span class="keyword">return</span> <span class="keyword">new</span> ReactDOMComponent(node);

    }
    <span class="comment">//自定义的元素节点</span>
    <span class="keyword">if</span>(<span class="keyword">typeof</span> node === <span class="string">'object'</span> && <span class="keyword">typeof</span> node.type === <span class="string">'function'</span>){
        <span class="comment">//注意这里，使用新的component,专门针对自定义元素</span>
        <span class="keyword">return</span> <span class="keyword">new</span> ReactCompositeComponent(node);

    }
}
</pre></td></tr></table></figure>

<p>很简单我们增加了一个判断，使用新的component类形来处理自定义的节点。我们看下<br>ReactCompositeComponent的具体实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre>
<span class="function"><span class="keyword">function</span> <span class="title">ReactCompositeComponent</span><span class="params">(element)</span>{</span>
    <span class="comment">//存放元素element对象</span>
    <span class="keyword">this</span>._currentElement = element;
    <span class="comment">//存放唯一标识</span>
    <span class="keyword">this</span>._rootNodeID = <span class="literal">null</span>;
    <span class="comment">//存放对应的ReactClass的实例</span>
    <span class="keyword">this</span>._instance = <span class="literal">null</span>;
}

<span class="comment">//用于返回当前自定义元素渲染时应该返回的内容</span>
ReactCompositeComponent.prototype.mountComponent = <span class="function"><span class="keyword">function</span><span class="params">(rootID)</span>{</span>
    <span class="keyword">this</span>._rootNodeID = rootID;
    <span class="comment">//拿到当前元素对应的属性值</span>
    <span class="keyword">var</span> publicProps = <span class="keyword">this</span>._currentElement.props;
    <span class="comment">//拿到对应的ReactClass</span>
    <span class="keyword">var</span> ReactClass = <span class="keyword">this</span>._currentElement.type;
    <span class="comment">// Initialize the public class</span>
    <span class="keyword">var</span> inst = <span class="keyword">new</span> ReactClass(publicProps);
    <span class="keyword">this</span>._instance = inst;
    <span class="comment">//保留对当前comonent的引用，下面更新会用到</span>
    inst._reactInternalInstance = <span class="keyword">this</span>;

    <span class="keyword">if</span> (inst.componentWillMount) {
        inst.componentWillMount();
        <span class="comment">//这里在原始的reactjs其实还有一层处理，就是  componentWillMount调用setstate，不会触发rerender而是自动提前合并，这里为了保持简单，就略去了</span>
    }
    <span class="comment">//调用ReactClass的实例的render方法,返回一个element或者一个文本节点</span>
    <span class="keyword">var</span> renderedElement = <span class="keyword">this</span>._instance.render();
    <span class="comment">//得到renderedElement对应的component类实例</span>
    <span class="keyword">var</span> renderedComponentInstance = instantiateReactComponent(renderedElement);
    <span class="keyword">this</span>._renderedComponent = renderedComponentInstance; <span class="comment">//存起来留作后用</span>

    <span class="comment">//拿到渲染之后的字符串内容，将当前的_rootNodeID传给render出的节点</span>
    <span class="keyword">var</span> renderedMarkup = renderedComponentInstance.mountComponent(<span class="keyword">this</span>._rootNodeID);

    <span class="comment">//之前我们在React.render方法最后触发了mountReady事件，所以这里可以监听，在渲染完成后会触发。</span>
    $(document).on(<span class="string">'mountReady'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="comment">//调用inst.componentDidMount</span>
        inst.componentDidMount && inst.componentDidMount();
    });

    <span class="keyword">return</span> renderedMarkup;
}
</pre></td></tr></table></figure>

<p>实现并不难，ReactClass的render一定是返回一个虚拟节点(包括element和text)，这个时候我们使用instantiateReactComponent去得到实例，再使用mountComponent拿到结果作为当前自定义元素的结果。</p>
<p>应该说本身自定义元素不负责具体的内容，他更多的是负责生命周期。具体的内容是由它的render方法返回的虚拟节点来负责渲染的。</p>
<p>本质上也是递归的去渲染内容的过程。同时因为这种递归的特性，父组件的componentWillMount一定在某个子组件的componentWillMount之前调用，而父组件的componentDidMount肯定在子组件之后，因为监听mountReady事件，肯定是子组件先监听的。</p>
<blockquote>
<p>需要注意的是自定义元素并不会处理我们createElement时传入的子节点，它只会处理自己render返回的节点作为自己的子节点。不过我们在render时可以使用this.props.children拿到那些传入的子节点，可以自己处理。其实有点类似webcomponents里面的shadow dom的作用。</p>
</blockquote>
<p>上面实现了三种类型的元素，其实我们发现本质上没有太大的区别，都是有自己对应component类来处理自己的渲染过程。</p>
<p>大概的关系是下面这样。</p>
<p><img src="https://img.alicdn.com/tps/TB1NPA_JpXXXXcVXXXXXXXXXXXX-1024-768.jpg" alt="结构图"></p>
<p>于是我们发现初始化的渲染流程都已经完成了。</p>
<h2 id="结语">结语</h2>
<p>整个初次渲染的流程基本就分析完毕了。看看我们目前的进展，事件监听做了，虚拟dom有了。基本的组件生命周期也有了。我们这个小玩具已经可以简单跑跑了。下篇文章我们将一起去实现reactjs的更新机制，看看它最核心的diff算法是怎么回事。</p>
]]></content:encoded>
      <comments>http://purplebamboo.github.com/2015/09/15/reactjs_source_analyze_part_one/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[弹幕实现]]></title>
      <link>http://purplebamboo.github.com/2015/06/21/how-to-make-a-barrage/</link>
      <guid>http://purplebamboo.github.com/2015/06/21/how-to-make-a-barrage/</guid>
      <pubDate>Sat, 20 Jun 2015 17:13:56 GMT</pubDate>
      <description>
      <![CDATA[<p>好久不写博客了，罪过罪过，这几个月真是忙成狗了。最近做业务的时候需要实现个简单的弹幕效果，发现一些比较有意思的玩法，这边记录一下。</p>
<h2 id="思考-如何实现弹幕">思考-如何实现弹幕</h2>
<p>我们先抛开弹幕，来看看现实生活中的一个场景。</p>
<p>]]>
      </description>
      <content:encoded><![CDATA[<p>好久不写博客了，罪过罪过，这几个月真是忙成狗了。最近做业务的时候需要实现个简单的弹幕效果，发现一些比较有意思的玩法，这边记录一下。</p>
<h2 id="思考-如何实现弹幕">思考-如何实现弹幕</h2>
<p>我们先抛开弹幕，来看看现实生活中的一个场景。</p>
<p>什么场景呢，就是一台舞台剧的拍摄过程。</p>
<p>我们先看看拍一个舞台剧需要准备哪些东西：</p>
<ul>
<li>首先需要一个舞台</li>
<li>还需要有个剧本，剧本规定了这个剧该怎么演</li>
<li>然后需要一大堆演员，每个演员要自己化妆，确定自己什么时候上场</li>
<li>再然后需要个导演，导演负责整个流程的控制叫演员上场表演</li>
</ul>
<p>首先我们需要知道，一场舞台剧是分好几个场次的。有的演员在第一场，有的演员在第二场，每个演员的身份装扮也都是不同的。</p>
<p>在开场之前，需要做些前期准备，比如舞台装扮，还有跟演员说戏。<br>什么是说戏呢？<br>导演会先让演员看剧本，先装扮好。然后跟演员说：那个xxx你是第二场上，xxx第一场。到时我会提醒你们第几场开始了，你们要注意听。</p>
<p>说完戏之后，舞台剧就开始演了。</p>
<p>每开始一个场次，导演就喊：第xx场开始了，这个场次的演员注意上场。然后演员听到后就会找到时机上场。</p>
<p>整个舞台剧就这样按流程表演了。</p>
<p>为什么要说这个例子呢，因为我发现，弹幕跟这个就是一回事。</p>
<p>每一条弹幕其实就是一个演员，我们再搞一个调度者导演，来控制弹幕的出场。导演的说戏其实就是每个演员添加针对导演的事件监听。</p>
<h2 id="开始动手实现">开始动手实现</h2>
<p>为了方便，下面所有代码基于jQuery实现</p>
<p>我们先确定需要的元素：</p>
<p><em>1.我们需要个舞台</em></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>&lt;div id=<span class="string">"J_stage"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="title">div</span>&gt;</span>

<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript">

<span class="comment">//舞台是全局变量</span>
<span class="keyword">var</span> stage = $(<span class="string">'#J_stage'</span>);

</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span>
</pre></td></tr></table></figure>

<p><em>2.我们需要个剧本</em></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
</pre></td><td class="code"><pre><span class="keyword">var</span> playList = [{
    <span class="comment">//从何时开始</span>
    time:<span class="number">0</span>,
    <span class="comment">//经过的时间</span>
    duration:<span class="number">4292</span>,
    <span class="comment">//舞台偏移的高度</span>
    top:<span class="number">10</span>,
    <span class="comment">//弹幕文字大小</span>
    size:<span class="number">16</span>,
    <span class="comment">//弹幕颜色</span>
    color:<span class="string">'#000'</span>,
    <span class="comment">//内容</span>
    text:<span class="string">'前方高能注意'</span>
},{
    <span class="comment">//从何时开始</span>
    time:<span class="number">100</span>,
    <span class="comment">//经过的时间</span>
    duration:<span class="number">4192</span>,
    <span class="comment">//舞台偏移的高度</span>
    top:<span class="number">100</span>,
    <span class="comment">//弹幕文字大小</span>
    size:<span class="number">14</span>,
    <span class="comment">//弹幕颜色</span>
    color:<span class="string">'#333'</span>,
    <span class="comment">//内容</span>
    text:<span class="string">'我就是路过看看。。'</span>
},{
    <span class="comment">//从何时开始</span>
    time:<span class="number">170</span>,
    <span class="comment">//经过的时间</span>
    duration:<span class="number">6192</span>,
    <span class="comment">//舞台偏移的高度</span>
    top:<span class="number">130</span>,
    <span class="comment">//弹幕文字大小</span>
    size:<span class="number">16</span>,
    <span class="comment">//弹幕颜色</span>
    color:<span class="string">'#00ff00'</span>,
    <span class="comment">//内容</span>
    text:<span class="string">'我就静静的看着你装逼。。'</span>
},{
    <span class="comment">//从何时开始</span>
    time:<span class="number">1000</span>,
    <span class="comment">//经过的时间</span>
    duration:<span class="number">5992</span>,
    <span class="comment">//舞台偏移的高度</span>
    top:<span class="number">150</span>,
    <span class="comment">//弹幕文字大小</span>
    size:<span class="number">20</span>,
    <span class="comment">//弹幕颜色</span>
    color:<span class="string">'#ff0000'</span>,
    <span class="comment">//内容</span>
    text:<span class="string">'我和我的小伙伴都惊呆了～～'</span>
}]

<span class="comment">//弹幕的总时间（演出总时间）</span>
<span class="keyword">var</span> Time = <span class="number">9000</span>;
<span class="comment">//检测时间间隔（每一场的时间）</span>
<span class="keyword">var</span> CheckTime = <span class="number">1000</span>;
<span class="comment">//总场数</span>
<span class="keyword">var</span> PlayCount = <span class="built_in">Math</span>.ceil(Time / CheckTime);
</pre></td></tr></table></figure>

<p>剧本很简单,包括演出的总时间，每一场的时间，还有具体的每个演员的表演内容，规定了每个演员的入场时间（time）,表演的时间(duration),还有入场的位置(top)，还有演员的妆容(size,color,text)</p>
<p><em>3.我们还需要演员</em><br>作为一名合格的演员，需要具备那些素质呢？<br>我们创建个演员的类：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre></td><td class="code"><pre>
<span class="comment">//构造函数，传递一个剧本片段</span>
<span class="keyword">var</span> Actor = <span class="function"><span class="keyword">function</span><span class="params">(play)</span>{</span>
    <span class="comment">//保存剧本的副本</span>
    <span class="keyword">this</span>.play = play;
    <span class="comment">//给自己化妆</span>
    <span class="keyword">this</span>.appearance = <span class="keyword">this</span>.makeUp();
    <span class="comment">//自己走上舞台旁边准备上场</span>
    <span class="keyword">this</span>.appearance.hide().appendTo(stage);
}

<span class="comment">//演员化妆，也就是最终呈现的样子</span>
Actor.prototype.makeUp = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> appearance = $(<span class="string">'&lt;div style="min-width:400px;font-size:'</span>+<span class="keyword">this</span>.play.size +<span class="string">';color:'</span>+<span class="keyword">this</span>.play.color+<span class="string">';"&gt;'</span>+<span class="keyword">this</span>.play.text+<span class="string">'&lt;/div&gt;'</span>);
    <span class="keyword">return</span> appearance;
}

<span class="comment">//演员上场飘过</span>
Actor.prototype.animate = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> that = <span class="keyword">this</span>;
    <span class="keyword">var</span> appearance = that.appearance;
    <span class="keyword">var</span> mywidth = appearance.width();
    <span class="comment">//使用动画控制left</span>
    appearance.animate({
        left:-mywidth
    }, that.play.duration,<span class="string">'swing'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        appearance.hide();
    });
}

<span class="comment">//演员开始表演</span>
Actor.prototype.perform = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> that = <span class="keyword">this</span>;
    <span class="keyword">var</span> appearance = that.appearance;

    <span class="comment">//准备入场,先隐藏在幕布后面</span>
    appearance.css({
        position:<span class="string">'absolute'</span>,
        left: stage.width()+<span class="string">'px'</span>,
        top:that.play.top||<span class="number">0</span>,
        zIndex:<span class="number">10</span>,
        display:<span class="string">'block'</span>
    });
    <span class="comment">//确定入场偏移时间，入场表演</span>
    <span class="comment">//导演只会说第几场开始了，可不会还帮你具体到某个时间点，所以需要你自己计算好入场的时间。</span>
    <span class="keyword">var</span> delayTime = that.play.time - (that.play.session-<span class="number">1</span>) * CheckTime;
    <span class="comment">//演员需要修正自己上场的时间</span>
    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        that.animate();
    },delayTime)

}
</pre></td></tr></table></figure>

<p>演员类还是比较简单，构造函数调用后演员自己会化好妆等待入场。并且暴露出表演的方法perform。每个演员需要监听导演。当导演说了某个场次开始后，记得关注，入场表演即可。</p>
<p><em>4.好了我们还需要个导演，非常重要的调度者</em></p>
<p>导演需要具有事件机制，也就是我们常说的观察者模式，因为我们使用了jQuery，所以有现成的可以用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">//这样我们就得到了一个支持事件机制的对象。</span>
<span class="keyword">var</span> director = $({});
</pre></td></tr></table></figure>

<p>这样所有的元素都已经齐全了，下面我们开始进行戏剧的前期准备过程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>

<span class="comment">//准备舞台（这个上面其实已经说了）</span>
<span class="keyword">var</span> stage = $(<span class="string">'#J_stage'</span>);
stage.css({
    position:<span class="string">'relative'</span>,
    overflow:<span class="string">'hidden'</span>
})

<span class="comment">//导演开始说戏过剧本</span>
<span class="comment">//整理playList列表，组装事件</span>
$.each(playList,<span class="function"><span class="keyword">function</span><span class="params">(k,play)</span>{</span>
    <span class="comment">//确定演员，确定场次</span>
    <span class="keyword">var</span> session = <span class="built_in">Math</span>.ceil(play.time / CheckTime);
    play.session = session;
    <span class="comment">//剧本拿给演员,召唤一个演员</span>
    <span class="keyword">var</span> actor = <span class="keyword">new</span> Actor(play);
    <span class="comment">//演员针对导演添加监听。</span>
    <span class="comment">//等导演说了这个场次后，就开始叫演员表演</span>
    director.on(session+<span class="string">'start'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        actor.perform();
    })
})
</pre></td></tr></table></figure>

<p>说戏也说完了，下面就开始正式表演啦：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>currentSession = <span class="number">0</span>;

setInterval(<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="comment">//第xx场开始表演</span>
    director.trigger(currentSession+<span class="string">'start'</span>);
    <span class="comment">//从头再来一遍</span>
    <span class="keyword">if</span> (currentSession === PlayCount) {
        currentSession = <span class="number">0</span>;
    }<span class="keyword">else</span>{
        currentSession++;
    }

},CheckTime);
</pre></td></tr></table></figure>

<p>最终结果如下：</p>
<iframe  style="height:268px;" scrolling='no' src='//codepen.io/cherishpeace/embed/jPGKXY/?height=268&theme-id=16140&default-tab=result' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='http://codepen.io/cherishpeace/pen/jPGKXY/'>jPGKXY</a> by cherishpeace (<a href='http://codepen.io/cherishpeace'>@cherishpeace</a>) on <a href='http://codepen.io'>CodePen</a>.<br></iframe>



<h2 id="结语">结语</h2>
<p>其实可做的事情还很多，后来还增加了不少功能，比如弹幕的停止，继续。以及其他一些高级功能，但是受限于篇幅，就不往下扩展了。写在端午节晚上，明天还要继续苦逼的加班，anyway端午节快乐。</p>
]]></content:encoded>
      <comments>http://purplebamboo.github.com/2015/06/21/how-to-make-a-barrage/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[(翻译)使用200行代码创建属于你自己的精简版angular]]></title>
      <link>http://purplebamboo.github.com/2015/05/27/use-200-line-code-to-implementation-a-simple-angular/</link>
      <guid>http://purplebamboo.github.com/2015/05/27/use-200-line-code-to-implementation-a-simple-angular/</guid>
      <pubDate>Wed, 27 May 2015 14:58:56 GMT</pubDate>
      <description>
      <![CDATA[<p>原文：<a href="http://blog.mgechev.com/2015/03/09/build-learn-your-own-light-lightweight-angularjs/" target="_blank">http://blog.mgechev.com]]>
      </description>
      <content:encoded><![CDATA[<p>原文：<a href="http://blog.mgechev.com/2015/03/09/build-learn-your-own-light-lightweight-angularjs/" target="_blank">http://blog.mgechev.com/2015/03/09/build-learn-your-own-light-lightweight-angularjs/</a></p>
<p>第一次翻译外文，就拿这篇作为第一次练习。加上一些自己的理解并且做了些删减。</p>
<p>正文开始：</p>
<p>我的实践经验证明有两种好方法来学习一项新技术。</p>
<ul>
<li>自己重新实现这个项目</li>
<li>分析那些你所知道的技术概念是如何运用在这个项目里的</li>
</ul>
<p>在一些情况下第一种方式很难做到。比如，如果你为了理解<a href="https://github.com/torvalds/linux" target="_blank">kernel</a>（linux内核）的工作原理而去重新实现一次它会很困难很慢。往往更有效的是你去实现一个轻量的版本，去除掉那些你没兴趣的技术细节，只关注核心功能。</p>
<p>第二种方法一般是很有效的，特别是当你具有一些相似的技术经验的时候。最好的证明就是我写的<a href="https://github.com/mgechev/angularjs-in-patterns" target="_blank">angularjs-in-patterns</a>,对于有经验的工程师来说这是个对angular框架非常好的介绍。</p>
<p>不管怎么说，从头开始实现一些东西并且去理解代码使用的技术细节是非常好的学习方式。整个angularjs框架大概有20k行代码，其中有很多特别难懂的地方。这是很多聪明的程序员夜以继日的工作做出来的伟大的壮举。然而为了理解这个框架还有它主要的设计原则，我们可以仅仅简单的实现一个‘模型’。</p>
<p>我们可以通过下面这些步骤来实现这个模型：</p>
<ul>
<li>简化api</li>
<li>去除掉对于理解核心功能无关的组件代码</li>
</ul>
<p>这就是我在<a href="https://github.com/mgechev/light-angularjs" target="_blank">Lightweight AngularJS</a>里面做的事情。</p>
<p>在开始阅读下面的内容之前，建议先了解下angularjs的基本用法，可以看这篇<a href="http://blog.mgechev.com/2014/05/08/angularjs-in-patterns-part-1-overview-of-angularjs/" target="_blank">文章</a></p>
<p>下面是一些demo例子还有代码片段：</p>
<ul>
<li><a href="https://github.com/mgechev/light-angularjs" target="_blank">Lightweight AngularJS source code</a></li>
<li><a href="https://mgechev.github.io/light-angularjs/" target="_blank">Very simple todo application built with Lightweight AngularJS</a></li>
</ul>
<p>让我们开始我们的实现：</p>
<h2 id="主要的组件：">主要的组件：</h2>
<p>我们不完全实现angularjs的那套技术，我们就仅仅定义一部分的组件并且实现大部分的angularjs里面的时尚特性。可能会接口变得简单点，或者减少些功能特性。</p>
<p>我们会实现的angular的组件包括：</p>
<ul>
<li>Controllers</li>
<li>Directives</li>
<li>Services</li>
</ul>
<p>为了达到这些功能我们需要实现<code>$compile</code>service(我们称之为<code>DOMCompiler</code>),还有<code>$provider</code>跟<code>$injector</code>(在我们的实现里统称为Provider)。为了实现双向绑定我们还要实现scope。</p>
<p>下面是Provider, Scope 跟 DOMCompiler 的依赖关系：</p>
<p><img src="http://blog.mgechev.com/images/lightweight-ng/main-components.png" alt="yilai"></p>
<h3 id="Provider">Provider</h3>
<p>就像上面提到的，我们的Provider会包括原生angular里面的两个组件的内容：</p>
<ul>
<li>$provide</li>
<li>$injector</li>
</ul>
<p>他是一个具有如下功能特性的单列：</p>
<ul>
<li>注册组件（directives, services 和 controllers）</li>
<li>解决各个组件之间的依赖关系</li>
<li>初始化所有组件</li>
</ul>
<h3 id="DOMCompiler">DOMCompiler</h3>
<p>DOMCompiler也是一个单列，他会遍历dom树去查找对应的directives节点。我们这里仅仅支持那种用在dom元素属性上的directive。当DOMCompiler发现directive的时候会给他提供scope的功能特性（因为对应的directive可能需要一个新的scope）并且调用关联在它上面对应的逻辑代码（也就是link函数里面的逻辑）。所以这个组件的主要职责就是：</p>
<p>编译dom</p>
<ul>
<li>遍历dom树的所有节点</li>
<li>找到注册的属性类型的directives指令</li>
<li>调用对应的directive对应的link逻辑</li>
<li>管理scope</li>
</ul>
<h3 id="Scope">Scope</h3>
<p>我们的轻量级angular的最后一个主要的组件就是scope。为了实现双向绑定的功能，我们需要有一个$scope对象来挂载属性。我们可以把这些属性组合成表达式并且监控它们。当我们发现监控的某个表达式的值改变了，我们就调用对应的回调函数。</p>
<p>scope的职责：</p>
<ul>
<li>监控表达式</li>
<li>在每次$digest循环的时候执行所有的表达式，直到稳定（译者注：稳定就是说，表达式的值不再改变的时候）</li>
<li>在表达式的值发生改变时，调用对应的所有的回调函数</li>
</ul>
<p>下面本来还有些图论的讲解，但是认为意义不大，这边就略去了。</p>
<h2 id="开始实现">开始实现</h2>
<p>让我们开始实现我们的轻量版angular</p>
<h3 id="Provider-1">Provider</h3>
<p>正如我们上面说的，Provide会：</p>
<ul>
<li>注册组件（directives, services 和 controllers）</li>
<li>解决各个组件之间的依赖关系</li>
<li>初始化所有组件</li>
</ul>
<p>所以它具有下面这些接口：</p>
<ul>
<li>get(name, locals) - 通过名称 还有本地依赖 返回对应的service</li>
<li>invoke(fn, locals) - 通过service对应的工厂函数还有本地依赖初始化service</li>
<li>directive(name, fn) - 通过名称还有工厂函数注册一个directive</li>
<li>controller(name, fn) - 通过名称还有工厂函数注册一个controller。注意angularjs的代码里并没有controllers对应的代码，他们是通过$controller来实现的。</li>
<li>service(name, fn) - 通过名称还有工厂函数注册一个service</li>
<li>annotate(fn) - 返回一个数组，数组里是当前service依赖的模块的名称</li>
</ul>
<p>组件的注册：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="keyword">var</span> Provider = {
  _providers: {},
  directive: <span class="function"><span class="keyword">function</span> <span class="params">(name, fn)</span> {</span>
    <span class="keyword">this</span>._register(name + Provider.DIRECTIVES_SUFFIX, fn);
  },
  controller: <span class="function"><span class="keyword">function</span> <span class="params">(name, fn)</span> {</span>
    <span class="keyword">this</span>._register(name + Provider.CONTROLLERS_SUFFIX, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
      <span class="keyword">return</span> fn;
    });
  },
  service: <span class="function"><span class="keyword">function</span> <span class="params">(name, fn)</span> {</span>
    <span class="keyword">this</span>._register(name, fn);
  },
  _register: <span class="function"><span class="keyword">function</span> <span class="params">(name, factory)</span> {</span>
    <span class="keyword">this</span>._providers[name] = factory;
  }
  <span class="comment">//...</span>
};
Provider.DIRECTIVES_SUFFIX = <span class="string">'Directive'</span>;
Provider.CONTROLLERS_SUFFIX = <span class="string">'Controller'</span>;
</pre></td></tr></table></figure>

<blockquote>
<p>译者注：看到这里容易对controller的包装一层有疑问，先忽略，看完invoke的实现后，下面我再给出解释。</p>
</blockquote>
<p>上面的代码提供了一个针对注册组件的简单的实现。我们定义了一个私有属性<code>_provides</code>用来存储所有的组件的工厂函数。我们还定义了directive,service和controller这些方法。这些方法本质上内部会调用_register来实现。在controller方法里面我们简单的在给的工厂函数外面包装了一层函数，因为我们希望可以多次实例化同一个controller而不去缓存返回的值。在我们看了下面的get和ngl-controller方法实现后会对controller方法有更加清晰的认识。下面还剩下的方法就是：</p>
<ul>
<li>invoke</li>
<li>get</li>
<li>annotate</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre>
<span class="keyword">var</span> Provider = {
  <span class="comment">// ...</span>
  get: <span class="function"><span class="keyword">function</span> <span class="params">(name, locals)</span> {</span>
    <span class="keyword">if</span> (<span class="keyword">this</span>._cache[name]) {
      <span class="keyword">return</span> <span class="keyword">this</span>._cache[name];
    }
    <span class="keyword">var</span> provider = <span class="keyword">this</span>._providers[name];
    <span class="keyword">if</span> (!provider || <span class="keyword">typeof</span> provider !== <span class="string">'function'</span>) {
      <span class="keyword">return</span> <span class="literal">null</span>;
    }
    <span class="keyword">return</span> (<span class="keyword">this</span>._cache[name] = <span class="keyword">this</span>.invoke(provider, locals));
  },
  annotate: <span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> {</span>
    <span class="keyword">var</span> res = fn.toString()
        .replace(<span class="regexp">/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg</span>, <span class="string">''</span>)
        .match(<span class="regexp">/\((.*?)\)/</span>);
    <span class="keyword">if</span> (res && res[<span class="number">1</span>]) {
      <span class="keyword">return</span> res[<span class="number">1</span>].split(<span class="string">','</span>).map(<span class="function"><span class="keyword">function</span> <span class="params">(d)</span> {</span>
        <span class="keyword">return</span> d.trim();
      });
    }
    <span class="keyword">return</span> [];
  },
  invoke: <span class="function"><span class="keyword">function</span> <span class="params">(fn, locals)</span> {</span>
    locals = locals || {};
    <span class="keyword">var</span> deps = <span class="keyword">this</span>.annotate(fn).map(<span class="function"><span class="keyword">function</span> <span class="params">(s)</span> {</span>
      <span class="keyword">return</span> locals[s] || <span class="keyword">this</span>.get(s, locals);
    }, <span class="keyword">this</span>);
    <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, deps);
  },
  _cache: { $rootScope: <span class="keyword">new</span> Scope() }
};
</pre></td></tr></table></figure>

<p>我们写了更多的逻辑，下面我们看看get的实现。</p>
<p>在get方法中我们先检测下一个组件是不是已经缓存在了私有属性_cache里面。</p>
<ul>
<li>如果缓存了就直接返回（译者注：这边其实就是个单列模式，只会调用注册的工厂函数一次，以后直接调用缓存的生成好的对象）。$rootScope默认就会被缓存，，因为我们需要一个单独的全局的并且唯一的超级scope。一旦整个应用启动了，他就会被实例化。</li>
<li>如果不在缓存里，就从私有属性_providers里面拿到它的工厂函数，并且调用invoke去执行工厂函数实例化它。</li>
</ul>
<p>在invoke函数里，我们做的第一件事就是判断如果没有locals对象就赋值一个空的值。</p>
<p>这些locals对象 叫做局部依赖，什么是局部依赖呢？</p>
<p>在angularjs里面我们可以想到两种依赖：</p>
<ul>
<li>局部依赖</li>
<li>全局依赖</li>
</ul>
<p>全局依赖是我们使用factory，service，filter等等注册的组件。他们可以被所有应用里的其他组件依赖使用。但是$scope呢？对于每一个controller（具有相同执行函数的controller）我们希望拥有不同的scope，$scope对象不像$http,$resource，它不是全局的依赖对象，而是跟$delegate对象一样是局部依赖，针对当前的组件。</p>
<p>让我们呢回到invoke的实现上。通过合理的规避null，undefined这些值，我们可以获取到当前组件的依赖项的名字。注意我们的实现仅仅支持解析那种作为参数属性的依赖写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>
<span class="function"><span class="keyword">function</span> <span class="title">Controller</span><span class="params">($scope, $http)</span> {</span>
  <span class="comment">// ...</span>
}
angular.controller(<span class="string">'Controller'</span>, Controller);
</pre></td></tr></table></figure>

<p>一旦把controller的定义转换成字符串，我们就可以很简单的通过annotate里面的正则匹配出它的依赖项。但是万一controller的定义里面有注释呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>
<span class="function"><span class="keyword">function</span> <span class="title">Controller</span><span class="params">($scope <span class="comment">/* only local scope, for the component */</span>, $http)</span> {</span>
  <span class="comment">// ...</span>
}
angular.controller(<span class="string">'Controller'</span>, Controller);
</pre></td></tr></table></figure>

<p>这边简单的正则就不起作用了，因为执行Controller.toString()也会返回注释，所以这就是我们为什么最开始要使用下面的正则先去掉注释：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>.replace(/((<span class="command">\/</span><span class="command">\/</span>.*<span class="formula">$)|(<span class="command">\/</span><span class="command">\*</span><span class="special">[</span><span class="command">\s</span><span class="command">\S</span><span class="special">]</span>*?<span class="command">\*</span><span class="command">\/</span>))/mg, '').</span>
</pre></td></tr></table></figure>

<p>当我们拿到依赖项的名称后，我们需要去实例化他们。所以我们使用map来循环遍历，挨个的调用get来获取实例。你注意到这边的问题了吗？</p>
<p>如果我们有个组件A，A依赖B和C。并且假设C依赖A？在这种情况下我们就会发生无止境的循环，也就是循环依赖。在这个实现里面我们不会处理这种问题，但是你应该小心点，尽量避免。</p>
<p>所以上面就是我们的provider的实现，现在我们可以这样注册组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>Provider.service(<span class="string">'RESTfulService'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(url)</span> {</span>
    <span class="comment">// make restful call & return promise</span>
  };
});

Provider.controller(<span class="string">'MainCtrl'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(RESTfulService)</span> {</span>
  RESTfulService(url)
  .then(<span class="function"><span class="keyword">function</span> <span class="params">(data)</span> {</span>
    alert(data);
  });
});
</pre></td></tr></table></figure>

<p>然后我们可以这样执行MainCtrl：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">var</span> ctrl = Provider.get(<span class="string">'MainCtrl'</span> + Provider.CONTROLLERS_SUFFIX);
Provider.invoke(ctrl);
</pre></td></tr></table></figure>

<p>译者注：</p>
<p>这边可以开始解释下上面的Provider里面controller方法里为啥要包装一层了。</p>
<p>首先我们注意到controller的调用方式是特殊的，Provider.get内部已经调用了一次invoke，但是我们还要再调用一次invoke才能执行MainCtrl的真正执行函数。这是因为我们包装了一层，导致_cache里面单列存储的是MainCtrl的执行函数。而不是执行函数的结果。</p>
<p>想想这才是合理的，因为MainCtrl可能会有多个调用，这些调用只有执行函数是一致的，但是执行函数的执行结果根据不同的scope环境是不一样的。换句话说对于controller来说 执行函数才是单列的，执行结果是差异的。如果我们不包装一层，就会导致第一次的执行结果会直接缓存，这样下次再使用MainCtrl的时候得到的值就是上一次的。</p>
<p>当然带来的问题就是我们需要get到执行函数后，再次调用invoke来获取结果。</p>
<p>这边的controller初始化，需要看下面的ngl-controller的实现，可以到时再回过头来看这边会理解的更清楚。</p>
<h3 id="DOMCompiler-1">DOMCompiler</h3>
<p>DOMCompiler的主要职责是：</p>
<p>编译dom</p>
<ul>
<li>遍历dom树的所有节点</li>
<li>找到注册的属性类型的directives指令</li>
<li>调用对应的directive对应的link逻辑</li>
<li>管理scope</li>
</ul>
<p>下面的这些接口就够了：</p>
<ul>
<li>bootstrap() - 启动整个项目（类似angularjs里面的angular。bootstrap，不过一直使用html根节点作为启动的节点）</li>
<li>compile(el, scope) - 执行所有依附在当前html节点上的directives的代码，并且递归执行子元素的组件逻辑。我们需要一个scope对象关联当前的html节点，这样才能实现双向绑定。因为每个directive可能都会生成一个不同的scope，所以我们需要在递归调用的时候传入当前的scope对象。</li>
</ul>
<p>下面是对应的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="keyword">var</span> DOMCompiler = {
  bootstrap: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">this</span>.compile(document.children[<span class="number">0</span>],
      Provider.get(<span class="string">'$rootScope'</span>));
  },
  compile: <span class="function"><span class="keyword">function</span> <span class="params">(el, scope)</span> {</span>
    <span class="comment">//获取某个元素上的所有指令</span>
    <span class="keyword">var</span> dirs = <span class="keyword">this</span>._getElDirectives(el);
    <span class="keyword">var</span> dir;
    <span class="keyword">var</span> scopeCreated;
    dirs.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(d)</span> {</span>
      dir = Provider.get(d.name + Provider.DIRECTIVES_SUFFIX);
      <span class="comment">//dir.scope代表当前 directive是否需要生成新的scope</span>
      <span class="comment">//这边的情况是只要有一个指令需要单独的scope，其他的directive也会变成具有新的scope对象，这边是不是不太好</span>
      <span class="keyword">if</span> (dir.scope && !scopeCreated) {
        scope = scope.$<span class="keyword">new</span>();
        scopeCreated = <span class="literal">true</span>;
      }
      dir.link(el, scope, d.value);
    });
    <span class="built_in">Array</span>.prototype.slice.call(el.children).forEach(<span class="function"><span class="keyword">function</span> <span class="params">(c)</span> {</span>
      <span class="keyword">this</span>.compile(c, scope);
    }, <span class="keyword">this</span>);
  },
  <span class="comment">// ...</span>
};
</pre></td></tr></table></figure>

<p>bootstrap的实现很简单。就是调用了一下compile，传递的是html的根节点，以及全局的$rootScope。<br>在compile里面的代码就很有趣了，最开始我们使用了一个辅助方法来获取某个节点上面的所有指令。我们后面再来看这个_getElDirectives的实现。<br>当我们获取到当前节点的所有指令后，我们循环遍历下并且使用Provider.get获取到对应的directive的工厂函数的执行返回对象。然后我们检查当前的directive是否需要一个新的scope，如果需要并且我们还没有为当前的节点初始化过新的scope对象，我们就执行scope.$new()来生成一个新的scope对象。这个对象会原型继承当前的scope对象。然后我们执行当前directive的link方法。最后我们递归执行子节点。因为el.children是一个nodelist对象，所以我们使用Array.prototype.slice.call将它转换成数组，之后对它递归调用compile。</p>
<p>再让我们看看_getElDirectives：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>
<span class="comment">// ...</span>
_getElDirectives: <span class="function"><span class="keyword">function</span> <span class="params">(el)</span> {</span>
  <span class="keyword">var</span> attrs = el.attributes;
  <span class="keyword">var</span> result = [];
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; attrs.length; i += <span class="number">1</span>) {
    <span class="keyword">if</span> (Provider.get(attrs[i].name + Provider.DIRECTIVES_SUFFIX)) {
      result.push({
        name: attrs[i].name,
        value: attrs[i].value
      });
    }
  }
  <span class="keyword">return</span> result;
}
<span class="comment">// ...</span>
</pre></td></tr></table></figure>

<p>主要就是遍历当前节点el的所有属性，发现一个注册过的指令就把它的名字和值加入到返回的数组里。</p>
<p>好了，到这里我们的DOMCompiler就完成了，下面我们看看最后一个重要的组件：</p>
<h3 id="Scope-1">Scope</h3>
<p>为了实现脏检测的功能，于是scope可能是整个实现里面最复杂的部分了。在angularjs里面我们称为$digest循环。笼统的讲双向绑定的最主要原理，就是在$digest循环里面执行监控表达式。一旦这个循环开始调用，就会执行所有监控的表达式并且检测最后的执行结果是不是更当前的执行结果不同，如果angularjs发现他们不同，它就会执行这个表达式对应的回调函数。一个监控者就是一个对象像这样{ expr, fn, last }。expr是对应的监控表达试，fn是对应的回调函数会在值变化后执行，last是上一次的表达式的执行结果。</p>
<p>scope对象有下面这些方法：</p>
<ul>
<li>$watch(expr, fn) - 监控表达式 expr。一旦发现expr的值有变化就只行回调函数fn，并且传入新的值</li>
<li>$destroy() - 销毁当前的scope对象</li>
<li>$eval(expr) - 根据上下文执行当前的表达式</li>
<li>$new() - 原型继承当前的scope对象，生成一个新的scope对象，</li>
<li>$digest() - 运营脏检测</li>
</ul>
<p>让我们来深入的看看scope的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Scope</span><span class="params">(parent, id)</span> {</span>
  <span class="keyword">this</span>.$$watchers = [];
  <span class="keyword">this</span>.$$children = [];
  <span class="keyword">this</span>.$parent = parent;
  <span class="keyword">this</span>.$id = id || <span class="number">0</span>;
}
Scope.counter = <span class="number">0</span>;
</pre></td></tr></table></figure>

<p>我们大幅度的简化了angularjs的scope。我们仅仅有一个监控者的列表，一个子scope对象的列表，一个父scope对象，还有个当前scope的id。我们添加了一个静态属性counter用来跟踪最后一个scope，并且为下一个scope对象提供一个唯一的标识。</p>
<p>我们来实现$watch方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>Scope.prototype.$watch = <span class="function"><span class="keyword">function</span> <span class="params">(exp, fn)</span> {</span>
  <span class="keyword">this</span>.$$watchers.push({
    exp: exp,
    fn: fn,
    last: Utils.clone(<span class="keyword">this</span>.$<span class="built_in">eval</span>(exp))
  });
};
</pre></td></tr></table></figure>

<p>在$watch方法中，我们添加了一个新对象到this.$$watchers监控者列表里。这个对象包括一个表达式，一个执行的回调还有最后一次表达式执行的结果last。因为我们使用this.$eval执行表达式得到的结果有可能是个引用，所以我们需要克隆一份新的。</p>
<p>下面我们看看如何新建scope，和销毁scope。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>
Scope.prototype.$<span class="keyword">new</span> = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  Scope.counter += <span class="number">1</span>;
  <span class="keyword">var</span> obj = <span class="keyword">new</span> Scope(<span class="keyword">this</span>, Scope.counter);
  <span class="comment">//设置原型链，把当前的scope对象作为新scope的原型，这样新的scope对象可以访问到父scope的属性方法</span>
  <span class="built_in">Object</span>.setPrototypeOf(obj, <span class="keyword">this</span>);
  <span class="keyword">this</span>.$$children.push(obj);
  <span class="keyword">return</span> obj;
};

Scope.prototype.$destroy = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> pc = <span class="keyword">this</span>.$parent.$$children;
  pc.splice(pc.indexOf(<span class="keyword">this</span>), <span class="number">1</span>);
};
</pre></td></tr></table></figure>

<p>$new用来创建一个新的scope对象，并且具有独一无二的标识，原型被设置为当前scope对象。然后我们把新生成的scope对象放到子scope对象列表（this.$$children）里。</p>
<p>在destroy方法里，我们把当前scope对象从父级scope对象里的子scope对象列表（this.$$children）移除掉。</p>
<p>下面我们看看传说中的脏检测$digest的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>Scope.prototype.$digest = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> dirty, watcher, current, i;
  <span class="keyword">do</span> {
    dirty = <span class="literal">false</span>;
    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.$$watchers.length; i += <span class="number">1</span>) {
      watcher = <span class="keyword">this</span>.$$watchers[i];
      current = <span class="keyword">this</span>.$<span class="built_in">eval</span>(watcher.exp);
      <span class="keyword">if</span> (!Utils.equals(watcher.last, current)) {
        watcher.last = Utils.clone(current);
        dirty = <span class="literal">true</span>;
        watcher.fn(current);
      }
    }
  } <span class="keyword">while</span> (dirty);
  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.$$children.length; i += <span class="number">1</span>) {
    <span class="keyword">this</span>.$$children[i].$digest();
  }
};
</pre></td></tr></table></figure>

<p>基本上我们一直循环运行检测一直到没有脏数据，默认情况下就是没有脏数据的。一旦我们发现当前表达式的执行结果跟上一次的结果不一样我们就任务有了脏数据，一旦我们发现一个脏数据我们就要重新执行一次所有的监控表达式。为什么呢？因为我们可能会有一些内部表达式依赖，所以一个表达式的结果可能会影响到另外一个的结果。这就是为什么我们需要一遍一遍的运行脏检测一直到所有的表达式都没有变化也就是稳定了。一旦我们发现数据改变了，我们就立即执行对应的回调并且更新对应的last值，并且标识当前有脏数据，这样就会再次调用脏检测。</p>
<p>然后我们会继续递归调用子scope对象的脏数据检测，一个需要注意的情况就是这边也会发生循环依赖：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Controller</span><span class="params">($scope)</span> {</span>
  $scope.i = $scope.j = <span class="number">0</span>;
  $scope.$watch(<span class="string">'i'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(val)</span> {</span>
    $scope.j += <span class="number">1</span>;
  });
  $scope.$watch(<span class="string">'j'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(val)</span> {</span>
    $scope.i += <span class="number">1</span>;
  });
  $scope.i += <span class="number">1</span>;
  $scope.$digest();
}
</pre></td></tr></table></figure>

<p>这种情况下我们就会看到：</p>
<p><img src="http://blog.mgechev.com/images/lightweight-ng/snap.png" alt="snap"></p>
<p>最后一个方法是$eval.最好不要在生产环境里使用这个，这个是一个hack手段用来避免我们还需要自己做个表达式解析引擎。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="comment">// In the complete implementation there're</span>
<span class="comment">// lexer, parser and interpreter.</span>
<span class="comment">// Note that this implementation is pretty evil!</span>
<span class="comment">// It uses two dangerouse features:</span>
<span class="comment">// - eval</span>
<span class="comment">// - with</span>
<span class="comment">// The reason the 'use strict' statement is</span>
<span class="comment">// omitted is because of `with`</span>
Scope.prototype.$<span class="built_in">eval</span> = <span class="function"><span class="keyword">function</span> <span class="params">(exp)</span> {</span>
  <span class="keyword">var</span> val;
  <span class="keyword">if</span> (<span class="keyword">typeof</span> exp === <span class="string">'function'</span>) {
    val = exp.call(<span class="keyword">this</span>);
  } <span class="keyword">else</span> {
    <span class="keyword">try</span> {
      <span class="keyword">with</span> (<span class="keyword">this</span>) {
        val = <span class="built_in">eval</span>(exp);
      }
    } <span class="keyword">catch</span> (e) {
      val = <span class="literal">undefined</span>;
    }
  }
  <span class="keyword">return</span> val;
};
</pre></td></tr></table></figure>

<p>我们检测监控的表达式是不是一个函数，如果是的话我们就使用当前的上下文执行它。否则我们就通过with把当前的执行环境改成当前scope的上下文并且使用eval来得到结果。这个可以允许我们执行类似<code>foo + bar * baz()</code>的表达式，甚至是更复杂的。当然我们不会支持filters，因为他们是angularjs扩展的功能。</p>
<h3 id="Directive">Directive</h3>
<p>到目前为止使用已有的元素我们做不了什么。为了让它跑起来我们需要添加一些指令（directive）还有服务（service）。让我们来实现ngl-bind (ng-bind ), ngl-model (ng-model), ngl-controller (ng-controller) and ngl-click (ng-click)。括号里代表在angularjs里面的对应directive</p>
<p><strong>ngl-bind</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>
Provider.directive(<span class="string">'ngl-bind'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> {
    scope: <span class="literal">false</span>,
    link: <span class="function"><span class="keyword">function</span> <span class="params">(el, scope, exp)</span> {</span>
      el.innerHTML = scope.$<span class="built_in">eval</span>(exp);
      scope.$watch(exp, <span class="function"><span class="keyword">function</span> <span class="params">(val)</span> {</span>
        el.innerHTML = val;
      });
    }
  };
});
</pre></td></tr></table></figure>

<p>ngl-bind并不需要一个新的scope，它仅仅对当前节点添加了一个监控。当脏检测发现有了改变，回调函数就会把新的值赋值到innerHTML更新dom</p>
<p><strong>ngl-model</strong></p>
<p>我们的ng-model只会支持input框的改变检测，所以它的实现是这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>Provider.directive(<span class="string">'ngl-model'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> {
    link:  <span class="function"><span class="keyword">function</span> <span class="params">(el, scope, exp)</span> {</span>
      el.onkeyup = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        scope[exp] = el.value;
        scope.$digest();
      };
      scope.$watch(exp, <span class="function"><span class="keyword">function</span> <span class="params">(val)</span> {</span>
        el.value = val;
      });
    }
  };
});
</pre></td></tr></table></figure>

<p>我们对当前的input框添加了一个onkeyup的监听，一旦当前input的值变化了，我们就调用当前scope对象的$digest脏检测循环。这样就可以保证这个改变会应用到所有scope的监控表达式。当值改变了我们就改变对应的节点的值。</p>
<p><strong>ngl-controller</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>Provider.directive(<span class="string">'ngl-controller'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> {
    scope: <span class="literal">true</span>,
    link: <span class="function"><span class="keyword">function</span> <span class="params">(el, scope, exp)</span> {</span>
      <span class="keyword">var</span> ctrl = Provider.get(exp + Provider.CONTROLLERS_SUFFIX);
      Provider.invoke(ctrl, { $scope: scope });
    }
  };
});
</pre></td></tr></table></figure>

<p>我们需要针对每个controller生成一个新的scope对象，所以它的scope的值是true。我们使用Provide.get来获取到需要的controller执行函数，然后使用当前的scope来执行它。在controller里面我们可以给scope对象添加属性，我们可以使用ngl-bind/ngl-model绑定这些属性。一旦我们改变了属性值我们需要确保我们执行$digest脏检测来保证监控这些属性的表达式会执行。</p>
<p><strong>ngl-click</strong></p>
<p>在我们可以做一个有用的todo应用之前，这是我们最后要看的指令。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>Provider.directive(<span class="string">'ngl-click'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> {
    scope: <span class="literal">false</span>,
    link: <span class="function"><span class="keyword">function</span> <span class="params">(el, scope, exp)</span> {</span>
      el.onclick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        scope.$<span class="built_in">eval</span>(exp);
        scope.$digest();
      };
    }
  };
});
</pre></td></tr></table></figure>

<p>这里我们不需要新建个scope对象。我们需要的就是当用户点击按钮时执行当前ngl-click后面跟着的表达式并且调用脏检测。</p>
<h2 id="一个完整的例子">一个完整的例子</h2>
<p>为了保证我们可以理解双向绑定是怎么工作的，我们来看个下面的例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span> <span class="attribute">lang</span>=<span class="value">"en"</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span> <span class="attribute">ngl-controller</span>=<span class="value">"MainCtrl"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">span</span> <span class="attribute">ngl-bind</span>=<span class="value">"bar"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>
  <span class="tag">&lt;<span class="title">button</span> <span class="attribute">ngl-click</span>=<span class="value">"foo()"</span>&gt;</span>Increment<span class="tag">&lt;/<span class="title">button</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>Provider.controller(<span class="string">'MainCtrl'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($scope)</span> {</span>
  $scope.bar = <span class="number">0</span>;
  $scope.foo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    $scope.bar += <span class="number">1</span>;
  };
});
</pre></td></tr></table></figure>

<p>让我们看看使用这些会发生什么：</p>
<p><img src="http://blog.mgechev.com/images/lightweight-ng/lifecycle-overview.png" alt="lifecycle-overview"></p>
<p>首先DOMCompiler会先发现我们的ngl-controller指令。然后会调用这个指令的link函数生成一个新的scope对象传递给controller的执行函数。我们增加了一个值为0的bar属性，还有一个叫做foo的方法，foo方法会不断增加bar。DOMCompiler会发现ngl-bind然后为bar添加监控。并且还发现了ngl-click同时添加click事件到按钮上。</p>
<p>一旦用户点击了按钮，foo函数就会通过$scope.$eval执行。使用的scope对象就是传递给MainCtrl的scope对象。这之后ngl-click会执行脏检测$scope.$digest。脏检测循环会遍历所有的监控表达式，发现bar的值变化了。因为我们添加了对应的回调函数，所以就执行它更新span的内容。</p>
<h2 id="结论">结论</h2>
<p>这个框架离实际的生产环境应用还有很大差距，但是它还是实现了不少功能：</p>
<ul>
<li>双向绑定</li>
<li>依赖注入</li>
<li>作用域分离</li>
</ul>
<p>跟在angular里面的运行方式差不多。这些可以帮助我们更容易理解angularjs。</p>
<p>但是你还是要记住的是不要把这些代码用在生产环境，最好还是直接使用bower install angular使用最新的anguar。</p>
<p><img src="http://blog.mgechev.com/images/no-production.gif" alt="no-production"></p>
]]></content:encoded>
      <comments>http://purplebamboo.github.com/2015/05/27/use-200-line-code-to-implementation-a-simple-angular/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[javascript组件化]]></title>
      <link>http://purplebamboo.github.com/2015/03/16/javascript-component/</link>
      <guid>http://purplebamboo.github.com/2015/03/16/javascript-component/</guid>
      <pubDate>Mon, 16 Mar 2015 09:37:34 GMT</pubDate>
      <description>
      <![CDATA[<p>作为一名前端工程师，写组件的能力至关重要。虽然javascript经常被人嘲笑是个小玩具，但是在一代代大牛的前仆后继的努力下，渐渐的也摸索了一套组件的编写方式。</p>
<p>下面我们来谈谈，在现有的知识体系下，如何很好的写组件。</p>
<p>比如我们要实现这样一个组件，]]>
      </description>
      <content:encoded><![CDATA[<p>作为一名前端工程师，写组件的能力至关重要。虽然javascript经常被人嘲笑是个小玩具，但是在一代代大牛的前仆后继的努力下，渐渐的也摸索了一套组件的编写方式。</p>
<p>下面我们来谈谈，在现有的知识体系下，如何很好的写组件。</p>
<p>比如我们要实现这样一个组件，就是一个输入框里面字数的计数。这个应该是个很简单的需求。</p>
<p><img src="http://gtms03.alicdn.com/tps/i3/TB1QTOaHXXXXXbkaXXX0TQoKFXX-261-61.gif" alt="图片"></p>
<p>我们来看看，下面的各种写法。</p>
<blockquote>
<p>为了更清楚的演示，下面全部使用jQuery作为基础语言库。</p>
</blockquote>
<h2 id="最简陋的写法">最简陋的写法</h2>
<p>嗯 所谓的入门级写法呢，就是完完全全的全局函数全局变量的写法。（就我所知，现在好多外包还是这种写法）</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre>&lt;!DOCTYPE html&gt;
<span class="xml"><span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
  <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">title</span>&gt;</span>test<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
  <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"http://code.jquery.com/jquery-1.9.1.min.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
  <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
    $(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>

      <span class="keyword">var</span> input = $(<span class="string">'#J_input'</span>);

      <span class="comment">//用来获取字数</span>
      <span class="function"><span class="keyword">function</span> <span class="title">getNum</span><span class="params">()</span>{</span>
        <span class="keyword">return</span> input.val().length;
      }

      <span class="comment">//渲染元素</span>
      <span class="function"><span class="keyword">function</span> <span class="title">render</span><span class="params">()</span>{</span>
        <span class="keyword">var</span> num = getNum();

        <span class="comment">//没有字数的容器就新建一个</span>
        <span class="keyword">if</span> ($(<span class="string">'#J_input_count'</span>).length == <span class="number">0</span>) {
          input.after(<span class="string">'&lt;span id="J_input_count"&gt;&lt;/span&gt;'</span>);
        };

        $(<span class="string">'#J_input_count'</span>).html(num+<span class="string">'个字'</span>);
      }

      <span class="comment">//监听事件</span>
      input.on(<span class="string">'keyup'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
        render();
      });

      <span class="comment">//初始化，第一次渲染</span>
      render();


    })
  </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">id</span>=<span class="value">"J_input"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span></span>
</pre></td></tr></table></figure>

<p>这段代码跑也是可以跑的，但是呢，各种变量混乱，没有很好的隔离作用域,当页面变的复杂的时候,会很难去维护。目前这种代码基本是用不了的。当然少数的活动页面可以简单用用。</p>
<h2 id="作用域隔离">作用域隔离</h2>
<p>让我们对上面的代码作些改动，使用单个变量模拟命名空间。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre><span class="keyword">var</span> textCount = {
  input:<span class="literal">null</span>,
  init:<span class="function"><span class="keyword">function</span><span class="params">(config)</span>{</span>
    <span class="keyword">this</span>.input = $(config.id);
    <span class="keyword">this</span>.bind();
    <span class="comment">//这边范围对应的对象，可以实现链式调用</span>
    <span class="keyword">return</span> <span class="keyword">this</span>;
  },
  bind:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">this</span>.input.on(<span class="string">'keyup'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
      self.render();
    });
  },
  getNum:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.input.val().length;
  },
  <span class="comment">//渲染元素</span>
  render:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> num = <span class="keyword">this</span>.getNum();

    <span class="keyword">if</span> ($(<span class="string">'#J_input_count'</span>).length == <span class="number">0</span>) {
      <span class="keyword">this</span>.input.after(<span class="string">'&lt;span id="J_input_count"&gt;&lt;/span&gt;'</span>);
    };

    $(<span class="string">'#J_input_count'</span>).html(num+<span class="string">'个字'</span>);
  }
}

$(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="comment">//在domready后调用</span>
  textCount.init({id:<span class="string">'#J_input'</span>}).render();
})
</pre></td></tr></table></figure>

<p>这样一改造，立马变的清晰了很多，所有的功能都在一个变量下面。代码更清晰，并且有统一的入口调用方法。</p>
<p>但是还是有些瑕疵，这种写法没有私有的概念，比如上面的getNum,bind应该都是私有的方法。但是其他代码可以很随意的改动这些。当代码量特别特别多的时候，很容易出现变量重复，或被修改的问题。</p>
<p>于是又出现了一种函数闭包的写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="code"><pre><span class="keyword">var</span> TextCount = (<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
  <span class="comment">//私有方法，外面将访问不到</span>
  <span class="keyword">var</span> _bind = <span class="function"><span class="keyword">function</span><span class="params">(that)</span>{</span>
    that.input.on(<span class="string">'keyup'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
      that.render();
    });
  }

  <span class="keyword">var</span> _getNum = <span class="function"><span class="keyword">function</span><span class="params">(that)</span>{</span>
    <span class="keyword">return</span> that.input.val().length;
  }

  <span class="keyword">var</span> TextCountFun = <span class="function"><span class="keyword">function</span><span class="params">(config)</span>{</span>

  }

  TextCountFun.prototype.init = <span class="function"><span class="keyword">function</span><span class="params">(config)</span> {</span>
    <span class="keyword">this</span>.input = $(config.id);
    _bind(<span class="keyword">this</span>);

    <span class="keyword">return</span> <span class="keyword">this</span>;
  };

  TextCountFun.prototype.render = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> num = _getNum(<span class="keyword">this</span>);

    <span class="keyword">if</span> ($(<span class="string">'#J_input_count'</span>).length == <span class="number">0</span>) {
      <span class="keyword">this</span>.input.after(<span class="string">'&lt;span id="J_input_count"&gt;&lt;/span&gt;'</span>);
    };

    $(<span class="string">'#J_input_count'</span>).html(num+<span class="string">'个字'</span>);
  };
  <span class="comment">//返回构造函数</span>
  <span class="keyword">return</span> TextCountFun;

})();

$(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">new</span> TextCount().init({id:<span class="string">'#J_input'</span>}).render();
})
</pre></td></tr></table></figure>

<p>这种写法，把所有的东西都包在了一个自动执行的闭包里面，所以不会受到外面的影响，并且只对外公开了TextCountFun构造函数，生成的对象只能访问到init,render方法。这种写法已经满足绝大多数的需求了。事实上大部分的jQuery插件都是这种写法。</p>
<h2 id="面向对象">面向对象</h2>
<p>上面的写法已经可以满足绝大多数需求了。</p>
<p>但是呢，当一个页面特别复杂，当我们需要的组件越来越多，当我们需要做一套组件。仅仅用这个就不行了。首先的问题就是，这种写法太灵活了，写单个组件还可以。如果我们需要做一套风格相近的组件，而且是多个人同时在写。那真的是噩梦。</p>
<p>在编程的圈子里，面向对象一直是被认为最佳的编写代码方式。比如java，就是因为把面向对象发挥到了极致，所以多个人写出来的代码都很接近，维护也很方便。但是很不幸的是，javascript不支持class类的定义。但是我们可以模拟。</p>
<p>下面我们先实现个简单的javascript类：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td><td class="code"><pre><span class="keyword">var</span> Class = (<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> _mix = <span class="function"><span class="keyword">function</span><span class="params">(r, s)</span> {</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> s) {
      <span class="keyword">if</span> (s.hasOwnProperty(p)) {
        r[p] = s[p]
      }
    }
  }

  <span class="keyword">var</span> _extend = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>

    <span class="comment">//开关 用来使生成原型时,不调用真正的构成流程init</span>
    <span class="keyword">this</span>.initPrototype = <span class="literal">true</span>
    <span class="keyword">var</span> prototype = <span class="keyword">new</span> <span class="keyword">this</span>()
    <span class="keyword">this</span>.initPrototype = <span class="literal">false</span>

    <span class="keyword">var</span> items = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>) || []
    <span class="keyword">var</span> item

    <span class="comment">//支持混入多个属性，并且支持{}也支持 Function</span>
    <span class="keyword">while</span> (item = items.shift()) {
      _mix(prototype, item.prototype || item)
    }


    <span class="comment">// 这边是返回的类，其实就是我们返回的子类</span>
    <span class="function"><span class="keyword">function</span> <span class="title">SubClass</span><span class="params">()</span> {</span>
      <span class="keyword">if</span> (!SubClass.initPrototype && <span class="keyword">this</span>.init)
        <span class="keyword">this</span>.init.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)<span class="comment">//调用init真正的构造函数</span>
    }

    <span class="comment">// 赋值原型链，完成继承</span>
    SubClass.prototype = prototype

    <span class="comment">// 改变constructor引用</span>
    SubClass.prototype.constructor = SubClass

    <span class="comment">// 为子类也添加extend方法</span>
    SubClass.extend = _extend

    <span class="keyword">return</span> SubClass
  }
  <span class="comment">//超级父类</span>
  <span class="keyword">var</span> Class = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>}
  <span class="comment">//为超级父类添加extend方法</span>
  Class.extend = _extend

  <span class="keyword">return</span> Class
})()
</pre></td></tr></table></figure>

<p>这是拿John Resig的class简单修改了下。</p>
<blockquote>
<p>这边只是很简陋的实现了类的继承机制。如果对类的实现有兴趣可以参考我另一篇文章<a href="http://purplebamboo.github.io/2014/07/13/javascript-oo-class/" target="_blank">javascript oo实现</a></p>
</blockquote>
<p>我们看下使用方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="comment">//继承超级父类，生成个子类Animal，并且混入一些方法。这些方法会到Animal的原型上。</span>
<span class="comment">//另外这边不仅支持混入{}，还支持混入Function</span>
<span class="keyword">var</span> Animal = Class.extend({
  init:<span class="function"><span class="keyword">function</span><span class="params">(opts)</span>{</span>
    <span class="keyword">this</span>.msg = opts.msg
    <span class="keyword">this</span>.type = <span class="string">"animal"</span>
  },
  say:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    alert(<span class="keyword">this</span>.msg+<span class="string">":i am a "</span>+<span class="keyword">this</span>.type)
  }
})


<span class="comment">//继承Animal，并且混入一些方法</span>
<span class="keyword">var</span> Dog = Animal.extend({
  init:<span class="function"><span class="keyword">function</span><span class="params">(opts)</span>{</span>
    <span class="comment">//并未实现super方法，直接简单使用父类原型调用即可</span>
    Animal.prototype.init.call(<span class="keyword">this</span>,opts)
    <span class="comment">//修改了type类型</span>
    <span class="keyword">this</span>.type = <span class="string">"dog"</span>
  }
})

<span class="comment">//new Animal({msg:'hello'}).say()</span>

<span class="keyword">new</span> Dog({msg:<span class="string">'hi'</span>}).say()
</pre></td></tr></table></figure>

<p>使用很简单，超级父类具有extend方法，可以继承出一个子类。子类也具有extend方法。</p>
<p>这边要强调的是，继承的父类都是一个也就是单继承。但是可以通过extend实现多重混入。详见下面用法。</p>
<p>有了这个类的扩展，我们可以这么编写代码了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre>
<span class="keyword">var</span> TextCount = Class.extend({
  init:<span class="function"><span class="keyword">function</span><span class="params">(config)</span>{</span>
    <span class="keyword">this</span>.input = $(config.id);
    <span class="keyword">this</span>._bind();
    <span class="keyword">this</span>.render();
  },
  render:<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> num = <span class="keyword">this</span>._getNum();

    <span class="keyword">if</span> ($(<span class="string">'#J_input_count'</span>).length == <span class="number">0</span>) {
      <span class="keyword">this</span>.input.after(<span class="string">'&lt;span id="J_input_count"&gt;&lt;/span&gt;'</span>);
    };

    $(<span class="string">'#J_input_count'</span>).html(num+<span class="string">'个字'</span>);

  },
  _getNum:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.input.val().length;
  },
  _bind:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    self.input.on(<span class="string">'keyup'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
      self.render();
    });
  }
})

$(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">new</span> TextCount({
    id:<span class="string">"#J_input"</span>
  });
})
</pre></td></tr></table></figure>

<p>这边可能还没看见class的真正好处，不急我们继续往下。</p>
<h2 id="抽象出base">抽象出base</h2>
<p>可以看到，我们的组件有些方法，是大部分组件都会有的。</p>
<ul>
<li>比如init用来初始化属性。</li>
<li>比如render用来处理渲染的逻辑。</li>
<li>比如bind用来处理事件的绑定。</li>
</ul>
<p>当然这也是一种约定俗成的规范了。如果大家全部按照这种风格来写代码，开发大规模组件库就变得更加规范，相互之间配合也更容易。</p>
<p>这个时候面向对象的好处就来了，我们抽象出一个Base类。其他组件编写时都继承它。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="keyword">var</span> Base = Class.extend({
  init:<span class="function"><span class="keyword">function</span><span class="params">(config)</span>{</span>
    <span class="comment">//自动保存配置项</span>
    <span class="keyword">this</span>.__config = config
    <span class="keyword">this</span>.bind()
    <span class="keyword">this</span>.render()
  },
  <span class="comment">//可以使用get来获取配置项</span>
  get:<span class="function"><span class="keyword">function</span><span class="params">(key)</span>{</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.__config[key]
  },
  <span class="comment">//可以使用set来设置配置项</span>
  set:<span class="function"><span class="keyword">function</span><span class="params">(key,value)</span>{</span>
    <span class="keyword">this</span>.__config[key] = value
  },
  bind:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
  },
  render:<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>

  },
  <span class="comment">//定义销毁的方法，一些收尾工作都应该在这里</span>
  destroy:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>

  }
})
</pre></td></tr></table></figure>

<p>base类主要把组件的一般性内容都提取了出来，这样我们编写组件时可以直接继承base类，覆盖里面的bind和render方法。</p>
<p>于是我们可以这么写代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="keyword">var</span> TextCount = Base.extend({
  _getNum:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.get(<span class="string">'input'</span>).val().length;
  },
  bind:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    self.get(<span class="string">'input'</span>).on(<span class="string">'keyup'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
      self.render();
    });
  },
  render:<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> num = <span class="keyword">this</span>._getNum();

    <span class="keyword">if</span> ($(<span class="string">'#J_input_count'</span>).length == <span class="number">0</span>) {
      <span class="keyword">this</span>.get(<span class="string">'input'</span>).after(<span class="string">'&lt;span id="J_input_count"&gt;&lt;/span&gt;'</span>);
    };

    $(<span class="string">'#J_input_count'</span>).html(num+<span class="string">'个字'</span>);

  }
})

$(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">new</span> TextCount({
  <span class="comment">//这边直接传input的节点了，因为属性的赋值都是自动的。</span>
    input:$(<span class="string">"#J_input"</span>)
  });
})
</pre></td></tr></table></figure>

<p>可以看到我们直接实现一些固定的方法，bind，render就行了。其他的base会自动处理（这里只是简单处理了配置属性的赋值）。</p>
<p>事实上，这边的init，bind，render就已经有了点生命周期的影子，但凡是组件都会具有这几个阶段，初始化，绑定事件，以及渲染。当然这边还可以加一个destroy销毁的方法，用来清理现场。</p>
<p>此外为了方便，这边直接变成了传递input的节点。因为属性赋值自动化了，一般来说这种情况下都是使用getter，setter来处理。这边就不详细展开了。</p>
<h2 id="引入事件机制（观察者模式）">引入事件机制（观察者模式）</h2>
<p>有了base应该说我们编写组件更加的规范化，体系化了。下面我们继续深挖。</p>
<p>还是上面的那个例子，如果我们希望输入字的时候超过5个字就弹出警告。该怎么办呢。</p>
<p>小白可能会说，那简单啊直接改下bind方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">var</span> TextCount = Base.extend({
  ...
  bind:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    self.get(<span class="string">'input'</span>).on(<span class="string">'keyup'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
      <span class="keyword">if</span>(self._getNum() &gt; <span class="number">5</span>){
        alert(<span class="string">'超过了5个字了。。。'</span>)
      }
      self.render();
    });
  },
  ...
})
</pre></td></tr></table></figure>

<p>的确也是一种方法，但是太low了，代码严重耦合。当这种需求特别特别多，代码会越来越乱。</p>
<p>这个时候就要引入事件机制，也就是经常说的观察者模式。</p>
<blockquote>
<p>注意这边的事件机制跟平时的浏览器那些事件不是一回事，要分开来看。</p>
</blockquote>
<p>什么是观察者模式呢，官方的解释就不说了，直接拿这个例子来说。</p>
<p>想象一下base是个机器人会说话，他会一直监听输入的字数并且汇报出去（通知）。而你可以把耳朵凑上去，听着他的汇报（监听）。发现字数超过5个字了，你就做些操作。</p>
<p>所以这分为两个部分，一个是通知，一个是监听。</p>
<p>假设通知是 fire方法，监听是on。于是我们可以这么写代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="keyword">var</span> TextCount = Base.extend({
  ...
  bind:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    self.get(<span class="string">'input'</span>).on(<span class="string">'keyup'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
      <span class="comment">//通知,每当有输入的时候，就报告出去。</span>
      self.fire(<span class="string">'Text.input'</span>,self._getNum())
      self.render();
    });
  },
  ...
})

$(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> t = <span class="keyword">new</span> TextCount({
    input:$(<span class="string">"#J_input"</span>)
  });
  <span class="comment">//监听这个输入事件</span>
  t.on(<span class="string">'Text.input'</span>,<span class="function"><span class="keyword">function</span><span class="params">(num)</span>{</span>
    <span class="comment">//可以获取到传递过来的值</span>
    <span class="keyword">if</span>(num&gt;<span class="number">5</span>){
       alert(<span class="string">'超过了5个字了。。。'</span>)
    }
  })
})
</pre></td></tr></table></figure>

<p>fire用来触发一个事件，可以传递数据。而on用来添加一个监听。这样组件里面只负责把一些关键的事件抛出来，至于具体的业务逻辑都可以添加监听来实现。没有事件的组件是不完整的。</p>
<p>下面我们看看怎么实现这套事件机制。</p>
<p>我们首先抛开base，想想怎么实现一个具有这套机制的类。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
</pre></td><td class="code"><pre>
<span class="comment">//辅组函数，获取数组里某个元素的索引 index</span>
<span class="keyword">var</span> _indexOf = <span class="function"><span class="keyword">function</span><span class="params">(array,key)</span>{</span>
  <span class="keyword">if</span> (array === <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>
  <span class="keyword">var</span> i = <span class="number">0</span>, length = array.length
  <span class="keyword">for</span> (; i &lt; length; i++) <span class="keyword">if</span> (array[i] === item) <span class="keyword">return</span> i
  <span class="keyword">return</span> -<span class="number">1</span>
}

<span class="keyword">var</span> Event = Class.extend({
  <span class="comment">//添加监听</span>
  on:<span class="function"><span class="keyword">function</span><span class="params">(key,listener)</span>{</span>
    <span class="comment">//this.__events存储所有的处理函数</span>
    <span class="keyword">if</span> (!<span class="keyword">this</span>.__events) {
      <span class="keyword">this</span>.__events = {}
    }
    <span class="keyword">if</span> (!<span class="keyword">this</span>.__events[key]) {
      <span class="keyword">this</span>.__events[key] = []
    }
    <span class="keyword">if</span> (_indexOf(<span class="keyword">this</span>.__events,listener) === -<span class="number">1</span> && <span class="keyword">typeof</span> listener === <span class="string">'function'</span>) {
      <span class="keyword">this</span>.__events[key].push(listener)
    }

    <span class="keyword">return</span> <span class="keyword">this</span>
  },
  <span class="comment">//触发一个事件，也就是通知</span>
  fire:<span class="function"><span class="keyword">function</span><span class="params">(key)</span>{</span>

    <span class="keyword">if</span> (!<span class="keyword">this</span>.__events || !<span class="keyword">this</span>.__events[key]) <span class="keyword">return</span>

    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>) || []

    <span class="keyword">var</span> listeners = <span class="keyword">this</span>.__events[key]
    <span class="keyword">var</span> i = <span class="number">0</span>
    <span class="keyword">var</span> l = listeners.length

    <span class="keyword">for</span> (i; i &lt; l; i++) {
      listeners[i].apply(<span class="keyword">this</span>,args)
    }

    <span class="keyword">return</span> <span class="keyword">this</span>
  },
  <span class="comment">//取消监听</span>
  off:<span class="function"><span class="keyword">function</span><span class="params">(key,listener)</span>{</span>

    <span class="keyword">if</span> (!key && !listener) {
      <span class="keyword">this</span>.__events = {}
    }
    <span class="comment">//不传监听函数，就去掉当前key下面的所有的监听函数</span>
    <span class="keyword">if</span> (key && !listener) {
      <span class="keyword">delete</span> <span class="keyword">this</span>.__events[key]
    }

    <span class="keyword">if</span> (key && listener) {
      <span class="keyword">var</span> listeners = <span class="keyword">this</span>.__events[key]
      <span class="keyword">var</span> index = _indexOf(listeners, listener)

      (index &gt; -<span class="number">1</span>) && listeners.splice(index, <span class="number">1</span>)
    }

    <span class="keyword">return</span> <span class="keyword">this</span>;
  }
})


<span class="keyword">var</span> a = <span class="keyword">new</span> Event()

<span class="comment">//添加监听 test事件</span>
a.on(<span class="string">'test'</span>,<span class="function"><span class="keyword">function</span><span class="params">(msg)</span>{</span>
  alert(msg)
})

<span class="comment">//触发 test事件</span>
a.fire(<span class="string">'test'</span>,<span class="string">'我是第一次触发'</span>)
a.fire(<span class="string">'test'</span>,<span class="string">'我又触发了'</span>)

a.off(<span class="string">'test'</span>)

a.fire(<span class="string">'test'</span>,<span class="string">'你应该看不到我了'</span>)
</pre></td></tr></table></figure>

<p>实现起来并不复杂，只要使用this.__events存下所有的监听函数。在fire的时候去找到并且执行就行了。</p>
<p>这个时候面向对象的好处就来了，如果我们希望base拥有事件机制。只需要这么写:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">var</span> Base = Class.extend(Event,{
  ...
  destroy:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="comment">//去掉所有的事件监听</span>
    <span class="keyword">this</span>.off()
  }
})
<span class="comment">//于是可以</span>
<span class="comment">//var a  = new Base()</span>
<span class="comment">// a.on(xxx,fn)</span>
<span class="comment">//</span>
<span class="comment">// a.fire()</span>
</pre></td></tr></table></figure>

<p>是的只要extend的时候多混入一个Event，这样Base或者它的子类生成的对象都会自动具有事件机制。</p>
<p>有了事件机制我们可以把组件内部很多状态暴露出来，比如我们可以在set方法中抛出一个事件，这样每次属性变更的时候我们都可以监听到。</p>
<p>到这里为止，我们的base类已经像模像样了，具有了init，bind，render，destroy方法来表示组件的各个关键过程，并且具有了事件机制。基本上已经可以很好的来开发组件了。</p>
<h2 id="更进一步，richbase">更进一步，richbase</h2>
<p>我们还可以继续深挖。看看我们的base，还差些什么。首先浏览器的事件监听还很落后，需要用户自己在bind里面绑定，再然后现在的TextCount里面还存在dom操作，也没有自己的模板机制。这都是需要扩展的，于是我们在base的基础上再继承出一个richbase用来实现更完备的组件基类。</p>
<p>主要实现这些功能：</p>
<ul>
<li>事件代理：不需要用户自己去找dom元素绑定监听，也不需要用户去关心什么时候销毁。</li>
<li>模板渲染：用户不需要覆盖render方法，而是覆盖实现setUp方法。可以通过在setUp里面调用render来达到渲染对应html的目的。</li>
<li>单向绑定：通过setChuckdata方法，更新数据，同时会更新html内容，不再需要dom操作。</li>
</ul>
<p>我们看下我们实现richbase后怎么写组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre></td><td class="code"><pre><span class="keyword">var</span> TextCount = RichBase.extend({
  <span class="comment">//事件直接在这里注册，会代理到parentNode节点，parentNode节点在下面指定</span>
  EVENTS:{
    <span class="comment">//选择器字符串，支持所有jQuery风格的选择器</span>
    <span class="string">'input'</span>:{
      <span class="comment">//注册keyup事件</span>
      keyup:<span class="function"><span class="keyword">function</span><span class="params">(self,e)</span>{</span>
        <span class="comment">//单向绑定，修改数据直接更新对应模板</span>
        self.setChuckdata(<span class="string">'count'</span>,self._getNum())

      }
    }
  },
  <span class="comment">//指定当前组件的模板</span>
  template:<span class="string">'&lt;span id="J_input_count"&gt;&lt;%= count %&gt;个字&lt;/span&gt;'</span>,
  <span class="comment">//私有方法</span>
  _getNum:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.get(<span class="string">'input'</span>).val().length || <span class="number">0</span>
  },
  <span class="comment">//覆盖实现setUp方法，所有逻辑写在这里。最后可以使用render来决定需不需要渲染模板</span>
  <span class="comment">//模板渲染后会append到parentNode节点下面，如果未指定，会append到document.body</span>
  setUp:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> self = <span class="keyword">this</span>;

    <span class="keyword">var</span> input = <span class="keyword">this</span>.get(<span class="string">'parentNode'</span>).find(<span class="string">'#J_input'</span>)
    self.set(<span class="string">'input'</span>,input)

    <span class="keyword">var</span> num = <span class="keyword">this</span>._getNum()
    <span class="comment">//赋值数据，渲染模板，选用。有的组件没有对应的模板就可以不调用这步。</span>
    self.render({
      count:num
    })

  }
})

$(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="comment">//传入parentNode节点，组件会挂载到这个节点上。所有事件都会代理到这个上面。</span>
  <span class="keyword">new</span> TextCount({
    parentNode:$(<span class="string">"#J_test_container"</span>)
  });
})

<span class="comment">/**对应的html,做了些修改，主要为了加上parentNode，这边就是J_test_container

&lt;div id="J_test_container"&gt;
  &lt;input type="text" id="J_input"/&gt;
&lt;/div&gt;

*/</span>
</pre></td></tr></table></figure>

<p>看下上面的用法，可以看到变得更简单清晰了：</p>
<ul>
<li>事件不需要自己绑定，直接注册在EVENTS属性上。程序会自动将事件代理到parentNode上。</li>
<li>引入了模板机制，使用template规定组件的模板，然后在setUp里面使用render(data)的方式渲染模板，程序会自动帮你append到parentNode下面。</li>
<li>单向绑定，无需操作dom，后面要改动内容，不需要操作dom，只需要调用setChuckdata(key,新的值)，选择性的更新某个数据，相应的html会自动重新渲染。</li>
</ul>
<p>下面我们看下richebase的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
</pre></td><td class="code"><pre>
<span class="keyword">var</span> RichBase = Base.extend({
  EVENTS:{},
  template:<span class="string">''</span>,
  init:<span class="function"><span class="keyword">function</span><span class="params">(config)</span>{</span>
    <span class="comment">//存储配置项</span>
    <span class="keyword">this</span>.__config = config
    <span class="comment">//解析代理事件</span>
    <span class="keyword">this</span>._delegateEvent()
    <span class="keyword">this</span>.setUp()
  },
  <span class="comment">//循环遍历EVENTS，使用jQuery的delegate代理到parentNode</span>
  _delegateEvent:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> self = <span class="keyword">this</span>
    <span class="keyword">var</span> events = <span class="keyword">this</span>.EVENTS || {}
    <span class="keyword">var</span> eventObjs,fn,select,type
    <span class="keyword">var</span> parentNode = <span class="keyword">this</span>.get(<span class="string">'parentNode'</span>) || $(document.body)

    <span class="keyword">for</span> (select <span class="keyword">in</span> events) {
      eventObjs = events[select]

      <span class="keyword">for</span> (type <span class="keyword">in</span> eventObjs) {
        fn = eventObjs[type]

        parentNode.delegate(select,type,<span class="function"><span class="keyword">function</span><span class="params">(e)</span>{</span>
          fn.call(<span class="literal">null</span>,self,e)
        })
      }

    }

  },
  <span class="comment">//支持underscore的极简模板语法</span>
  <span class="comment">//用来渲染模板，这边是抄的underscore的。非常简单的模板引擎，支持原生的js语法</span>
  _parseTemplate:<span class="function"><span class="keyword">function</span><span class="params">(str,data)</span>{</span>
    <span class="comment">/**
     * http://ejohn.org/blog/javascript-micro-templating/
     * https://github.com/jashkenas/underscore/blob/0.1.0/underscore.js#L399
     */</span>
    <span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'obj'</span>,
        <span class="string">'var p=[],print=function(){p.push.apply(p,arguments);};'</span> +
        <span class="string">'with(obj){p.push(\''</span> + str
            .replace(<span class="regexp">/[\r\t\n]/g</span>, <span class="string">" "</span>)
            .split(<span class="string">"&lt;%"</span>).join(<span class="string">"\t"</span>)
            .replace(<span class="regexp">/((^|%&gt;)[^\t]*)'/g</span>, <span class="string">"$1\r"</span>)
            .replace(<span class="regexp">/\t=(.*?)%&gt;/g</span>, <span class="string">"',$1,'"</span>)
            .split(<span class="string">"\t"</span>).join(<span class="string">"');"</span>)
            .split(<span class="string">"%&gt;"</span>).join(<span class="string">"p.push('"</span>)
            .split(<span class="string">"\r"</span>).join(<span class="string">"\\'"</span>) +
        <span class="string">"');}return p.join('');"</span>)
    <span class="keyword">return</span> data ? fn(data) : fn
  },
  <span class="comment">//提供给子类覆盖实现</span>
  setUp:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">this</span>.render()
  },
  <span class="comment">//用来实现刷新，只需要传入之前render时的数据里的key还有更新值，就可以自动刷新模板</span>
  setChuckdata:<span class="function"><span class="keyword">function</span><span class="params">(key,value)</span>{</span>
    <span class="keyword">var</span> self = <span class="keyword">this</span>
    <span class="keyword">var</span> data = self.get(<span class="string">'__renderData'</span>)

    <span class="comment">//更新对应的值</span>
    data[key] = value

    <span class="keyword">if</span> (!<span class="keyword">this</span>.template) <span class="keyword">return</span>;
    <span class="comment">//重新渲染</span>
    <span class="keyword">var</span> newHtmlNode = $(self._parseTemplate(<span class="keyword">this</span>.template,data))
    <span class="comment">//拿到存储的渲染后的节点</span>
    <span class="keyword">var</span> currentNode = self.get(<span class="string">'__currentNode'</span>)
    <span class="keyword">if</span> (!currentNode) <span class="keyword">return</span>;
    <span class="comment">//替换内容</span>
    currentNode.replaceWith(newHtmlNode)

    self.set(<span class="string">'__currentNode'</span>,newHtmlNode)

  },
  <span class="comment">//使用data来渲染模板并且append到parentNode下面</span>
  render:<span class="function"><span class="keyword">function</span><span class="params">(data)</span>{</span>
    <span class="keyword">var</span> self = <span class="keyword">this</span>
    <span class="comment">//先存储起来渲染的data,方便后面setChuckdata获取使用</span>
    self.set(<span class="string">'__renderData'</span>,data)

    <span class="keyword">if</span> (!<span class="keyword">this</span>.template) <span class="keyword">return</span>;

    <span class="comment">//使用_parseTemplate解析渲染模板生成html</span>
    <span class="comment">//子类可以覆盖这个方法使用其他的模板引擎解析</span>
    <span class="keyword">var</span> html = self._parseTemplate(<span class="keyword">this</span>.template,data)

    <span class="keyword">var</span> parentNode = <span class="keyword">this</span>.get(<span class="string">'parentNode'</span>) || $(document.body)

    <span class="keyword">var</span> currentNode = $(html)
    <span class="comment">//保存下来留待后面的区域刷新</span>
    <span class="comment">//存储起来，方便后面setChuckdata获取使用</span>
    self.set(<span class="string">'__currentNode'</span>,currentNode)
    parentNode.append(currentNode)
  },
  destroy:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>

    <span class="keyword">var</span> self = <span class="keyword">this</span>
    <span class="comment">//去掉自身的事件监听</span>
    self.off()
    <span class="comment">//删除渲染好的dom节点</span>
    self.get(<span class="string">'__currentNode'</span>).remove()
    <span class="comment">//去掉绑定的代理事件</span>
    <span class="keyword">var</span> events = self.EVENTS || {}
    <span class="keyword">var</span> eventObjs,fn,select,type
    <span class="keyword">var</span> parentNode = self.get(<span class="string">'parentNode'</span>)

    <span class="keyword">for</span> (select <span class="keyword">in</span> events) {
      eventObjs = events[select]

      <span class="keyword">for</span> (type <span class="keyword">in</span> eventObjs) {
        fn = eventObjs[type]

        parentNode.undelegate(select,type,fn)
      }

    }

  }
})
</pre></td></tr></table></figure>

<p>主要做了两件事，一个就是事件的解析跟代理，全部代理到parentNode上面。另外就是把render抽出来，用户只需要实现setUp方法。如果需要模板支持就在setUp里面调用render来渲染模板，并且可以通过setChuckdata来刷新模板，实现单向绑定。</p>
<h2 id="结语">结语</h2>
<p>有了richbase，基本上组件开发就没啥问题了。但是我们还是可以继续深挖下去。</p>
<p>比如组件自动化加载渲染，局部刷新，比如父子组件的嵌套，再比如双向绑定，再比如实现ng-click这种风格的事件机制。</p>
<p>当然这些东西已经不属于组件里面的内容了。再进一步其实已经是一个框架了。实际上最近比较流行的react，ploymer还有我们的brix等等都是实现了这套东西。受限于篇幅，这个以后有空再写篇文章详细分析下。</p>
<blockquote>
<p>鉴于有人跟我要完整代码，其实上面都列出来了。好吧 那我就再整理下，放在github了包含具体的demo，请点<a href="https://github.com/purplebamboo/demo-richbase/tree/master/example" target="_blank">这里</a>。不过仅仅作为理解使用最好不要用于生产环境。如果觉得有帮助就给我个star吧。</p>
</blockquote>
]]></content:encoded>
      <comments>http://purplebamboo.github.com/2015/03/16/javascript-component/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[前端开发环境过滤器]]></title>
      <link>http://purplebamboo.github.com/2015/02/16/qfilter/</link>
      <guid>http://purplebamboo.github.com/2015/02/16/qfilter/</guid>
      <pubDate>Mon, 16 Feb 2015 06:35:04 GMT</pubDate>
      <description>
      <![CDATA[<p>作为一个前端，经常被各种环境困扰。古人说穷则变变则通。最近实在是忍受不了之前开发环境的总总弊端，下定决心好好整了整。</p>
<h2 id="那些年被虐待的经历">那些年被虐待的经历</h2>
<p>鄙人公司目前后端开发还是主要以java为主，使用的是spring的架构。之]]>
      </description>
      <content:encoded><![CDATA[<p>作为一个前端，经常被各种环境困扰。古人说穷则变变则通。最近实在是忍受不了之前开发环境的总总弊端，下定决心好好整了整。</p>
<h2 id="那些年被虐待的经历">那些年被虐待的经历</h2>
<p>鄙人公司目前后端开发还是主要以java为主，使用的是spring的架构。之前的开发情况是，前端切好静态页面，给开发去套vm。</p>
<p>显然这是一种特别效率低下的事情。开发其实很多时候不能理解我们的html结构，所以多数时候我们得跑到开发旁边，一起改vm。</p>
<p>后来开发说了，他们不管vm了，让我们写。好啊，我们写还自由点。可是我还是too young too simple。写vm，我们只能在本地跑java环境，这个包，那个包。这个依赖，那个依赖。经常是开发svn升级了一个包，我们这边就跑不起来环境了，然后又是各种找开发来帮忙整环境，苦不开言。这里深深鄙视下java，大部分时间都花在打包还有环境调试上了。</p>
<p>再后来我们想了个办法，嗯，有那种持续集成环境，就是一个线上虚拟机。我们不用本地跑vm了。不过问题依旧，经常性的环境挂掉。而且最大的问题是每次svn改了vm。都要去发布下。</p>
<p>再后来不能忍了，团队的大牛推荐了<a href="http://purplebamboo.github.io/2014/05/14/start_with_vagrant/" target="_blank">vagrant</a>。可以本地跑虚拟机，采用分发的方式。开发跑vagrant。然后打包发给我们，这样环境就一模一样。而且是本地虚拟机，所以改了vm立马生效。听起来很美好，可是再次证明现实很骨感，环境还是经常性的挂掉，因为开发用的windows，而我们vagrant里面的跑的linux，还是不少差别。在开发帮忙调试了几次环境后，发现问题依旧。也越来越懒得帮我们看环境了。</p>
<p>再后来，又回到了原始的境地，前端跑到开发旁边调vm。调js。</p>
<h2 id="忍无可忍无需再忍">忍无可忍无需再忍</h2>
<p>就这样，我们一直忍受着这种开发模式。因为nodejs如今如火如荼的进行着，而公司内部各个bu都在考虑用node做前后端分离，我们一直期待着有一天，把view层抽出来。这样就不用再跑java环境了。java只提供http数据接口。整个渲染层交给node，由我们自己把控。还可以自己模拟数据。</p>
<p>想想还是有点小激动呢。</p>
<p>但是。。。现实还是再一次拍死了我们。因为开发，运维对node还是有点抵触的：</p>
<ul>
<li>认为这么新的东西。稳定性没有保障。</li>
<li>而且vm用的好好的，干啥要换。使用了node中间层反而增加了前端的工作量，本来就资源不够了。</li>
<li>对开发其实并没有特别的好处，只是方便了前端把控环境。</li>
</ul>
<p>于是在我们老大跟他们讨论了几次后，node中间层一直在做ing。嗯，这个做的过程不知道要持续多久。</p>
<p>作为小p，推动不了这么大的全局性的改变。但是环境问题真的受！够！了！</p>
<p>偶然的情况下发现了<a href="https://github.com/shepherdwind/velocity.js" target="_blank">velocityjs</a>这个项目。于是想着完全可以用node来模拟java环境嘛，把vm跑起来不就好了。</p>
<p>说干就干，于是在后来一个比较小的模板展示的项目里，使用express搭建了一套环境。把vm跑起来了。并且vm上面的那些变量都是我们自己使用json模拟。</p>
<p>于是我们终于解脱了，不再需要跑java环境，还可以脱离java。把功能完全写好，各个逻辑都使用模拟数据验证完，然后跟开发联调基本就是分分种的事。</p>
<h2 id="想的更多点">想的更多点</h2>
<p>虽然我们在小的项目里尝试了。但是对于比较复杂的项目，还是觉得整体改造比较困难。后来商量了下，其实可以做一个命令行工具。进行一些简单的配置就可以把vm跑起来。没错感觉就是个启动服务的工具了。</p>
<p>其实除了vm渲染的问题，我们还面对不少困难。</p>
<ol>
<li>本地静态服务，之前都是本地起一个nginx。来新人了，都得教半天配置。另外线上的静态资源有时是支持combo的。我们跑vm的时候都得把combo的资源人肉切分。</li>
<li>项目一般都是使用less编写。开发的时候需要使用gulp跑一个watch，或者使用<a href="http://koala-app.com/index-zh.html" target="_blank">koala</a>这种工具。</li>
<li>ajax请求无法模拟，做静态页面的时候。都是自己写个简单的php脚本，打出一些简单的数据，来模拟。</li>
<li>在线上环境调试时，不方便。线上引用的都是压缩的文件。虽然可以通过url变量控制引用不压缩的。但是修改代码的时候，还是需要本地改好，打包发cdn，一看效果不对又要回滚。后来想到用<a href="http://cssha.com/reres/" target="_blank">reres</a>来映射线上js到本地。可是combo的资源映射起来就难办了。另外我们前端使用了一种打包技术，将html模板打包到js里面，所以直接映射js就少了模板。总之一直是一个头两个大。</li>
</ol>
<p>总体来说，我们的环境太零散，太凌乱。用起来也是各种困难。</p>
<p>所以想着能不能搞个工具解决所有这些问题呢？</p>
<p>正好那段时间一直在玩koa。突然发现koa天生适合解决这个问题。于是说干就敢，制作了<a href="https://github.com/purplebamboo/qfilter" target="_blank">qfilter</a>这个工具。</p>
<p>说白了使用koa开一个本地服务命令行工具：</p>
<ol>
<li>开发一个静态资源中间件用来处理js，css，html请求，支持combo。</li>
<li>开发一个vm中间件，当请求是vm模板时就使用velocityjs渲染vm后返回。</li>
<li>开发一个ajax中间件，处理所有的ajax请求。</li>
<li>开发一个rewrite中间件来改写请求的url。</li>
<li>开发一个less中间件实时编译less。</li>
</ol>
<p>我们看上面说的：</p>
<p>第一个问题，静态资源中间件就解决了。</p>
<p>第二个问题，先使用rewrite中间件来改写请求的路径url，把css的请求映射到对应的less文件，并且到下一个less中间件时实时编译返回的内容返回。性能上并没有啥大问题。</p>
<p>第三个问题，ajax中间件搞定，只需要指定个目录，写一些模拟数据就好了。</p>
<p>第四个问题，因为通过上面的一系列中间件，可以使本地环境跟线上环境一模一样。我们只需要使用switchsharp这种代理软件把线上的js请求都映射到本地的服务，线上的css请求会映射到本地服务，本地服务再请求对应的less，再实时编译返回。线上的combojs请求，映射到本地服务，本地服务自动分割合并不同的js返回给浏览器。并且是立即修改，立即生效，调试变得异常简单。</p>
<p>整体上的思路，就是线上线下的页面都是一样的，线上请求什么，线下开发也是一样的。但是请求过来了，返回什么内容是本地服务说了算，请求css，我映射到对应的less并且编译返回。请求vm，我渲染后再返回。只不过线上是直接请求的打包生成好的css。请求的也是java渲染好的vm。而这些本地的服务都能百分百模拟。</p>
<p>于是前端开发的时候，不需要跑java环境了，如果前面的人配置好了各个参数。新人只需要跑到环境根目录下运行 <code>qf s</code> 于是世界清静了。所有的环境都在这一行命令行里面了。环境不再碎片化。而且线上线下一套环境，无缝切换。调试也更加简单。解放了大量的劳动力。</p>
<p>最终产出了这个基于koa的工具  <a href="https://github.com/purplebamboo/qfilter" target="_blank">qfilter</a></p>
<h2 id="结语">结语</h2>
<p>任何事情，不要期望着未来遥远的解决方案，与其等遥远的阳光，还不如先想办法解决当前寒冷的问题。将来node中间件必将彻底解决环境问题，解决前后端分离问题。其实我这种反而是旁门左道了，但是我觉得解决问题才是最重要的。更何况，其实qfilter不只是解决了vm的渲染问题了。</p>
]]></content:encoded>
      <comments>http://purplebamboo.github.com/2015/02/16/qfilter/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[javascript模块加载器实践]]></title>
      <link>http://purplebamboo.github.com/2015/01/17/javascript-module/</link>
      <guid>http://purplebamboo.github.com/2015/01/17/javascript-module/</guid>
      <pubDate>Sat, 17 Jan 2015 14:02:44 GMT</pubDate>
      <description>
      <![CDATA[<p>但凡是比较成熟的服务端语言，都会有模块或者包的概念。模块化开发的好处就不用多说了。由于javascript的运行环境（浏览器）的特殊性。js很早之前一直都没有模块的概念。经过一代代程序猿们的努力。提供了若干的解决方案。</p>
<h2 id="基本对象">基本对象</h2>]]>
      </description>
      <content:encoded><![CDATA[<p>但凡是比较成熟的服务端语言，都会有模块或者包的概念。模块化开发的好处就不用多说了。由于javascript的运行环境（浏览器）的特殊性。js很早之前一直都没有模块的概念。经过一代代程序猿们的努力。提供了若干的解决方案。</p>
<h2 id="基本对象">基本对象</h2>
<p>为了解决模块化的问题。早期的程序员会把代码放到某个变量里。做一个最简单的命名空间的划分。</p>
<p>比如一个工具模块：util</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>
<span class="keyword">var</span> util = {
    _prefix:<span class="string">'我想说：'</span>,
    log:<span class="function"><span class="keyword">function</span><span class="params">(msg)</span>{</span> console.log(_prefix +msg)}
    <span class="comment">/*
    其他工具函数
    */</span>
}
</pre></td></tr></table></figure>

<p>这样所有的工具函数都托管在util这个对象变量里，极其简陋的弄了个伪命名空间。这样的局限性很大，因为我们可以随意修改。util不存在私有的属性。_prefix这个私有属性，后面可以随意修改。而我们很难定位到到底在哪边被修改了。</p>
<h2 id="闭包立即执行">闭包立即执行</h2>
<p>后来，一些程序员想到了方法解决私有属性的问题，有了下面这种写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> util = (<span class="function"><span class="keyword">function</span><span class="params">(window)</span>{</span>

    <span class="keyword">var</span> _prefix = <span class="string">'我想说：'</span>;
    <span class="keyword">return</span> {
        log:<span class="function"><span class="keyword">function</span><span class="params">(msg)</span>{</span> console.log(_prefix +msg)}
    }

})(window)
</pre></td></tr></table></figure>

<p>主要使用了匿名函数立即执行的技巧，这样 <code>_prefix</code> 是一个匿名函数里面的局部变量，外面无法修改。但是log这个函数里面又因为闭包的关系可以访问到_prefix。只把公用的方法暴露出去。</p>
<p>这是后来模块划分的主要技巧，各大库比如jQuery，都会在最外层包裹这样一个匿名函数。</p>
<p>但是这只是在同一个文件里面的技巧，如果我们把util单独写到一个文件util.js。而我们程序的主代码是main.js那我们需要在页面里面一起用script标签引入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>&lt;script src=<span class="string">"main.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"util.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span>
</pre></td></tr></table></figure>

<p>这会有不少问题，最典型的比如如果我们的main.js如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>util.log(<span class="string">'我是模块主代码，我加载好了'</span>)
</pre></td></tr></table></figure>

<p>这个就执行不了，因为我们的util.js是在main.js后面引入的。所以执行main.js的内容的时候util还没定义呢。<br>不止这个问题，再比如如果引入了其他的js文件，并且也定义了util这个变量。就会混乱。</p>
<h2 id="模块加载器">模块加载器</h2>
<p>node作为javascript服务端的一种应用场景，加入了文件模块的概念，主要是实现的<a href="http://javascript.ruanyifeng.com/nodejs/commonjs.html" target="_blank">CommonJS规范</a>。</p>
<p>后来一些程序员就想，服务端可以有文件模块。浏览器端为什么就不可以呢。但是CommonJS规范是设计给服务端语言用的，不适合浏览器端的js。</p>
<p>于是出现了<a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank">amd规范</a>，并且在这个基础上出现了实现amd规范的库requirejs。</p>
<p>后来国内的大神玉伯由于多次给requirejs提建议（比如用时定义）一直不被采纳。于是另起炉灶制作了seajs。慢慢的也沉淀出了seajs的<a href="https://github.com/cmdjs/specification/blob/master/draft/module.md" target="_blank">cmd规范</a>。</p>
<p>关于模块规范的具体历史，可以参考：<a href="https://github.com/seajs/seajs/issues/588" target="_blank">https://github.com/seajs/seajs/issues/588</a></p>
<p>两个规范差别并不是很大，可能由于写node习惯了，个人更喜欢cmd的编写方式。</p>
<p>首先我们看看基于cmd规范（其实就是seajs）后我们怎么写代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre>
<span class="comment">//util.js</span>
define(<span class="function"><span class="keyword">function</span><span class="params">(require, exports, module)</span>{</span>
    <span class="keyword">var</span> _prefix = <span class="string">'我想说：'</span>;
    module.exports = {
        log:<span class="function"><span class="keyword">function</span><span class="params">(msg)</span>{</span> console.log(_prefix +msg)}
    }
})

<span class="comment">///main.js</span>
define(<span class="function"><span class="keyword">function</span><span class="params">(require, exports, module)</span>{</span>
    <span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>)
    util.log(<span class="string">'我是模块主代码，我加载好了'</span>)
})

<span class="comment">///index.html</span>
&lt;html&gt;
<span class="xml"><span class="tag">&lt;<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"seajs.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">'text/javascript'</span>&gt;</span><span class="javascript">
    seajs.use([<span class="string">"main"</span>])
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span></span>
</pre></td></tr></table></figure>

<p>seajs的书写风格跟node很像。</p>
<ul>
<li>使用define来定义一个模块。</li>
<li>模块代码里可以使用require去加载另一个模块，</li>
<li>使用exports，module.exports来设置结果。</li>
<li>通过seajs.use来加载一个主模块。类似c，java里面的main函数。</li>
</ul>
<p>seajs会自动帮你加载好模块的文件，并且正确的处理依赖关系。于是前端终于也可以使用模块化的开发方式了。</p>
<h2 id="一步一步实现模块加载器">一步一步实现模块加载器</h2>
<p>下面我们来实现一个简单的cmd模块加载器程序，也可以当作是seajs的核心源码分析。</p>
<h3 id="获取加载根路径">获取加载根路径</h3>
<p>cmd模块规定一个模块一个文件，当我们<code>require(&#39;util&#39;)</code>的时候需要找到对应的文件，一般会加上根路径。默认情况下加载模块的根路径就是seajs.js所在目录。如何获取这个目录地址呢？我们只要在seajs.js里面写上：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">var</span> loadderDir = (<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>

    <span class="comment">//使用正则获取一个文件所在的目录</span>
    <span class="function"><span class="keyword">function</span> <span class="title">dirname</span><span class="params">(path)</span> {</span>
        <span class="keyword">return</span> path.match(<span class="regexp">/[^?#]*\//</span>)[<span class="number">0</span>]
    }
    <span class="comment">//拿到引用seajs所在的script节点</span>
    <span class="keyword">var</span> scripts = document.scripts
    <span class="keyword">var</span> ownScript = scripts[scripts.length - <span class="number">1</span>]

    <span class="comment">//获取绝对地址的兼容写法</span>
    <span class="keyword">var</span> src = ownScript.hasAttribute ? ownScript.src :ownScript.getAttribute(<span class="string">"src"</span>, <span class="number">4</span>)

    <span class="keyword">return</span> dirname(src)

})()
</pre></td></tr></table></figure>

<p>这边有两个小技巧：</p>
<ul>
<li>浏览器是遇到一个script标记执行一个，当seajs.js正在执行的时候，document.scripts获取到的最后一个script就是当前正在执行的script。所以我们可以通过<code>scripts[scripts.length - 1]</code>拿到引用seajs.js的那个script节点引用。</li>
<li>要获取一个 script节点的src绝对地址。除ie67外，ownScript.src返回的都是绝对地址，但是ie67src是什么就返回什么，这边就是’seajs.js’而不是绝对地址。幸好ie下支持<code>getAttribute(&quot;src&quot;, 4)</code>的方式获取绝对地址。参考<a href="http://msdn.microsoft.com/en-us/library/ms536429(VS.85" target="_blank">这里</a>.aspx)。ie67下没有 hasAttribute属性，所以就有了获取绝对地址的兼容写法。</li>
</ul>
<h3 id="异步js文件加载器">异步js文件加载器</h3>
<p>模块加载是建立在文件加载器基础上的。在浏览器环境下我们可以通过动态生成script标记的方式，加载js。我们写一个简单js文件加载器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="keyword">var</span> head = document.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>]
<span class="keyword">var</span> baseElement = head.getElementsByTagName(<span class="string">"base"</span>)[<span class="number">0</span>]
;<span class="function"><span class="keyword">function</span> <span class="title">request</span><span class="params">(url,callback)</span>{</span>

    <span class="keyword">var</span> node = document.createElement(<span class="string">"script"</span>)

    <span class="keyword">var</span> supportOnload = <span class="string">"onload"</span> <span class="keyword">in</span> node

    <span class="keyword">if</span> (supportOnload) {
        node.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            callback()
        }
    }<span class="keyword">else</span> {
        node.onreadystatechange = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
          <span class="keyword">if</span> (<span class="regexp">/loaded|complete/</span>.test(node.readyState)) {
            callback()
          }
        }
    }

    node.async = <span class="literal">true</span>
    node.src = url
    <span class="comment">//ie6下如果有base的script节点会报错，</span>
    <span class="comment">//所以有baseElement的时候不能用`head.appendChild(node)`,而是应该插入到base之前</span>
    baseElement ? head.insertBefore(node, baseElement) : head.appendChild(node)

}
</pre></td></tr></table></figure>

<p>主要就是动态生成一个script节点加载js,监听事件触发回调函数，没什么难度，算是一个工具函数，给下面的模块使用。</p>
<h3 id="模块类定义">模块类定义</h3>
<p>终于到了重头戏。我们需要引入一个模块类的概念。util，main这些都是一个模块。模块有自己的依赖，有自己的状态。</p>
<p>我们先定义一个模块类：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Module</span><span class="params">(uri,deps)</span>{</span>
  <span class="keyword">this</span>.uri = uri
  <span class="keyword">this</span>.dependencies = deps || []
  <span class="keyword">this</span>.factory = <span class="literal">null</span>
  <span class="keyword">this</span>.status = <span class="number">0</span>

  <span class="comment">// 哪些模块依赖我</span>
  <span class="keyword">this</span>._waitings = {}

  <span class="comment">// 我依赖的模块还有多少没加载好</span>
  <span class="keyword">this</span>._remain = <span class="number">0</span>
}
</pre></td></tr></table></figure>

<p>1.uri代表当前模块的地址，一般是使用baseUrl（就是上面的loadderDir）+ id + ‘.js’</p>
<p>2.dependencies是当前模块依赖的模块。</p>
<p>3.factory就是我们定义模块时define的参数<code>function(require, exports, module){}</code></p>
<p>4.status代表当前模块的状态，我们先定义下面这些状态：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="keyword">var</span> STATUS = Module.STATUS = {
  <span class="comment">// 1 - 对应的js文件正在加载</span>
  FETCHING: <span class="number">1</span>,
  <span class="comment">// 2 - js加载完毕，并且已经分析了js文件得到了一些相关信息，存储了起来</span>
  SAVED: <span class="number">2</span>,
  <span class="comment">// 3 - 依赖的模块正在加载</span>
  LOADING: <span class="number">3</span>,
  <span class="comment">// 4 - 依赖的模块也都加载好了，处于可执行状态</span>
  LOADED: <span class="number">4</span>,
  <span class="comment">// 5 - 正在执行这个模块</span>
  EXECUTING: <span class="number">5</span>,
  <span class="comment">// 6 - 这个模块执行完成</span>
  EXECUTED: <span class="number">6</span>
}
</pre></td></tr></table></figure>

<p>5.<code>_waitings</code>存放着依赖我的模块实例集合，<code>_remain</code>则代表我还有多少依赖模块是处于不可用，也就是上面的小于LOADED的状态。<br>这个的作用是什么呢？</p>
<p>是这样的，比如A模块依赖B,C模块。那么A模块装载的时候会先去通知B,C模块把自己（A）加入到他们的<code>_waitings</code>里面。当B模块装载好了，就可以通过遍历B自己的<code>_waitings</code>去更新依赖它的模块比如A的<code>_remain</code>值。B发现更新后A的<code>_remain</code>后不为0，就什么也不做。直到C也好了，C更新下A的<code>_remain</code>值发现为0了，就会调用A的完成回调了。</p>
<p>如果B，C有自己的依赖模块也是一样的原理。</p>
<p>而如果一个模块没有依赖的模块，就会立即进入完成状态，然后通知依赖它的模块更新<code>_remain</code>值。他们处于最底端，往上一级级的去更新状态。</p>
<p>模块相互之间的通知机制就是这样，那么状态是如何变化的呢。<br>我们给模块增加一些原型方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="comment">//用于加载当前模块所在文件</span>
<span class="comment">//加载前状态是STATUS.FETCHING,加载完成后状态是SAVED，加载完后调用当前模块的load方法</span>
Module.prototype.fetch = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>}

<span class="comment">//用于装载当前模块，装载之前状态变为STATUS.LOADING，主要初始化依赖的模块的加载情况。</span>
<span class="comment">//看一下依赖的模块有多少没有达到SAVED的状态，赋值给自己的_remain。另外对还没有加载的模块设置对应的_waitings，增加对自己的引用。</span>
<span class="comment">//挨个检查自己依赖的模块。发现依赖的模块都加载完成，或者没有依赖的模块就直接调用自己的onload</span>
<span class="comment">//如果发现依赖模块还有没加载的就调用它的fetch让它去加载。如果已经是加载完了，也就是SAVED状态的。就调用它的load</span>
Module.prototype.load = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>}

<span class="comment">//当模块装载完，也就是load之后会调用此函数。会将状态变为LOADED，并且遍历自己的_waitings，找到依赖自己的那些模块，更新相应的_remain值，发现为0的话就调用对应的onload。</span>
<span class="comment">//onload调用有两种情况，第一种就是一个模块没有任何依赖直接load后调用自己的onload.</span>
<span class="comment">//还有一种就是当前模块依赖的模块都已经加载完成，在那些加载完成的模块的onload里面会帮忙检测_remain。通知当前模块是否该调用onload</span>
<span class="comment">//这样就会使用上面说的那套通知机制，当一个没有依赖的模块加载好了，会检测依赖它的模块。发现_remain为0，就会帮忙调用那个模块的onload函数</span>
Module.prototype.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>}

<span class="comment">/*===========================================*/</span>
<span class="comment">/*****下面的几个跟上面的通知机制就没啥关系了*****/</span>
<span class="comment">/*===========================================*/</span>

<span class="comment">//exec用于执行当前模块的factory</span>
<span class="comment">//执行前为STATUS.FETCHING 执行后为STATUS.EXECUTED</span>
Module.prototype.exec = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>}

<span class="comment">//这是一个辅助方法，用来获取格式化当前依赖的模块的地址。</span>
<span class="comment">//比如上面就会把  ['util'] 格式化为 [baseUrl（就是上面的loadderDir）+ util + '.js']</span>
Module.prototype.resolve = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>}

<span class="comment">//实例生成方法，所有的模块都是单例的，get用来获得一个单例。</span>
Module.get = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>}
</pre></td></tr></table></figure>

<p>是不是感觉有点晕，没事我们一个个来看。</p>
<h3 id="辅助函数">辅助函数</h3>
<p>我们先把辅助函数实现下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="comment">//存储实例化的模块对象</span>
cachedMods = {}
<span class="comment">//根据uri获取一个对象，没有的话就生成一个新的</span>
Module.get = <span class="function"><span class="keyword">function</span><span class="params">(uri, deps)</span> {</span>
  <span class="keyword">return</span> cachedMods[uri] || (cachedMods[uri] = <span class="keyword">new</span> Module(uri, deps))
}

<span class="comment">//进行id到url的转换，实际情况会比这个复杂的多，可以支持各种配置,各种映射。</span>
<span class="function"><span class="keyword">function</span> <span class="title">id2Url</span><span class="params">(id)</span>{</span>
    <span class="keyword">return</span> loadderDir + id + <span class="string">'.js'</span>
}
<span class="comment">//解析依赖的模块的实际地址的集合</span>
Module.prototype.resolve = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
  <span class="keyword">var</span> mod = <span class="keyword">this</span>
  <span class="keyword">var</span> ids = mod.dependencies
  <span class="keyword">var</span> uris = []

  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = ids.length; i &lt; len; i++) {
    uris[i] = id2Url(ids[i])
  }
  <span class="keyword">return</span> uris

}
</pre></td></tr></table></figure>

<h3 id="fetch与define的实现">fetch与define的实现</h3>
<p>实现fetch之前我们先实现全局函数define。</p>
<p>fetch会生成script节点加载模块的具体代码。<br>还记得我们上面模块定义的写法吗？都是使用define来定义一个模块。define的主要任务就是生成当前模块的一些信息，给fetch使用。</p>
<p>define的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre>
<span class="keyword">var</span> REQUIRE_RE = <span class="regexp">/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'|\/\*[\S\s]*?\*\/|\/(?:\\\/|[^\/\r\n])+\/(?=[^\/])|\/\/.*|\.\s*require|(?:^|[^$])\brequire\s*\(\s*(["'])(.+?)\1\s*\)/g</span>
<span class="keyword">var</span> SLASH_RE = <span class="regexp">/\\\\/g</span>

<span class="comment">//工具函数，解析依赖的模块</span>
<span class="function"><span class="keyword">function</span> <span class="title">parseDependencies</span><span class="params">(code)</span> {</span>
  <span class="keyword">var</span> ret = []

  code.replace(SLASH_RE, <span class="string">""</span>)
      .replace(REQUIRE_RE, <span class="function"><span class="keyword">function</span><span class="params">(m, m1, m2)</span> {</span>
        <span class="keyword">if</span> (m2) {
          ret.push(m2)
        }
      })

  <span class="keyword">return</span> ret
}

<span class="function"><span class="keyword">function</span> <span class="title">define</span> <span class="params">(factory)</span> {</span>
  <span class="comment">//使用正则分析获取到对应的依赖模块</span>
  deps = parseDependencies(factory.toString())
  <span class="keyword">var</span> meta = {
    deps: deps,
    factory: factory
  }
  <span class="comment">//存到一个全局变量，等后面fetch在script的onload回调里获取。</span>
  anonymousMeta = meta
}
</pre></td></tr></table></figure>

<p>这边为了尽量展现原理，去掉了很多兼容的代码。<br>比如其实define是支持<code>function (id, deps, factory)</code>这种写法的，这样就可以提前写好模块的id和deps，这样就不需要通过正则去获取依赖的模块了。一般写的时候只写factory，上线时会使用构建工具生成好deps参数，这样可以避免压缩工具把require关键字压缩掉而导致依赖失效。性能上也会更好。</p>
<p>另外，为了兼容ie下面的script标签不一定触发的问题。这边其实有个getCurrentScript()的方法，用于获取当前正在解析的script节点的地址。这边略去，有兴趣的可以去源码里看看。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">getCurrentScript</span><span class="params">()</span> {</span>

<span class="comment">//主要原理就是在ie6-9下面可以查看script.readyState === "interactive"来判断当前节点是否处于加载状态</span>
  <span class="keyword">var</span> scripts = head.getElementsByTagName(<span class="string">"script"</span>)
  <span class="keyword">for</span> (<span class="keyword">var</span> i = scripts.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {
    <span class="keyword">var</span> script = scripts[i]
    <span class="keyword">if</span> (script.readyState === <span class="string">"interactive"</span>) {
      <span class="keyword">return</span> script
    }
  }
</pre></td></tr></table></figure>

<p>下面是fetch的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre>
Module.prototype.fetch = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> mod = <span class="keyword">this</span>
  <span class="keyword">var</span> uri = mod.uri

  mod.status = STATUS.FETCHING
  <span class="comment">//调用工具函数，异步加载js</span>
  request(uri, onRequest)

  <span class="comment">//保存模块信息</span>
  <span class="function"><span class="keyword">function</span> <span class="title">saveModule</span><span class="params">(uri, anonymousMeta)</span>{</span>
      <span class="comment">//使用辅助函数获取模块，没有就实例化个新的</span>
      <span class="keyword">var</span> mod = Module.get(uri)
      <span class="comment">//保存meta信息</span>
      <span class="keyword">if</span> (mod.status &lt; STATUS.SAVED) {
        mod.id = anonymousMeta.id || uri
        mod.dependencies = anonymousMeta.deps || []
        mod.factory = anonymousMeta.factory
        mod.status = STATUS.SAVED
      }
  }

  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span><span class="params">()</span> {</span>
    <span class="comment">//拿到之前define保存的meta信息</span>
    <span class="keyword">if</span> (anonymousMeta) {
      saveModule(uri, anonymousMeta)
      anonymousMeta = <span class="literal">null</span>
    }
    <span class="comment">//调用加载函数</span>
    mod.load()
  }
}
</pre></td></tr></table></figure>

<h3 id="load与onload的实现">load与onload的实现</h3>
<p>fetch完成后会调用load方法。</p>
<p>我们看下load的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
</pre></td><td class="code"><pre>Module.prototype.load = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> mod = <span class="keyword">this</span>
  <span class="comment">// If the module is being loaded, just wait it onload call</span>
  <span class="keyword">if</span> (mod.status &gt;= STATUS.LOADING) {
    <span class="keyword">return</span>
  }
  mod.status = STATUS.LOADING

  <span class="comment">//拿到解析后的依赖模块的列表</span>
  <span class="keyword">var</span> uris = mod.resolve()

  <span class="comment">//复制_remain</span>
  <span class="keyword">var</span> len = mod._remain = uris.length
  <span class="keyword">var</span> m

  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) {
    <span class="comment">//拿到依赖的模块对应的实例</span>
    m = Module.get(uris[i])

    <span class="keyword">if</span> (m.status &lt; STATUS.LOADED) {
      <span class="comment">// Maybe duplicate: When module has dupliate dependency, it should be it's count, not 1</span>
      <span class="comment">//把我注入到依赖的模块里的_waitings,这边可能依赖多次，也就是在define里面多次调用require加载了同一个模块。所以要递增</span>
      m._waitings[mod.uri] = (m._waitings[mod.uri] || <span class="number">0</span>) + <span class="number">1</span>
    }
    <span class="keyword">else</span> {
      mod._remain--
    }
  }
  <span class="comment">//如果一开始就发现自己没有依赖模块，或者依赖的模块早就加载好了，就直接调用自己的onload</span>
  <span class="keyword">if</span> (mod._remain === <span class="number">0</span>) {
    mod.onload()
    <span class="keyword">return</span>
  }
  <span class="comment">//检查依赖的模块，如果有还没加载的就调用他们的fetch让他们开始加载</span>
  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) {
    m = cachedMods[uris[i]]

    <span class="keyword">if</span> (m.status &lt; STATUS.FETCHING) {
      m.fetch()
    }
    <span class="keyword">else</span> <span class="keyword">if</span> (m.status === STATUS.SAVED) {
      m.load()
    }
  }
}

Module.prototype.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> mod = <span class="keyword">this</span>
  mod.status = STATUS.LOADED
  <span class="comment">//回调，预留接口给之后主函数use使用，这边先不管</span>
  <span class="keyword">if</span> (mod.callback) {
    mod.callback()
  }

  <span class="keyword">var</span> waitings = mod._waitings
  <span class="keyword">var</span> uri, m
  <span class="comment">//遍历依赖自己的那些模块实例，挨个的检查_remain，如果更新后为0，就帮忙调用对应的onload</span>
  <span class="keyword">for</span> (uri <span class="keyword">in</span> waitings) {
    <span class="keyword">if</span> (waitings.hasOwnProperty(uri)) {
      m = cachedMods[uri]
      m._remain -= waitings[uri]
      <span class="keyword">if</span> (m._remain === <span class="number">0</span>) {
        m.onload()
      }
    }
  }

}
</pre></td></tr></table></figure>

<p>这样整个通知机制就结束了。</p>
<h3 id="exec的实现">exec的实现</h3>
<p>模块onload之后代表已经处于一种可执行状态。seajs不会立即执行模块代码，只有你真正require了才会去调用模块的exec去执行。这就是用时定义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="code"><pre>Module.prototype.exec = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> mod = <span class="keyword">this</span>

  <span class="keyword">if</span> (mod.status &gt;= STATUS.EXECUTING) {
    <span class="keyword">return</span> mod.exports
  }

  mod.status = STATUS.EXECUTING

  <span class="keyword">var</span> uri = mod.uri

  <span class="comment">//这是会传递给factory的参数，factory执行的时候，所有的模块已经都加在好处于可用的状态了，但是还没有执行对应的factory。这就是cmd里面说的用时定义，只有第一次require的时候才会去获取并执行</span>
  <span class="function"><span class="keyword">function</span> <span class="title">require</span><span class="params">(id)</span> {</span>
    <span class="keyword">return</span> Module.get(id2Url(id)).exec()
  }

  <span class="function"><span class="keyword">function</span> <span class="title">isFunction</span> <span class="params">(obj)</span> {</span>
    <span class="keyword">return</span> ({}).toString.call(obj) == <span class="string">"[object Function]"</span>
  }

  <span class="comment">// Exec factory</span>
  <span class="keyword">var</span> factory = mod.factory
  <span class="comment">//如果factory是函数，直接执行获取到返回值。否则赋值，主要是为了兼容define({数据})这种写法，可以用来发jsonp请求等等。</span>
  <span class="keyword">var</span> exports = isFunction(factory) ?
      factory(<span class="built_in">require</span>, mod.exports = {}, mod) :
      factory
  <span class="comment">//没有返回值，就使用mod.exports的值。看到这边你受否明白了，为什么我们要返回一个函数的时候，直接exports = function(){}不行了呢？因为这边取的是mod.exports。exports只是传递过去的指向{}的一个引用。你改变了这个引用地址，却没有改变mod.exports。所以当然是不行的。</span>
  <span class="keyword">if</span> (exports === <span class="literal">undefined</span>) {
    exports = mod.exports
  }

  mod.exports = exports
  mod.status = STATUS.EXECUTED

  <span class="keyword">return</span> exports

}
</pre></td></tr></table></figure>

<h3 id="入口函数seajs-use">入口函数seajs.use</h3>
<p>上面这套东西已经完成了整个模块之间的加载执行依赖关系了。但是还缺少一个入口。</p>
<p>这时候就是seajs.use出场的时候了。seajs.use用来加载一些模块。比如下面：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>seajs.use([<span class="string">"main"</span>])
</pre></td></tr></table></figure>

<p>其实我们可以把它当作一个主模块，use的后面那些比如main就是它的依赖模块。而且这个主模块比较特殊，他不需要经过加载的过程，直接可以从load装载开始，于是use的实现就很简单了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre>seajs = {}
seajs.use = <span class="function"><span class="keyword">function</span> <span class="params">(ids, callback)</span> {</span>
  <span class="comment">//生成一个带依赖的模块</span>
  <span class="keyword">var</span> mod = Module.get(<span class="string">'_use_special_id'</span>, ids)
  <span class="comment">//还记得上面我们在onload里面预留的接口嘛。这边派上用场了。</span>
  mod.callback = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> exports = []
    <span class="comment">//拿到依赖的模块地址数组</span>
    <span class="keyword">var</span> uris = mod.resolve()

    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = uris.length; i &lt; len; i++) {
      <span class="comment">//执行依赖的那些模块</span>
      exports[i] = cachedMods[uris[i]].exec()
    }
    <span class="comment">//注入到回调函数中</span>
    <span class="keyword">if</span> (callback) {
      callback.apply(global, exports)
    }
  }
  <span class="comment">//直接使用load去装载。</span>
  mod.load()
}
</pre></td></tr></table></figure>

<p>于是整个流程就变成了这样：</p>
<p>主入口函数use直接生成一个模块，直接load。然后建立好依赖关系。通过上面那套通知机制，从下到上一个个的触发模块的onload。然后主函数里面调用依赖模块的exec去执行，然后一层层的下去，每一层都可以通过require来执行对应的factory。整个过程就是这样。</p>
<h2 id="结语">结语</h2>
<p>又是一个因为js本身的缺陷，然后后人擦屁股的事情。这样的例子已经数不胜数了。js真是让人又爱又恨。总之有了模块加载器，让js有了做大规模富客户端应用的能力。是前端工业化开发不可缺少的一环。</p>
]]></content:encoded>
      <comments>http://purplebamboo.github.com/2015/01/17/javascript-module/#disqus_comments</comments>
    </item>
    
    <item>
      <title><![CDATA[koa源码分析系列（四）co-4.0新变化]]></title>
      <link>http://purplebamboo.github.com/2015/01/16/koa-source-analytics-4/</link>
      <guid>http://purplebamboo.github.com/2015/01/16/koa-source-analytics-4/</guid>
      <pubDate>Fri, 16 Jan 2015 10:39:27 GMT</pubDate>
      <description>
      <![CDATA[<p>koa是TJ大神新一代的中间件框架，本系列旨在一步一步实现koa的功能，包括下面这些。</p>
<ol>
<li><a href="/2014/05/24/koa-source-analytics-1/">koa源码分析系列（一）generator</a></li>
<li]]>
      </description>
      <content:encoded><![CDATA[<p>koa是TJ大神新一代的中间件框架，本系列旨在一步一步实现koa的功能，包括下面这些。</p>
<ol>
<li><a href="/2014/05/24/koa-source-analytics-1/">koa源码分析系列（一）generator</a></li>
<li><a href="/2014/05/24/koa-source-analytics-2/">koa源码分析系列（二）co的实现</a></li>
<li><a href="/2014/05/24/koa-source-analytics-3/">koa源码分析系列（三）koa的中间件机制实现</a></li>
<li><a href="/2015/01/16/koa-source-analytics-4/">koa源码分析系列（四）co-4.0新变化</a></li>
</ol>
<p>koa基于co实现，co又是使用了es6的generator特性，所以，没错这个特性支持很一般。<br>有下面几种办法体验generator：</p>
<ul>
<li>node v0.11 可以使用 (node —harmony)</li>
<li>使用gnode来使用，不过据说性能一般</li>
<li>使用chrome体验，打开chrome://flags/, 搜索harmony, 启用,重启chrome即可。</li>
</ul>
<h2 id="核心代码分析">核心代码分析</h2>
<p>之前写过一篇co的源码分析文章，但是不久之后co就发生了重大变化，就是完全抛弃了thunk风格的函数。全部转用promise。于是，找了个时间我再次看了下源码。简单记录下。</p>
<p>本文假设你已经熟悉了es6里面promise的基本用法。如果不是特别清楚的可以参考下面几篇文章：</p>
<ol>
<li><a href="http://purplebamboo.github.io/2015/01/16/promise/" target="_blank">http://purplebamboo.github.io/2015/01/16/promise/</a></li>
<li><a href="http://www.w3ctech.com/topic/721" target="_blank">http://www.w3ctech.com/topic/721</a></li>
<li><a href="http://www.cnblogs.com/fsjohnhuang/p/4135149.html" target="_blank">http://www.cnblogs.com/fsjohnhuang/p/4135149.html</a></li>
<li><a href="http://wohugb.gitbooks.io/ecmascript-6/content/docs/promise.html" target="_blank">http://wohugb.gitbooks.io/ecmascript-6/content/docs/promise.html</a></li>
</ol>
<p>co4.0全部采用promise来实现。下面我们分析下代码。</p>
<p>首先co的用法发生了改变：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>co(<span class="function"><span class="keyword">function</span>* <span class="params">()</span> {</span>
  <span class="keyword">var</span> result = <span class="keyword">yield</span> Promise.resolve(<span class="literal">true</span>);
  <span class="keyword">return</span> result;
}).then(<span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span>
  console.log(value);
}, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
  console.error(err.stack);
});
</pre></td></tr></table></figure>

<p>可以看到co还是接受了一个generatorFunction作为参数，实际上参数如果是一个generator对象也是可以的。如果是generatorFunction，co内部会帮你执行生成对应的generator对象。</p>
<p>不同的是co不再返回一个thunk函数，而是返回了一个promise对象。</p>
<p>yield后面推荐的也是promise对象，而不是thunk函数了。</p>
<p>我们看下实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">co</span><span class="params">(gen)</span> {</span>
  <span class="keyword">var</span> ctx = <span class="keyword">this</span>;

  <span class="comment">//如果是generatorFunction,就执行 获得对应的generator对象</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">'function'</span>) gen = gen.call(<span class="keyword">this</span>);

  <span class="comment">//返回一个promise</span>
  <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span><span class="params">(resolve, reject)</span> {</span>

    <span class="comment">//初始化入口函数，第一次调用</span>
    onFulfilled();

    <span class="comment">//成功状态下的回调</span>
    <span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span><span class="params">(res)</span> {</span>
      <span class="keyword">var</span> ret;
      <span class="keyword">try</span> {
        <span class="comment">//拿到第一个yield返回的对象值ret</span>
        ret = gen.next(res);
      } <span class="keyword">catch</span> (e) {
        <span class="comment">//出错直接调用reject把promise置为失败状态</span>
        <span class="keyword">return</span> reject(e);
      }
      <span class="comment">//开启调用链</span>
      next(ret);
    }

    <span class="function"><span class="keyword">function</span> <span class="title">onRejected</span><span class="params">(err)</span> {</span>
      <span class="keyword">var</span> ret;
      <span class="keyword">try</span> {
        <span class="comment">//抛出错误，这边使用generator对象throw。这个的好处是可以在co的generatorFunction里面使用try捕获到这个异常。</span>
        ret = gen.throw(err);
      } <span class="keyword">catch</span> (e) {
        <span class="keyword">return</span> reject(e);
      }
      next(ret);
    }


    <span class="function"><span class="keyword">function</span> <span class="title">next</span><span class="params">(ret)</span> {</span>
      <span class="comment">//如果执行完成，直接调用resolve把promise置为成功状态</span>
      <span class="keyword">if</span> (ret.done) <span class="keyword">return</span> resolve(ret.value);
      <span class="comment">//把yield的值转换成promise</span>
      <span class="comment">//支持 promise，generator，generatorFunction，array，object</span>
      <span class="comment">//toPromise的实现可以先不管，只要知道是转换成promise就行了</span>
      <span class="keyword">var</span> value = toPromise.call(ctx, ret.value);

      <span class="comment">//成功转换就可以直接给新的promise添加onFulfilled, onRejected。当新的promise状态变成结束态（成功或失败）。就会调用对应的回调。整个next链路就执行下去了。</span>
      <span class="keyword">if</span> (value && isPromise(value)) <span class="keyword">return</span> value.then(onFulfilled, onRejected);

      <span class="comment">//否则说明有错误，调用onRejected给出错误提示</span>
      <span class="keyword">return</span> onRejected(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'You may only yield a function, promise, generator, array, or object, '</span>
        + <span class="string">'but the following object was passed: "'</span> + <span class="built_in">String</span>(ret.value) + <span class="string">'"'</span>));
    }
  });
}

<span class="function"><span class="keyword">function</span> <span class="title">isPromise</span><span class="params">(obj)</span> {</span>
  <span class="keyword">return</span> <span class="string">'function'</span> == <span class="keyword">typeof</span> obj.then;
}
</pre></td></tr></table></figure>

<p>核心代码主要是onFulfilled与next的实现。</p>
<p>我们先不考虑错误处理看下执行流程。也先不看toPromise的实现。假定我们只是yield一个promise对象。</p>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>
co(<span class="function"><span class="keyword">function</span>* <span class="params">()</span> {</span>
  <span class="keyword">var</span> a = <span class="keyword">yield</span> Promise.resolve(<span class="string">'传给a的值'</span>);
  <span class="keyword">var</span> b = <span class="keyword">yield</span> Promise.resolve(<span class="string">'传给b的值'</span>);
  <span class="keyword">return</span> b;
}).then(<span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span>
  console.log(value);
}, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
  console.error(err.stack);
});
</pre></td></tr></table></figure>

<p>假设：</p>
<ul>
<li><code>Promise.resolve(&#39;传给a的值&#39;);</code>生成的叫做promise对象A。</li>
<li><code>Promise.resolve(&#39;传给b的值&#39;);</code>生成的叫做promise对象B。</li>
</ul>
<p>onFulfilled作为入口函数。</p>
<ol>
<li>调用gen.next(res)。这时候代码会执行到<code>yield Promise.resolve(&#39;传给a的值&#39;);</code>然后停住。拿到了返回值`{value:’promise对象A’,done:false}。</li>
<li>然后调用next（ret）,传递ret对象。next里面调用promise对象A的then添加操作函数。</li>
<li>等promise对象A变成了成功状态，就会再次调用onFulfilled，并且传入resolve的值。</li>
<li>于是再次重复1。代码会执行到<code>yield Promise.resolve(&#39;传给b的值&#39;);</code>停住。不同的是这次调用onFulfilled会传递res的值。通过gen.next(res)会把res也就是resolve的值赋值给a。</li>
</ol>
<p>然后继续这个过程，一直到最后return的时候。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">//co包裹的generatorFunction return后 ret.done为true。这个时候就可以resole `Co生成的promise对象`了。</span>
<span class="keyword">if</span> (ret.done) <span class="keyword">return</span> resolve(ret.value);
</pre></td></tr></table></figure>

<p>这样整个调用链就执行下去了。可以看到主要是使用promise的then方法添加onfullied操作函数，来实现自动调用<code>gen.next()</code>。</p>
<h2 id="co的错误处理">co的错误处理</h2>
<p>co的错误处理主要使用onRejected实现，基本逻辑跟onFulfilled差不多，这边主要说一下<code>gen.throw(err);</code>的原理。<br>generator对象的一个特性是可以在generatorFunction外面抛出异常,在generatorFunction里面捕获到这个异常。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> *<span class="title">test</span><span class="params">()</span>{</span>
    <span class="keyword">try</span>{
        <span class="keyword">yield</span> <span class="string">'a'</span>
        <span class="keyword">yield</span> <span class="string">'b'</span>
    }<span class="keyword">catch</span>(e){
        console.log(<span class="string">'内部捕获：'</span>)
        console.log(e)
    }
}

<span class="keyword">var</span> g = test()
g.next()

g.throw(<span class="string">'外面报错消息'</span>)

<span class="comment">/*结果
*内部捕获：
*外面报错消息
*
*/</span>
</pre></td></tr></table></figure>

<p>当我们运行gen.next()的时候，会运行到yield ‘a’这一句。这一句正好在内部的try范围内，因此<code>g.throw(&#39;外面报错消息&#39;)</code>这个抛出的错误会被捕获到。</p>
<p>如果我们不调用gen.next()或者连续调用三次gen.next()。代码执行不在try的范围，这个时候去gen.throw错误就不会被内部捕获到。</p>
<p>所以co里面用了这个特性，可以让你针对某一个或多个yield加上try，catch代码。<br>co发现某个内部promise报错就会调用onRejected然后调用gen.throw抛出错误。</p>
<p>如果你不处理错误，co就调用reject(err)传递给包装后的co返回的promise对象。这样你就可以在co(*fn).catch 拿到这个错误。</p>
<h2 id="toPromise的实现">toPromise的实现</h2>
<p>我们看下toPromise的代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">toPromise</span><span class="params">(obj)</span> {</span>

  <span class="keyword">if</span> (!obj) <span class="keyword">return</span> obj;
  <span class="comment">//是promise就直接返回</span>
  <span class="keyword">if</span> (isPromise(obj)) <span class="keyword">return</span> obj;
  <span class="comment">//如果是generator对象或者generatorFunction就直接用co包一层，最后会返回一个包装好的promise。</span>
  <span class="keyword">if</span> (isGeneratorFunction(obj) || isGenerator(obj)) <span class="keyword">return</span> co.call(<span class="keyword">this</span>, obj);
  <span class="comment">//如果是thunk函数就调用thunkToPromise转换</span>
  <span class="keyword">if</span> (<span class="string">'function'</span> == <span class="keyword">typeof</span> obj) <span class="keyword">return</span> thunkToPromise.call(<span class="keyword">this</span>, obj);
  <span class="comment">//是数组就使用arrayToPromise转换</span>
  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(obj)) <span class="keyword">return</span> arrayToPromise.call(<span class="keyword">this</span>, obj);
  <span class="comment">//是对象就使用objectToPromise转换</span>
  <span class="keyword">if</span> (isObject(obj)) <span class="keyword">return</span> objectToPromise.call(<span class="keyword">this</span>, obj);
  <span class="keyword">return</span> obj;
}
</pre></td></tr></table></figure>

<p>主要就是各种判断，把不同类型的yield值转换成一个promise对象。<br>前面几个都很简单不说了。</p>
<p>thunkToPromise比较简单如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">thunkToPromise</span><span class="params">(fn)</span> {</span>
  <span class="keyword">var</span> ctx = <span class="keyword">this</span>;
  <span class="comment">//主要就是新new一个promise对象，在thunk的回调里resolve这个promise对象</span>
  <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span> <span class="params">(resolve, reject)</span> {</span>
    fn.call(ctx, <span class="function"><span class="keyword">function</span> <span class="params">(err, res)</span> {</span>
      <span class="comment">//错误就调用reject抛出错误</span>
      <span class="keyword">if</span> (err) <span class="keyword">return</span> reject(err);
      <span class="comment">//对多个参数的支持</span>
      <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">2</span>) res = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);
      resolve(res);
    });
  });
}
</pre></td></tr></table></figure>

<p>arrayToPromise也比较容易：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">arrayToPromise</span><span class="params">(obj)</span> {</span>
  <span class="comment">//直接调用Promise的静态方法包装一个新的promise对象。然后对于每个value调用toPromise进行递归的包装</span>
  <span class="keyword">return</span> Promise.all(obj.map(toPromise, <span class="keyword">this</span>));
}
</pre></td></tr></table></figure>

<p>objectToPromise会稍微绕一点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">objectToPromise</span><span class="params">(obj)</span>{</span>
  <span class="comment">//小技巧，生成一个跟obj一样类型的克隆空对象</span>
  <span class="keyword">var</span> results = <span class="keyword">new</span> obj.constructor();
  <span class="comment">//拿到 对象的所有key，返回key的集合数组</span>
  <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(obj);
  <span class="keyword">var</span> promises = [];

  <span class="comment">//遍历所有值</span>
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.length; i++) {
    <span class="keyword">var</span> key = keys[i];

    <span class="comment">//递归调用</span>
    <span class="keyword">var</span> promise = toPromise.call(<span class="keyword">this</span>, obj[key]);
    <span class="comment">//如果转换后是promise对象，就异步的去赋值</span>
    <span class="keyword">if</span> (promise && isPromise(promise)) defer(promise, key);
    <span class="comment">//如果不能转换，说明是纯粹的值。就直接赋值</span>
    <span class="keyword">else</span> results[key] = obj[key];
  }

  <span class="comment">//监听所有队列里面的promise对象，等所有的promise对象成功了，代表都赋值完成了。就可以调用then，返回结果results了。</span>
  <span class="keyword">return</span> Promise.all(promises).then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">return</span> results;
  });

  <span class="function"><span class="keyword">function</span> <span class="title">defer</span><span class="params">(promise, key)</span> {</span>
    <span class="comment">//先占位</span>
    results[key] = <span class="literal">undefined</span>;
    <span class="comment">//把当前promise加入待监听promise数组队列</span>
    promises.push(promise.then(<span class="function"><span class="keyword">function</span> <span class="params">(res)</span> {</span>
      <span class="comment">//等当前promise变成成功态的时候赋值</span>
      results[key] = res;
    }));
  }
}
</pre></td></tr></table></figure>

<p>objectToPromise的主要思路是循环递归遍历对象的值</p>
<ul>
<li>如果发现是纯粹的值，就直接赋值给结果对象。</li>
<li>如果发现是可以转化为promise的就调用defer异步的把值添加到results里面，同时把promise对象放到监听的数组里。</li>
<li>这样在最外围只要使用Promise.all去监听这些promise对象。等他们都执行完了代表results已经被正确的赋值。于是再通过then，改变要反回的promise对象的要resolve的值。</li>
</ul>
<h2 id="结语">结语</h2>
<p>整个分析到这就结束了，新版的co代码非常清晰也更加容易理解。不过完全抛弃thunk不知道TJ大神怎么想的。好像目前的koa还是使用的老的co来实现的。不管怎么说，还是值得看一看的。</p>
]]></content:encoded>
      <comments>http://purplebamboo.github.com/2015/01/16/koa-source-analytics-4/#disqus_comments</comments>
    </item>
    
  </channel>
</rss>