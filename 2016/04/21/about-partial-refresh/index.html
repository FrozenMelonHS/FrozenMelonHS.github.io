
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>局部刷新模板那些事 | blog of purplebamboo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="purplebamboo">
    
    <meta name="description" content="模板是每个前端工作者都会接触到的东西，近几年前端的工程化，发展的如火如荼。从基本的字符串拼接到字符串模板，再到现在各种框架给出的“伪模板”解决方案，前端模板经历了种种变革。
下面就不同时期的模板做一下回顾。

本文假定读者已经对underscore, mustache，angularjs，react">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="blog of purplebamboo" title="blog of purplebamboo"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="blog of purplebamboo">blog of purplebamboo</a></h1>
				<h2 class="blog-motto">dota诚可贵，coding价更高，若为女朋友，二者皆可抛。</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/categories">分类</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:purplebamboo.github.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/04/21/about-partial-refresh/" title="局部刷新模板那些事" itemprop="url">局部刷新模板那些事</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://purplebamboo.github.com" title="purplebamboo">purplebamboo</a>
    </p>
  <p class="article-time">
    <time datetime="2016-04-21T08:26:17.000Z" itemprop="datePublished">4月 21 2016</time>
    更新日期:<time datetime="2016-04-21T08:41:45.000Z" itemprop="dateModified">4月 21 2016</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#原始的模板"><span class="toc-number">1.</span> <span class="toc-text">原始的模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串模板的兴起"><span class="toc-number">2.</span> <span class="toc-text">字符串模板的兴起</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串模板的局部刷新"><span class="toc-number">3.</span> <span class="toc-text">字符串模板的局部刷新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#新时代的“模板”"><span class="toc-number">4.</span> <span class="toc-text">新时代的“模板”</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#angularjs"><span class="toc-number">4.1.</span> <span class="toc-text">angularjs</span></a></li><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原理"><span class="toc-number">4.1.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分析"><span class="toc-number">4.1.2.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优点"><span class="toc-number">4.1.3.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缺点"><span class="toc-number">4.1.4.</span> <span class="toc-text">缺点</span></a></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#vuejs"><span class="toc-number">4.2.</span> <span class="toc-text">vuejs</span></a></li><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原理-1"><span class="toc-number">4.2.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分析-1"><span class="toc-number">4.2.2.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#特点"><span class="toc-number">4.2.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缺点-1"><span class="toc-number">4.2.4.</span> <span class="toc-text">缺点</span></a></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#reactjs"><span class="toc-number">4.3.</span> <span class="toc-text">reactjs</span></a></li><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原理-2"><span class="toc-number">4.3.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分析-2"><span class="toc-number">4.3.2.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#特点-1"><span class="toc-number">4.3.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缺点-2"><span class="toc-number">4.3.4.</span> <span class="toc-text">缺点</span></a></li></ol></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#思考"><span class="toc-number">5.</span> <span class="toc-text">思考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结语"><span class="toc-number">6.</span> <span class="toc-text">结语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#相关引用"><span class="toc-number">7.</span> <span class="toc-text">相关引用</span></a></li></ol>
		</div>
		
		<p>模板是每个前端工作者都会接触到的东西，近几年前端的工程化，发展的如火如荼。从基本的字符串拼接到字符串模板，再到现在各种框架给出的“伪模板”解决方案，前端模板经历了种种变革。</p>
<p>下面就不同时期的模板做一下回顾。</p>
<blockquote>
<p>本文假定读者已经对<code>underscore</code>, <code>mustache</code>，<code>angularjs</code>，<code>reactjs</code>等技术有了一定的了解。否则请先看看相关资料了解下。</p>
</blockquote>
<h2 id="原始的模板">原始的模板</h2>
<p>提到模板，不得不提到每个前端都会经历的字符串拼接的阶段。</p>
<p>看下面这段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre>
&lt;ul id=<span class="string">"test"</span>&gt;


<span class="xml"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span>

<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">

<span class="keyword">var</span> students = [{
    name:<span class="string">'张三'</span>,
    age:<span class="string">'19'</span>
},{
    name:<span class="string">'李四'</span>,
    age:<span class="string">'17'</span>
},{
    name:<span class="string">'王五'</span>,
    age:<span class="string">'21'</span>
}]

<span class="keyword">var</span> htmlArray = [],tmplStr

<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;students.length;i++){
    tmplStr = <span class="string">'&lt;li&gt;'</span>
    tmplStr += <span class="string">'姓名：'</span>+ students[i].name +<span class="string">'年龄：'</span> + students[i].age
    tmplStr += <span class="string">'&lt;/li&gt;'</span>
    htmlArray.push(tmplStr)
}

document.getElementById(<span class="string">'test'</span>).innerHTML = htmlArray.join(<span class="string">' '</span>)
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span>
</pre></td></tr></table></figure>

<p>代码逻辑很简单，将一份数据循环拼接好字符串最后组装好html字符串塞到页面上。</p>
<p>可以看到这种写法，模板部分跟逻辑部分很容易耦合在一起，非常的不清晰，可读性也很差。在大规模项目中是不建议这么用的。</p>
<h2 id="字符串模板的兴起">字符串模板的兴起</h2>
<p>因为上面的写法有太多的缺点，所以先辈们开始实现基本的模板引擎。实现展示与逻辑的分离。</p>
<p>比较典型的是underscore类型的模板，它其实很简单，就是把一个基本的模板语法转换成一个可执行的javascript代码。</p>
<p>我们看下上面的功能使用underscore的语法怎么写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre>

&lt;ul id=<span class="string">"test"</span>&gt;


<span class="xml"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span>

<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">

<span class="keyword">var</span> students = [{
    name:<span class="string">'张三'</span>
},{
    name:<span class="string">'李四'</span>
},{
    name:<span class="string">'王五'</span>
}]


<span class="keyword">var</span> tmpl = <span class="string">'&lt;% for(var i=0;i&lt;students.length;i++){ %&gt; 姓名： &lt;% students[i].name %&gt;   &lt;% } %&gt;'</span>

<span class="comment">//假设template可以实现类似underscore的语法</span>
<span class="keyword">var</span> tplCompile = template(tmpl) <span class="comment">//先生成执行函数</span>

document.getElementById(<span class="string">'test'</span>).innerHTML = tplCompile(students)<span class="comment">//执行渲染</span>
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span>
</pre></td></tr></table></figure>

<p>template，作为实现了underscore功能的函数，传入一个模板还有一份数据，就可以把模板渲染出来。</p>
<p>这样写的好处是，实现了模板与字符串逻辑的分离。ui层，也就是渲染逻辑看起来会比较清晰。</p>
<p>下面我们来看看如何实现一个最基本的template：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td><td class="code"><pre>
<span class="function"><span class="keyword">function</span> <span class="title">template</span><span class="params">(tpl)</span>{</span>
    <span class="comment">//用来匹配出我们的特殊语法</span>
    <span class="keyword">var</span> tplReg = <span class="regexp">/&lt;%([^%&gt;]+)?%&gt;/g</span>

    <span class="keyword">var</span> match;
    <span class="keyword">var</span> cursor=<span class="number">0</span>;
    <span class="keyword">var</span> regOut = <span class="regexp">/(^( )?(if|for|else|switch|case|break|{|}))(.*)?/g</span>;

    <span class="comment">//需要拼接的代码，这里注意with的用法，用来使渲染的数据应用在模板里</span>
    <span class="keyword">var</span> code = <span class="string">'var codes=[];\nwith(renderData){\n'</span>;

    <span class="keyword">var</span> addLine = <span class="function"><span class="keyword">function</span><span class="params">(line,js)</span>{</span>
        <span class="comment">//普通文本，这时候加上一个双引号就可以了</span>
        <span class="keyword">if</span>(!js){
            code += <span class="string">'codes.push("'</span> + line.replace(<span class="regexp">/"/g</span>, <span class="string">'\\"'</span>) + <span class="string">'");\n'</span>
            <span class="keyword">return</span>
        }

        <span class="comment">//特殊语法特殊处理</span>
        <span class="comment">//对于有js特殊逻辑比如for,if这种代码，不适用push。直接打出。</span>
        <span class="keyword">if</span>(regOut.test(line)){
            code += line + <span class="string">'\n'</span>;
        }<span class="keyword">else</span>{
            <span class="comment">//普通的特殊语法，跟上面的普通的文本唯一的区别就是少了双引号，这样以后执行时就会是变量。</span>
            code += <span class="string">'codes.push('</span> + line + <span class="string">');\n'</span>
        }

    }
    <span class="comment">//通过正则不停的去匹配特殊语法</span>
    <span class="keyword">while</span>(match = tplReg.exec(tpl)) {
        <span class="comment">//截取前面的普通文本</span>
        addLine(tpl.slice(cursor, match.index)); <span class="comment">//普通文本</span>
        <span class="comment">//将当前的特殊语法加入</span>
        addLine(match[<span class="number">1</span>],<span class="literal">true</span>);  <span class="comment">//特殊逻辑</span>
        cursor = match.index + match[<span class="number">0</span>].length; <span class="comment">//更新游标</span>
    }
    <span class="comment">//末尾可能还剩下些语法</span>
    addLine(tpl.substr(cursor, tpl.length - cursor)); <span class="comment">//剩下的代码</span>

    code += <span class="string">'};return codes.join("")'</span>;
    code = code.replace(<span class="regexp">/[\r\t\n]/g</span>, <span class="string">''</span>)

    <span class="keyword">var</span> compileFn = <span class="function"><span class="keyword">function</span><span class="params">(data)</span>{</span>
        <span class="comment">//使用function执行拼好的代码，将data传到函数里。</span>
        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'renderData'</span>,code)(data);
    }

    <span class="keyword">return</span> compileFn

}
</pre></td></tr></table></figure>

<p>实现很简单，主要就是通过正则替换，拼凑出最终的js执行语句，然后使用function来执行得到结果。</p>
<p>我们通过tplReg这个正则匹配出所有的<code>&lt;% ... %&gt;</code>特殊语法，<code>addLine</code>负责生成javascript可执行语句。</p>
<p><code>addLine</code>添加的语句需要分三种情况：</p>
<ol>
<li>特殊语法之外的普通文本，比如上面的<code>姓名：</code>这种文本。这个时候直接push到codes里面就行，最后会原样输出。这边需要加上双引号代表是个普通字符串。</li>
<li>对于特殊语法里面的普通语法，比如上面的<code>students[i].name</code>，这种时候直接push到codes里面，跟上面不同的是，这时不需要加双引号,这样最后这些codes执行时就会把它作为变量去处理。</li>
<li>还有一种特殊的语法，就是<code>for(var i=0;i&lt;students.length;i++){</code>这种带for的<br>。这个时候不能放到codes里面，因为我们本身需要它的循环功能。</li>
</ol>
<p>最后拼接好codes后，使用function一次执行得到最终渲染好的字符串。</p>
<p>当然我们这边的实现超级简陋，仅供参考原理。实际的模板还需要考虑缓存，兼容性，xss等等。</p>
<p>字符串模板使用很广泛，也踊跃出了若干实现。mustache，Underscore templates，Dust.js等等，前端真的是能折腾。如果有选择困难症，可以看看这里：<a href="http://garann.github.io/template-chooser/" target="_blank">http://garann.github.io/template-chooser/</a></p>
<p>这个阶段的模板或多或少都是相同的原理。</p>
<ul>
<li>解析字符串模板，有的是直接正则分析，有的是用语法树分析。</li>
<li>渲染出结果，直接改造成原生的javascript语句执行拿到结果。</li>
</ul>
<p>这在很长一段时间里对于前端工程师来说已经够用了。通过模板的dsl，很好的实现了前端逻辑与ui的分离。</p>
<h2 id="字符串模板的局部刷新">字符串模板的局部刷新</h2>
<p>但是随着前端的发展，特别是富客户端应用的兴起。单纯的字符串模板已经很难满足需求了。</p>
<p>比如一个学生个人信息界面，分为个人姓名，还有个人成绩两块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre>
&lt;div&gt;个人信息：&lt;/div&gt;
&lt;div id="test"&gt;


&lt;/div&gt;

&lt;script&gt;

var student = {
    name:'张三',
    score:89
}


var tmpl = '&lt;div&gt;姓名: &lt;% name %&gt; &lt;/div&gt;&lt;div&gt;成绩: &lt;% score %&gt; &lt;/div&gt;'

//假设template方法可以实现underscore的语法
document.getElementById('test').innerHTML = template(tmpl)(student)
&lt;/script&gt;
</pre></td></tr></table></figure>

<p>如果我们初次渲染后需要去更新成绩。我们期待的情况肯定是只更新成绩，个人姓名不要重复刷新。这对于普通字符串模板是做不到的。只能自己使用dom操作去修改，而这样就违背了我们的初衷，逻辑又跟展现耦合变的不可控了。</p>
<blockquote>
<p>实际情况会更复杂,页面内容更多，需要局部刷新的地方更多，这里为了方便，只举一个最简单的例子。</p>
</blockquote>
<p>如果不自己使用dom操作，还希望用模板，那么每次要改点东西都需要整个页面全部重新渲染，在通过innerHTML一次性更新。</p>
<ul>
<li>首先这会造成页面的整体刷新，用户体验差</li>
<li>其次，每次innerHTML，浏览器都需要重新渲染dom结构，造成性能浪费</li>
</ul>
<p>我们其实是需要一种局部刷新的东西，在初次渲染后仍然保持模板与dom的联系。通过一些方法，只改变页面中的一小部分html。差异化的去更新。其实是一种innerHTML的优化。</p>
<p>我们团队很久之前就做了这方面的尝试，可以先看下我们是怎么用的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>
&lt;script&gt;

<span class="keyword">var</span> student = {
    name:<span class="string">'张三'</span>,
    score:<span class="number">89</span>
}

<span class="comment">//注意下面的模板里面多了 tpl-name="sc"  tpl-key="score"</span>
<span class="keyword">var</span> tmpl = <span class="string">'&lt;div&gt;姓名: &lt;% name %&gt; &lt;/div&gt;&lt;div tpl-name="sc" tpl-key="score"&gt;成绩: &lt;% score %&gt; &lt;/div&gt;'</span>


<span class="comment">//第一次渲染，会自动绑定到test的div上</span>
<span class="keyword">var</span> node = render(<span class="string">'test'</span>, tmpl, student)

<span class="comment">//如果我们需要更新成绩只需要调用setChunkData来局部刷新页面</span>
node.setChunkData(score,<span class="number">100</span>)

&lt;<span class="regexp">/script&gt;</span>
</pre></td></tr></table></figure>

<p>首先我们会在需要更新的局部dom上打上标签<code>tpl-name=&quot;sc&quot; tpl-key=&quot;score&quot;</code>,代表这里的dom第二次渲染需要依赖score这个变量,并且这个局部模板有了唯一标识sc。然后当我们需要更新成绩的时候只需要调用<code>node.setChunkData(score,100)</code>就可以找到依赖score这个变量对应的dom并且自动使用局部模板去刷新页面了。</p>
<p>可以看到这样带来了不少好处，我们可以继续享受模板带来的便利性，也可以局部刷新页面中的某个区块。而这一切都是建立在数据上的，我们的逻辑处理永远在数据这一层，面向数据编程。而渲染，局部渲染都会自动帮忙完成。</p>
<p>那么达到这样的功能我们需要做什么呢？</p>
<ul>
<li>首先我们需要先解析模板，对于<code>tpl-key</code>这样的标签，我们需要特殊处理，把子模板记录下来，并且记录tpl-name，作为对应。</li>
<li>在调用setChunkData时，我们需要去找到对应的局部模板，还有对应的dom。重新渲染后局部innerHTML。</li>
</ul>
<p>我们看一个最简单的实现（基于上面的template增强而来）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="code"><pre>
<span class="comment">//此函数依赖上面的template函数</span>
<span class="keyword">var</span> render = <span class="function"><span class="keyword">function</span><span class="params">(id, tpl,data)</span>{</span>

    <span class="comment">//初次渲染，直接使用以前的template函数</span>
    document.getElementById(id).innerHTML = template(tpl)(data)


    <span class="comment">//下面都是局部渲染需要的逻辑</span>
    <span class="keyword">var</span> tpls = []<span class="comment">//存放局部刷新的模板</span>
    <span class="comment">//解析模板，找到局部模板 这边的getSubTpls可以先不管，只需要知道返回结果为：</span>
    <span class="comment">//[{name:'sc',key:score,tpl:'&lt;span&gt;成绩:&lt;/span&gt; &lt;% score %&gt; '}]</span>
    tpls = getSubTpls(tpl)


    <span class="comment">//用于根据依赖的key找到对应的那些模板</span>
    <span class="function"><span class="keyword">function</span> <span class="title">getChunkTpl</span><span class="params">(key)</span>{</span>
        <span class="keyword">var</span> results = []

        <span class="keyword">for</span>(<span class="keyword">var</span> i= tpls.length-<span class="number">1</span>;i&gt;-<span class="number">1</span>;i--){
            <span class="keyword">if</span>(tpls[i].key === key){
                results.push(tpls[i])
            }
        }
        <span class="keyword">return</span> results
    }

    <span class="keyword">return</span> {
        setChunkData:<span class="function"><span class="keyword">function</span><span class="params">(key,value)</span>{</span>
            <span class="keyword">var</span> subData = {}
            subData[key] = value


            <span class="keyword">var</span> subNode
            <span class="keyword">var</span> subTpls = getChunkTpl(key) <span class="comment">//匹配到对应的局部模板,可能有多个</span>

            <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;subTpls.length;i++){
                <span class="comment">//这里为了图方便直接用querySelector了</span>
                subNode = document.querySelector(<span class="string">'[tpl-name="'</span> + subTpls[i].name + <span class="string">'"]'</span>)
                <span class="comment">//渲染好，刷新局部dom</span>
                subNode.innerHTML = template(subTpls[i].tpl)(subData)

            }

        }
    }

}
</pre></td></tr></table></figure>

<p>基本实现了我们需要的功能，逻辑上也不复杂，提前准备好局部模板，在setChunkData时通过key找出对应的局部模板还有dom节点，这样就可以达到局部刷新的目的。</p>
<p>下面看下getSubTpls的实现，这个如果不感兴趣可以直接跳过，毕竟已经是过时的技术了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td><td class="code"><pre>
<span class="comment">//这个方法是用来获取一个tag下面的字符串</span>
<span class="comment">//getTagInnerHtml('&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;div id='1'&gt;&lt;/div&gt;&lt;/div&gt;',div,0,0)</span>
<span class="comment">//可以匹配出&lt;span&gt;&lt;/span&gt;&lt;div id='1'&gt;&lt;/div&gt;</span>
<span class="function"><span class="keyword">function</span> <span class="title">getTagInnerHtml</span><span class="params">(tpl, tag, s_pos, offset)</span> {</span>
    <span class="keyword">var</span> s_tag = <span class="string">'&lt;'</span> + tag
    <span class="keyword">var</span> e_tag = <span class="string">'&lt;/'</span> + tag + <span class="string">'&gt;'</span>

    <span class="keyword">var</span> s_or_pos = s_pos + offset

    <span class="keyword">var</span> e_pos = s_pos
    <span class="keyword">var</span> e_next_pos = s_pos

    s_pos = tpl.indexOf(s_tag, s_pos)
    <span class="keyword">var</span> s_next_pos = s_pos + <span class="number">1</span>

    <span class="keyword">while</span> (<span class="literal">true</span>) {
        s_pos = tpl.indexOf(s_tag, s_next_pos);
        e_pos = tpl.indexOf(e_tag, e_next_pos);

        <span class="keyword">if</span> (s_pos == -<span class="number">1</span> || s_pos &gt; e_pos) {
            <span class="keyword">break</span>
        }
        s_next_pos = s_pos + <span class="number">1</span>
        e_next_pos = e_pos + <span class="number">1</span>
    }
    <span class="keyword">return</span> {
        html: tpl.substring(s_or_pos, e_pos)
    }
}


<span class="function"><span class="keyword">function</span> <span class="title">getSubTpls</span><span class="params">(tpl)</span>{</span>
    <span class="comment">//用来匹配带有标签的tag的正则</span>
    <span class="keyword">var</span> tplTagReg = <span class="regexp">/&lt;([\w]+)\s+[^&gt;]*?tpl-name=["\']([^"\']+)["\']\s+[^&gt;]*?tpl-key=["\']([^"\']+)["\']\s*[^&gt;]*?&gt;/g</span>

    <span class="keyword">var</span> match,tagInfo
    <span class="keyword">var</span> tpls = []

    <span class="keyword">while</span>(match = tplTagReg.exec(tpl)) {

        tagInfo = getTagInnerHtml(tpl,match[<span class="number">1</span>],match.index,match[<span class="number">0</span>].length)

        tpls.push({
            name:match[<span class="number">2</span>],
            key:match[<span class="number">3</span>],
            tpl: tagInfo.html
        })
    }
    <span class="keyword">return</span> tpls
}
</pre></td></tr></table></figure>

<p>关键是getTagInnerHtml的实现，由于javascript没有平衡组的概念，所以不得不写这么一长串的处理逻辑，具体参考</p>
<p><a href="http://lf-6666.blog.163.com/blog/static/3123705200942155416430/" target="_blank">http://lf-6666.blog.163.com/blog/static/3123705200942155416430/</a></p>
<p><a href="http://thx.github.io/brix-core/articles/tpl-3/" target="_blank">http://thx.github.io/brix-core/articles/tpl-3/</a></p>
<p>至此基本功能就完成了。在一段时间里也够用了。</p>
<blockquote>
<p>实际的代码，需要处理的问题更多，需要处理好父子级局部模板，多个数据并列依赖等等问题，由于已经是过时的技术了，这里就不详细展开了，有兴趣的可以到<a href="https://github.com/etaoux/brix/blob/master/dist/2.0/brix.js" target="_blank">这里</a>了解。</p>
</blockquote>
<p>但是其实还是有些显而易见的问题：</p>
<ul>
<li>局部刷新需要自己去指定标签，也很难处理父子包含，同级数据并列等问题</li>
<li>使用<code>setChunkData</code>私有方法，需要到模板找到对应的依赖数据，需要自己去把握逻辑</li>
<li>局部刷新其实只是局部的innerHTML,有的时候没法力度太细。跟真正的dom操作比起来，消耗、闪烁都是要大的。</li>
</ul>
<p>这个时候我们渐渐发现字符串模板已经走到头了。面对日新月异的前端开发，尤其是单页应用，普通的字符串模板已经不能满足需求了。</p>
<h2 id="新时代的“模板”">新时代的“模板”</h2>
<p>因为字符串模板的种种缺陷，在新的大时代背景下，尤其是前端各种框架的井喷时代。各种各样的框架实现了很多很有意思的东西，跳出了传统字符串模板的概念，但是的确实现了模板的功能。这个时候已经不适合称之为模板了。</p>
<p>我们先想想，我们上面探索局部刷新时遇到了什么问题。</p>
<p>首先我们需要保持跟模板的联系，这样我们下次需要局部刷新时才能找到对应的节点。比如我们上面是通过在dom节点上打标来实现的。</p>
<p>其次我们需要监听数据的变化，我们上面是直接使用私有方法<code>setChunkData</code>来通知引擎数据变化了，可以开始更新了。这样其实很不好，需要我们关注太多的东西。</p>
<p>另外如果我们多次调用setChunkData，那么就会渲染多次，除了最后一次前面的渲染都是没有必要的，所以我们还需要个批量更新的东西，前面的那些改动不需要真实的反应到dom上。</p>
<p>事实上，目前的主流框架虽然已经脱离了模板的范畴，但是也是紧紧围绕这几个方面来实现的。</p>
<p>当然目前还兴起了双向绑定的热潮，不过在传统的字符串模板里是难以实现的。</p>
<p>下面我们大概介绍下主流的几个框架的是如何实现<code>模板</code>功能的，具体分为下面这几点：</p>
<ul>
<li>如何监听数据的变化</li>
<li>如何渲染更新页面定位节点位置<ul>
<li>初次渲染的逻辑</li>
<li>后来的更新机制</li>
</ul>
</li>
<li>如何实现双向绑定</li>
<li>如何实现批量更新</li>
</ul>
<h3 id="angularjs">angularjs</h3>
<p>angularjs带来了很多前端界的新概念，指令，脏检测，filter等等等。</p>
<h4 id="原理">原理</h4>
<p>我们看下angularjs的大致图形</p>
<p>几个概念：</p>
<ul>
<li>watcher 用来监听一个表达式的变更，然后有一个回调。</li>
<li>directive  具有link方法，存放所有的指令逻辑。一般会使用watcher的功能。</li>
<li>scope   作用域，angular的所有方法，数据都会在这个上面。</li>
<li>digest  用来执行脏检测，开始递归检查scope上的所有watcher发现当前的值跟以前的不一样时就做出dom改变。</li>
</ul>
<p>三个大模块：</p>
<p><img src="http://blog.mgechev.com/images/lightweight-ng/main-components.png" alt="dd"></p>
<p>Provider:</p>
<ul>
<li>注册组件（directives, services 和 controllers）</li>
<li>解决各个组件之间的依赖关系</li>
<li>初始化所有组件</li>
</ul>
<p>DOMCompiler:</p>
<ul>
<li>遍历dom树的所有节点</li>
<li>找到注册的属性类型的directives指令</li>
<li>调用对应的directive对应的link逻辑</li>
<li>管理scope</li>
</ul>
<p>Scope：</p>
<ul>
<li>监控表达式</li>
<li>在每次$digest循环的时候执行所有的表达式，直到稳定，稳定就是说，表达式的值不再改变的时候</li>
<li>在表达式的值发生改变时，调用对应的所有的回调函数</li>
</ul>
<p>怎么串起来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>&lt;span ng-bind=<span class="string">"a + 'hello'"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="title">span</span>&gt;</span></span>
</pre></td></tr></table></figure>

<p>我们看看<code>ng-bind</code>这个指令的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>Provider.directive(<span class="string">'ng-bind'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> {
    link: <span class="function"><span class="keyword">function</span> <span class="params">(el, scope, exp)</span> {</span>
      <span class="comment">//初次渲染的逻辑</span>
      el.innerHTML = scope.$<span class="built_in">eval</span>(exp);
      <span class="comment">//添加一个观察者，当在下一次脏检测发现数据改变时就执行回调逻辑</span>
      scope.$watch(exp, <span class="function"><span class="keyword">function</span> <span class="params">(val)</span> {</span>
        el.innerHTML = val;
      });
    }
  };
});
</pre></td></tr></table></figure>

<p>初始化时：DOMCompiler遍历dom节点，找到指令定义，执行link,写dom。并且通过scope的方法增加watcher观察者。</p>
<p>更新时：调用scope的digest，这个时候会遍历所有watchers，拿新的值跟旧的值做对比，如果不同就执行回调。</p>
<p>所以对于我们这边的简单例子来说，第一次初始化时，通过link函数我们第一次使用innerHTML来渲染dom。同时添加了一个watcher,这样在框架下次脏检测时，检测到数据变化就会调用回调里的逻辑，这里就是重新innerHTML。</p>
<p>具体可以看看<a href="http://purplebamboo.github.io/2015/05/27/use-200-line-code-to-implementation-a-simple-angular/" target="_blank">这篇文章</a>了解下它内部的渲染逻辑。</p>
<blockquote>
<p>当然这里只是给出了最简单的实现，其实这类模板的难点在于for,if这种指令的实现。这里受限于篇幅就不详细展开了。</p>
</blockquote>
<h4 id="分析">分析</h4>
<p>所以，angular的局部刷新，就是通过指令的私有逻辑来实现的。提出了一些比较好玩的概念。<br>我们再对比下之前说的那几个点：</p>
<ul>
<li><p>如何监听数据的变化：通过脏检测，用户在代码中调用<code>scope.$digest()</code>方法,在angularjs里面框架会在某些时候帮你调用。脏检测会负责遍历scope上面的所有观察者watcher。对比表达式的上一次值与现在的值，如果发现数据变化就会调用添加的回调逻辑。</p>
</li>
<li><p>如何渲染更新页面定位节点位置：通过指令，本身已经有了dom引用，一些特殊情况，会使用注释节点做占位符。</p>
</li>
<li><p>如何实现双向绑定：实现model指令，监听数据改变后先修改data数据，之后调用digest来一次脏检测更新就行了。</p>
</li>
<li><p>如何实现批量更新：脏检测本身就是批量的，因为是一次性调用digest才开始统一检查数据变化。</p>
</li>
</ul>
<h4 id="优点">优点</h4>
<ul>
<li>angular大而全，功能特别强大。集成了很多概念，社区也比较强大。</li>
<li>开发体验比较好。模板里的expression使用了自己的编译器去解析，所以支持很强大的语法。</li>
<li>提出了很多很好的概念，如filter，watcher。</li>
</ul>
<h4 id="缺点">缺点</h4>
<ul>
<li>很多功能不需要，难以单独拿出来跟业务结合</li>
<li>脏检测导致的性能问题，特别是大列表的局部刷新情况，watcher太多，导致性能巨差</li>
<li>直接解析现有dom带来不少问题，闪烁，属性错误等等</li>
<li>页面有多个实例时会经常出现脏检测的冲突</li>
<li>指令的写法，相对于传统的字符串模板，可读性差</li>
</ul>
<h3 id="vuejs">vuejs</h3>
<p>vue在学习angular的基础上，做了些精简还有优化。vue只负责处理view，其实是模板+组件方案+动画。我们这里主要看他的模板方面的原理</p>
<h4 id="原理-1">原理</h4>
<p>原理其实类似，也是有指令还有watcher的概念，只是去掉了scope，去掉了脏检测而是使用get set来做数据的变化监听。</p>
<p><img src="http://cn.vuejs.org/images/data.png" alt="222"></p>
<p>首先你需要先了解下<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank">defineProperty</a>,这个特性，可以达到在你对一个属性读或者写的时候写上自己的钩子函数。</p>
<p>整个原理是这样：</p>
<ul>
<li>先给数据注入get，set。递归注入，这样可以注入自己的钩子逻辑。</li>
<li>第一次compile的时候，找到页面上的指令，并且初始化指令，同时new一个watcher，第一次获取值。获取值的时候，触发get的钩子。这样就把key跟对应的watcher绑定起来。</li>
<li>watcher的回调不像angular那样自己写自己的私有逻辑，而是默认都是调用指令的update方法。</li>
<li>所以指令也是不同的，vue的指令有bind，update，destroy三个方法，分别负责初始化，更新，销毁需要做的事情。</li>
<li>当用户修改了值，会触发set，这样会通知对应绑定的watcher进行两次数据的校验，不同就触发回调，也就是对应指令的update方法。</li>
</ul>
<p>可以看到跟angular不同的地方主要在于，指令职责更细，另外有暴力的全部watcher检测，变成了通过set的钩子来指向性的找到对应的watcher做数据变更检测。所以在更新性能上会明显优于脏检测。</p>
<p>具体原理可以参考：<a href="http://cn.vuejs.org/guide/reactivity.html" target="_blank">http://cn.vuejs.org/guide/reactivity.html</a><br>还有：<a href="http://jiongks.name/blog/vue-code-review/" target="_blank">http://jiongks.name/blog/vue-code-review/</a></p>
<h4 id="分析-1">分析</h4>
<ul>
<li>如何监听数据的变化：通过defineproperties注入钩子，修改了数据就会出发钩子，然后通知对应的watcher进行检测</li>
<li>如何渲染更新页面定位节点位置： 也是通过指令，本身已经有了dom引用。而且vue很创新的使用了空白节点来占位。</li>
<li>如何实现双向绑定： 实现model指令，也是有私有逻辑，监听dom改变后，修改对应的data，钩子会自动触发完成更新。</li>
<li>如何实现批量更新：vue使用settimeOut,延迟watcher的check。通过去重watcher。达到批量更新的目的。当你多次调用赋值时不会立即去check数据的变更，而是在一次setTimeout后，开始检测队列。</li>
</ul>
<h4 id="特点">特点</h4>
<ul>
<li>相对angular来说，职责更清晰，去掉了很多不必要的东西，更加轻量</li>
<li>使用defineproperties解决了脏检测的性能问题，从暴力全量检测变成了指向性的检测</li>
<li>提出了空白占位节点的概念，解决了angular里面一堆注释节点的问题</li>
<li>动画功能很强大</li>
</ul>
<h4 id="缺点-1">缺点</h4>
<ul>
<li>defineproperties必须提前写好属性，侵入的改写get set。</li>
<li>不支持ie8</li>
<li>直接解析dom节点，（造成额外的404请求，一些写法有问题。因为提前渲染）</li>
<li>一直保留着对dom的引用。是否是一种浪费</li>
<li>初次渲染并不会比脏检测快，因为需要各种递归的注入。</li>
<li>指令写多了模板可读性太差。</li>
<li>暂时没有服务端渲染方案，因为依赖dom。</li>
</ul>
<p>其实这些缺点也都是angular会有的缺点，可以说vue已经解决了大部分的angular会有的问题。不过为了使用defineproperties放弃了支持ie8，对于国内的环境来说，ie8还是难以割舍。</p>
<h3 id="reactjs">reactjs</h3>
<p>reactjs创造性的提出了虚拟dom的概念，完全改变了前端的开发方式</p>
<h4 id="原理-2">原理</h4>
<p>react，其实就是虚拟dom与真实dom的互动。</p>
<p><img src="https://img.alicdn.com/tps/TB1NPA_JpXXXXcVXXXXXXXXXXXX-1024-768.jpg" alt="ddd"></p>
<p>最上面的<code>text,basic element,custom element</code>都是我们通常说的<code>virtual dom</code>。我们先不管红色的自定义组件节点<code>custom element</code>。</p>
<p>每一个<code>virtual dom</code>都有一个对应的<code>Component</code>来管理。<code>Component</code>具有两个方法：<code>mountComponent</code>还有<code>receiveComponent</code>分别负责处理初次渲染还有更新的逻辑。</p>
<p>react初次渲染就是拼接出字符串。每种<code>virtual dom</code>会调用自己的<code>Component</code>对应的<code>mountComponent</code>来得到渲染之后的内容。比如对于text就直接返回个span包裹的文本，对于basic element，需要先处理自身属性，再调用子节点对应的Component的mountComponent，最后全部拼接好，一次性的innerHTMl到页面上。</p>
<p>更新的时候，react里面一般是通过setState来赋予一个新的值，这样内部再调用receiveComponent来处理逻辑。对于basic element，就是先更新属性，再去更新子节点。这里有套算法，能复用的就直接调用子节点的receiveComponent。否则就是一次重新的mountComponent渲染（diff,patch）。对于text节点，直接是innerHTML更新。</p>
<p>具体原理参考：<a href="http://purplebamboo.github.io/2015/09/15/reactjs_source_analyze_part_one/" target="_blank">http://purplebamboo.github.io/2015/09/15/reactjs_source_analyze_part_one/</a></p>
<h4 id="分析-2">分析</h4>
<ul>
<li><p>如何监听数据的变化：很原始的get set（setState），跟我们最上面的<code>setChunkData</code>类似</p>
</li>
<li><p>如何渲染更新页面定位节点位置：不需要直接引用真实dom，引用虚拟dom就行。虚拟dom根据id来跟真实dom一一对应。</p>
</li>
<li><p>如何实现双向绑定：原生不支持双向绑定，不过有插件形式的替代方案。</p>
</li>
<li><p>如何实现批量更新：执行方法时会包裹一个batchUpdate。这样所有的setState会执行完以后再统一去diff。</p>
</li>
</ul>
<h4 id="特点-1">特点</h4>
<ul>
<li>创造性的提出了virtual dom的概念</li>
<li>支持服务端渲染</li>
<li>通过dom的diff，加快了更新速度</li>
</ul>
<h4 id="缺点-2">缺点</h4>
<ul>
<li>本质上还是脏检测，虽然这个脏检测是可以优化的</li>
<li>其实不存在模板语法，if，for都是要写js代码。理解起来很困难。</li>
<li>全家桶没办法跟其他的技术结合</li>
<li>不允许自己修改dom</li>
</ul>
<h2 id="思考">思考</h2>
<p>不管是 angularjs，vuejs，或者是reactjs，总感觉用起来不是那么顺手，原因是我们已经习惯了传统意义上的模板写法。所以这种dom based的模板总会有这样那样的限制，导致我们不能很顺畅的去开发。</p>
<p>上面这几种，目前我是比较喜欢vue的设计理念的，但是它也有着我们难以接受的缺点。不能说vue不优秀，只是的确不适合我们的业务。</p>
<p>那么我们是不是可以改造下，是否可以结合virtual dom 跟 指令的优势？</p>
<p>vue的指令是直接操作dom的，如果加一层virtual dom，实现大部分dom方法。让指令引用virtual dom，由virtual dom来操作真实dom。这样其实就可以解决掉vue的大部分问题。</p>
<p>我们可以先把模板解析成一个ast（抽象语法树）结构的虚拟dom树。然后去解析这个树，分析出各种依赖信息。这比vue直接使用原生dom会好很多。</p>
<p>指令不会直接跟dom打交道，而是跟虚拟dom打交道。</p>
<p>对于初次的渲染来说，各个指令会调用虚拟dom的方法，此时虚拟dom知道是初次渲染，所以只会更新自己，而不会修改真实的dom。在最后全部执行好后，一次性的innerHTML到页面中。有点跟react类似？</p>
<p>而更新的时候，仍然是指令的逻辑，只不过这个时候虚拟dom不仅仅会更新自身，也会同时更新真实的dom。</p>
<p>可以看到因为加了一层虚拟dom，解决了很多问题。</p>
<p>我们的基本原理还是vue的原理，但是通过一层中间虚拟dom层。我们可以做到：</p>
<ul>
<li>可以把模板的解析前置到打包阶段。打包出虚拟的virtual dom，像react那样，而vue是放到一个documentfragment，先渲染再改动。</li>
<li>初次渲染不再依赖真实dom，从而使服务器渲染可以像react那样变得比较简单。</li>
<li>因为不依赖dom，所以不会出现vue那样的非法指令的问题。</li>
<li>因为有一层中间dom。所以理论上可以支持任何语法，只要后面打包时转成虚拟dom的语法。</li>
</ul>
<p>所以 我做了pat，在vue的基础上加上vd的概念，当然还支持了ie8等等，为了支持业务做了一些改动。</p>
<p>一句话概括pat:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="function"><span class="title">listener</span><span class="params">(define<span class="variable">Properties</span>/dirtycheck)</span> + <span class="title">directive</span> + <span class="title">virtual</span> <span class="title">dom</span></span>
</pre></td></tr></table></figure>

<p>地址：<a href="http://purplebamboo.github.io/pat/doc/views/index.html" target="_blank">http://purplebamboo.github.io/pat/doc/views/index.html</a></p>
<p>与目前主要的框架相比，pat具有以下特点：</p>
<ul>
<li>单一职责，pat只负责解决模板问题。使用者可以单独使用，也可以跟任何其他框架结合使用。</li>
<li>支持类mustache风格的模板语法，避免了指令写多了模板可读性差的问题。</li>
<li>具有指令型框架的特点，扩展性强，功能强大，可以扩展自己的指令。同时支持filter与自定义watcher。</li>
<li>具有virtual dom中间层，一方面加快了分析指令的速度，另一方面也为服务端渲染提供了可能。还解决了错误属性的问题。而且没有强引用。</li>
<li>考虑到目前国内情况，pat做了大量事情，兼容到了ie8。</li>
<li>同时支持脏检测与defineProperties的数据检测机制。在defineProperties模式下使用vbscript来做ie8兼容处理。</li>
</ul>
<h2 id="结语">结语</h2>
<p>目前的前端界各种框架满天飞，但是都或多或少的有所缺陷。有句话说的好，没有最完美的方案只有最适合的自己的方案。</p>
<p>在这样的背景下作为一个前端遇到问题该怎么办呢，我认为可以先找开源技术，但是当开源技术不能满足自己的需求时。可以在开源技术的基础上修改加上自己的东西从而更好的解决问题。</p>
<p>其实把模板解析成ast已经有很多框架在做了。都是看重了virtual dom的优势。比如下面这些：</p>
<ul>
<li><a href="https://github.com/ractivejs/ractive" target="_blank">htmlbar</a>: 运行在handlebar之后的二次编译</li>
<li><a href="http://examples.ractivejs.org/todos" target="_blank">ractivejs</a>: 也是分析成虚拟dom</li>
<li><a href="https://github.com/regularjs/regular" target="_blank">Regularjs</a>: 网易的框架，在angular基础上改造而来</li>
<li><a href="https://github.com/kof/diff-renderer" target="_blank">diff-render</a>: facebook的人开发的，可以直接diff两个渲染好的字符串的差异，然后去更新。本质上每次都会解析成虚拟dom，然后像react那样diff这两个虚拟dom树</li>
</ul>
<p>总之前端的轮子真的太多了，但是无外乎那些解决方案，我们要做的就是了解这些方案，找到合适自己的，当没有特别合适的就拿一个加以改造解决自己的问题（于是又会造个轮子＝ ＝）。</p>
<h2 id="相关引用">相关引用</h2>
<ul>
<li><a href="http://div.io/topic/636" target="_blank">http://div.io/topic/636</a></li>
<li><a href="http://www.liaoxuefeng.com/article/001426512790239f83bfb47b1134b63b09a57548d06e5c5000" target="_blank">http://www.liaoxuefeng.com/article/001426512790239f83bfb47b1134b63b09a57548d06e5c5000</a></li>
<li><a href="http://www.cnblogs.com/hustskyking/p/principle-of-javascript-template.html" target="_blank">http://www.cnblogs.com/hustskyking/p/principle-of-javascript-template.html</a></li>
<li><a href="http://www.html-js.com/article/Regularjs-Chinese-guidelines-for-a-comprehensive-summary-of-the-front-template-technology" target="_blank">http://www.html-js.com/article/Regularjs-Chinese-guidelines-for-a-comprehensive-summary-of-the-front-template-technology</a></li>
<li><a href="http://www.toobug.net/article/how_to_design_front_end_template_engine.html" target="_blank">http://www.toobug.net/article/how_to_design_front_end_template_engine.html</a></li>
<li><a href="https://www.zhihu.com/question/32524504" target="_blank">https://www.zhihu.com/question/32524504</a></li>
<li><a href="http://ejohn.org/blog/javascript-micro-templating/" target="_blank">http://ejohn.org/blog/javascript-micro-templating/</a></li>
<li><a href="http://nuysoft.com/bak/templating.html" target="_blank">http://nuysoft.com/bak/templating.html</a></li>
</ul>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/partial/">partial</a><a href="/tags/refresh/">refresh</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/javascript/">javascript</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://purplebamboo.github.com/2016/04/21/about-partial-refresh/" data-title="局部刷新模板那些事 | blog of purplebamboo" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2016/08/16/iconfont_code_and_use/" title="iconfont字体生成原理及使用技巧">
  <strong>PREVIOUS:</strong><br/>
  <span>
  iconfont字体生成原理及使用技巧</span>
</a>
</div>


<div class="next">
<a href="/2015/09/15/reactjs_source_analyze_part_two/"  title="reactjs源码分析-下篇（更新机制实现原理）">
 <strong>NEXT:</strong><br/> 
 <span>reactjs源码分析-下篇（更新机制实现原理）
</span>
</a>
</div>

</nav>

	
<section class="comment">
	<div class="ds-thread"></div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#原始的模板"><span class="toc-number">1.</span> <span class="toc-text">原始的模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串模板的兴起"><span class="toc-number">2.</span> <span class="toc-text">字符串模板的兴起</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串模板的局部刷新"><span class="toc-number">3.</span> <span class="toc-text">字符串模板的局部刷新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#新时代的“模板”"><span class="toc-number">4.</span> <span class="toc-text">新时代的“模板”</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#angularjs"><span class="toc-number">4.1.</span> <span class="toc-text">angularjs</span></a></li><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原理"><span class="toc-number">4.1.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分析"><span class="toc-number">4.1.2.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优点"><span class="toc-number">4.1.3.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缺点"><span class="toc-number">4.1.4.</span> <span class="toc-text">缺点</span></a></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#vuejs"><span class="toc-number">4.2.</span> <span class="toc-text">vuejs</span></a></li><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原理-1"><span class="toc-number">4.2.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分析-1"><span class="toc-number">4.2.2.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#特点"><span class="toc-number">4.2.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缺点-1"><span class="toc-number">4.2.4.</span> <span class="toc-text">缺点</span></a></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#reactjs"><span class="toc-number">4.3.</span> <span class="toc-text">reactjs</span></a></li><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原理-2"><span class="toc-number">4.3.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分析-2"><span class="toc-number">4.3.2.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#特点-1"><span class="toc-number">4.3.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缺点-2"><span class="toc-number">4.3.4.</span> <span class="toc-text">缺点</span></a></li></ol></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#思考"><span class="toc-number">5.</span> <span class="toc-text">思考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结语"><span class="toc-number">6.</span> <span class="toc-text">结语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#相关引用"><span class="toc-number">7.</span> <span class="toc-text">相关引用</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/angularjs记录/" title="angularjs记录">angularjs记录<sup>9</sup></a></li>
		
			<li><a href="/categories/css/" title="css">css<sup>1</sup></a></li>
		
			<li><a href="/categories/iconfont技术/" title="iconfont技术">iconfont技术<sup>2</sup></a></li>
		
			<li><a href="/categories/javascript/" title="javascript">javascript<sup>18</sup></a></li>
		
			<li><a href="/categories/javascript/nodejs/" title="nodejs">nodejs<sup>2</sup></a></li>
		
			<li><a href="/categories/从零单排/" title="从零单排">从零单排<sup>1</sup></a></li>
		
			<li><a href="/categories/各种知识点记录/" title="各种知识点记录">各种知识点记录<sup>1</sup></a></li>
		
			<li><a href="/categories/javascript/源码分析/" title="源码分析">源码分析<sup>7</sup></a></li>
		
			<li><a href="/categories/系统环境/" title="系统环境">系统环境<sup>1</sup></a></li>
		
			<li><a href="/categories/angularjs记录/翻译/" title="翻译">翻译<sup>1</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/Filters/" title="Filters">Filters<sup>1</sup></a></li>
		
			<li><a href="/tags/analyze/" title="analyze">analyze<sup>1</sup></a></li>
		
			<li><a href="/tags/angular/" title="angular">angular<sup>2</sup></a></li>
		
			<li><a href="/tags/angularjs/" title="angularjs">angularjs<sup>7</sup></a></li>
		
			<li><a href="/tags/ast/" title="ast">ast<sup>1</sup></a></li>
		
			<li><a href="/tags/async/" title="async">async<sup>1</sup></a></li>
		
			<li><a href="/tags/border-shadow/" title="border-shadow">border-shadow<sup>1</sup></a></li>
		
			<li><a href="/tags/chunked/" title="chunked">chunked<sup>1</sup></a></li>
		
			<li><a href="/tags/class/" title="class">class<sup>1</sup></a></li>
		
			<li><a href="/tags/co/" title="co">co<sup>2</sup></a></li>
		
			<li><a href="/tags/comet/" title="comet">comet<sup>1</sup></a></li>
		
			<li><a href="/tags/controllers/" title="controllers">controllers<sup>1</sup></a></li>
		
			<li><a href="/tags/css3/" title="css3">css3<sup>1</sup></a></li>
		
			<li><a href="/tags/generator/" title="generator">generator<sup>1</sup></a></li>
		
			<li><a href="/tags/git/" title="git">git<sup>1</sup></a></li>
		
			<li><a href="/tags/gulp/" title="gulp">gulp<sup>1</sup></a></li>
		
			<li><a href="/tags/html/" title="html">html<sup>1</sup></a></li>
		
			<li><a href="/tags/iconfont/" title="iconfont">iconfont<sup>2</sup></a></li>
		
			<li><a href="/tags/javascript/" title="javascript">javascript<sup>15</sup></a></li>
		
			<li><a href="/tags/koa/" title="koa">koa<sup>2</sup></a></li>
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
      <li><a href="http://ued.taobao.com/" target="_blank">淘宝UED</a> </li>            <li><a href="http://www.aliued.com/" target="_blank">Alibaba国际站UED</a> </li>            <li><a href="http://china.aliued.com/" target="_blank">Alibaba中文站UED</a> </li>            <li><a href="http://ued.alipay.com/" target="_blank"> 支付宝UED</a> </li>            <li><a href="http://ued.tmall.com/" target="_blank">天猫UED</a> </li><li><a href="http://ur.alibaba-inc.com">阿里用户体验中心</a> </li>	 <li><a href="http://www.uisdc.com" target="_blank">优秀网页设计</a> </li>
      
    </ul>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
		<p class="copyright">Powered by <a href="http://zespia.tw/hexo/" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2016 
		
		<a href="http://purplebamboo.github.com" target="_blank" title="purplebamboo">purplebamboo</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"cherishpeace"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 






<script type="text/javascript">
  $(function(){
    window.onscroll = function(){
      //console.log($(document).scrollTop()+"px")
      $('.background-container .bg-dy2').css('backgroundPosition','0 '+$(document).scrollTop()+"px");
    }

  })
</script>
<div class="background-container">
  <div class="bg-dy1">

  </div>
  <div class="bg-dy2">

  </div>

</div

  </body>
</html>
