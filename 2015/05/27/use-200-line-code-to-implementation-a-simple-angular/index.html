
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>(翻译)使用200行代码创建属于你自己的精简版angular | blog of purplebamboo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="purplebamboo">
    
    <meta name="description" content="原文：http://blog.mgechev.com/2015/03/09/build-learn-your-own-light-lightweight-angularjs/
第一次翻译外文，就拿这篇作为第一次练习。加上一些自己的理解并且做了些删减。
正文开始：
我的实践经验证明有两种好方法来学习一">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="blog of purplebamboo" title="blog of purplebamboo"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="blog of purplebamboo">blog of purplebamboo</a></h1>
				<h2 class="blog-motto">dota诚可贵，coding价更高，若为女朋友，二者皆可抛。</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/categories">分类</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:purplebamboo.github.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/05/27/use-200-line-code-to-implementation-a-simple-angular/" title="(翻译)使用200行代码创建属于你自己的精简版angular" itemprop="url">(翻译)使用200行代码创建属于你自己的精简版angular</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://purplebamboo.github.com" title="purplebamboo">purplebamboo</a>
    </p>
  <p class="article-time">
    <time datetime="2015-05-27T14:58:56.000Z" itemprop="datePublished">5月 27 2015</time>
    更新日期:<time datetime="2015-06-20T17:24:14.000Z" itemprop="dateModified">6月 21 2015</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#主要的组件："><span class="toc-number">1.</span> <span class="toc-text">主要的组件：</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Provider"><span class="toc-number">1.1.</span> <span class="toc-text">Provider</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOMCompiler"><span class="toc-number">1.2.</span> <span class="toc-text">DOMCompiler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scope"><span class="toc-number">1.3.</span> <span class="toc-text">Scope</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#开始实现"><span class="toc-number">2.</span> <span class="toc-text">开始实现</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Provider-1"><span class="toc-number">2.1.</span> <span class="toc-text">Provider</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOMCompiler-1"><span class="toc-number">2.2.</span> <span class="toc-text">DOMCompiler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scope-1"><span class="toc-number">2.3.</span> <span class="toc-text">Scope</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Directive"><span class="toc-number">2.4.</span> <span class="toc-text">Directive</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#一个完整的例子"><span class="toc-number">3.</span> <span class="toc-text">一个完整的例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结论"><span class="toc-number">4.</span> <span class="toc-text">结论</span></a></li></ol>
		</div>
		
		<p>原文：<a href="http://blog.mgechev.com/2015/03/09/build-learn-your-own-light-lightweight-angularjs/" target="_blank">http://blog.mgechev.com/2015/03/09/build-learn-your-own-light-lightweight-angularjs/</a></p>
<p>第一次翻译外文，就拿这篇作为第一次练习。加上一些自己的理解并且做了些删减。</p>
<p>正文开始：</p>
<p>我的实践经验证明有两种好方法来学习一项新技术。</p>
<ul>
<li>自己重新实现这个项目</li>
<li>分析那些你所知道的技术概念是如何运用在这个项目里的</li>
</ul>
<p>在一些情况下第一种方式很难做到。比如，如果你为了理解<a href="https://github.com/torvalds/linux" target="_blank">kernel</a>（linux内核）的工作原理而去重新实现一次它会很困难很慢。往往更有效的是你去实现一个轻量的版本，去除掉那些你没兴趣的技术细节，只关注核心功能。</p>
<p>第二种方法一般是很有效的，特别是当你具有一些相似的技术经验的时候。最好的证明就是我写的<a href="https://github.com/mgechev/angularjs-in-patterns" target="_blank">angularjs-in-patterns</a>,对于有经验的工程师来说这是个对angular框架非常好的介绍。</p>
<p>不管怎么说，从头开始实现一些东西并且去理解代码使用的技术细节是非常好的学习方式。整个angularjs框架大概有20k行代码，其中有很多特别难懂的地方。这是很多聪明的程序员夜以继日的工作做出来的伟大的壮举。然而为了理解这个框架还有它主要的设计原则，我们可以仅仅简单的实现一个‘模型’。</p>
<p>我们可以通过下面这些步骤来实现这个模型：</p>
<ul>
<li>简化api</li>
<li>去除掉对于理解核心功能无关的组件代码</li>
</ul>
<p>这就是我在<a href="https://github.com/mgechev/light-angularjs" target="_blank">Lightweight AngularJS</a>里面做的事情。</p>
<p>在开始阅读下面的内容之前，建议先了解下angularjs的基本用法，可以看这篇<a href="http://blog.mgechev.com/2014/05/08/angularjs-in-patterns-part-1-overview-of-angularjs/" target="_blank">文章</a></p>
<p>下面是一些demo例子还有代码片段：</p>
<ul>
<li><a href="https://github.com/mgechev/light-angularjs" target="_blank">Lightweight AngularJS source code</a></li>
<li><a href="https://mgechev.github.io/light-angularjs/" target="_blank">Very simple todo application built with Lightweight AngularJS</a></li>
</ul>
<p>让我们开始我们的实现：</p>
<h2 id="主要的组件：">主要的组件：</h2>
<p>我们不完全实现angularjs的那套技术，我们就仅仅定义一部分的组件并且实现大部分的angularjs里面的时尚特性。可能会接口变得简单点，或者减少些功能特性。</p>
<p>我们会实现的angular的组件包括：</p>
<ul>
<li>Controllers</li>
<li>Directives</li>
<li>Services</li>
</ul>
<p>为了达到这些功能我们需要实现<code>$compile</code>service(我们称之为<code>DOMCompiler</code>),还有<code>$provider</code>跟<code>$injector</code>(在我们的实现里统称为Provider)。为了实现双向绑定我们还要实现scope。</p>
<p>下面是Provider, Scope 跟 DOMCompiler 的依赖关系：</p>
<p><img src="http://blog.mgechev.com/images/lightweight-ng/main-components.png" alt="yilai"></p>
<h3 id="Provider">Provider</h3>
<p>就像上面提到的，我们的Provider会包括原生angular里面的两个组件的内容：</p>
<ul>
<li>$provide</li>
<li>$injector</li>
</ul>
<p>他是一个具有如下功能特性的单列：</p>
<ul>
<li>注册组件（directives, services 和 controllers）</li>
<li>解决各个组件之间的依赖关系</li>
<li>初始化所有组件</li>
</ul>
<h3 id="DOMCompiler">DOMCompiler</h3>
<p>DOMCompiler也是一个单列，他会遍历dom树去查找对应的directives节点。我们这里仅仅支持那种用在dom元素属性上的directive。当DOMCompiler发现directive的时候会给他提供scope的功能特性（因为对应的directive可能需要一个新的scope）并且调用关联在它上面对应的逻辑代码（也就是link函数里面的逻辑）。所以这个组件的主要职责就是：</p>
<p>编译dom</p>
<ul>
<li>遍历dom树的所有节点</li>
<li>找到注册的属性类型的directives指令</li>
<li>调用对应的directive对应的link逻辑</li>
<li>管理scope</li>
</ul>
<h3 id="Scope">Scope</h3>
<p>我们的轻量级angular的最后一个主要的组件就是scope。为了实现双向绑定的功能，我们需要有一个$scope对象来挂载属性。我们可以把这些属性组合成表达式并且监控它们。当我们发现监控的某个表达式的值改变了，我们就调用对应的回调函数。</p>
<p>scope的职责：</p>
<ul>
<li>监控表达式</li>
<li>在每次$digest循环的时候执行所有的表达式，直到稳定（译者注：稳定就是说，表达式的值不再改变的时候）</li>
<li>在表达式的值发生改变时，调用对应的所有的回调函数</li>
</ul>
<p>下面本来还有些图论的讲解，但是认为意义不大，这边就略去了。</p>
<h2 id="开始实现">开始实现</h2>
<p>让我们开始实现我们的轻量版angular</p>
<h3 id="Provider-1">Provider</h3>
<p>正如我们上面说的，Provide会：</p>
<ul>
<li>注册组件（directives, services 和 controllers）</li>
<li>解决各个组件之间的依赖关系</li>
<li>初始化所有组件</li>
</ul>
<p>所以它具有下面这些接口：</p>
<ul>
<li>get(name, locals) - 通过名称 还有本地依赖 返回对应的service</li>
<li>invoke(fn, locals) - 通过service对应的工厂函数还有本地依赖初始化service</li>
<li>directive(name, fn) - 通过名称还有工厂函数注册一个directive</li>
<li>controller(name, fn) - 通过名称还有工厂函数注册一个controller。注意angularjs的代码里并没有controllers对应的代码，他们是通过$controller来实现的。</li>
<li>service(name, fn) - 通过名称还有工厂函数注册一个service</li>
<li>annotate(fn) - 返回一个数组，数组里是当前service依赖的模块的名称</li>
</ul>
<p>组件的注册：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="keyword">var</span> Provider = {
  _providers: {},
  directive: <span class="function"><span class="keyword">function</span> <span class="params">(name, fn)</span> {</span>
    <span class="keyword">this</span>._register(name + Provider.DIRECTIVES_SUFFIX, fn);
  },
  controller: <span class="function"><span class="keyword">function</span> <span class="params">(name, fn)</span> {</span>
    <span class="keyword">this</span>._register(name + Provider.CONTROLLERS_SUFFIX, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
      <span class="keyword">return</span> fn;
    });
  },
  service: <span class="function"><span class="keyword">function</span> <span class="params">(name, fn)</span> {</span>
    <span class="keyword">this</span>._register(name, fn);
  },
  _register: <span class="function"><span class="keyword">function</span> <span class="params">(name, factory)</span> {</span>
    <span class="keyword">this</span>._providers[name] = factory;
  }
  <span class="comment">//...</span>
};
Provider.DIRECTIVES_SUFFIX = <span class="string">'Directive'</span>;
Provider.CONTROLLERS_SUFFIX = <span class="string">'Controller'</span>;
</pre></td></tr></table></figure>

<blockquote>
<p>译者注：看到这里容易对controller的包装一层有疑问，先忽略，看完invoke的实现后，下面我再给出解释。</p>
</blockquote>
<p>上面的代码提供了一个针对注册组件的简单的实现。我们定义了一个私有属性<code>_provides</code>用来存储所有的组件的工厂函数。我们还定义了directive,service和controller这些方法。这些方法本质上内部会调用_register来实现。在controller方法里面我们简单的在给的工厂函数外面包装了一层函数，因为我们希望可以多次实例化同一个controller而不去缓存返回的值。在我们看了下面的get和ngl-controller方法实现后会对controller方法有更加清晰的认识。下面还剩下的方法就是：</p>
<ul>
<li>invoke</li>
<li>get</li>
<li>annotate</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre>
<span class="keyword">var</span> Provider = {
  <span class="comment">// ...</span>
  get: <span class="function"><span class="keyword">function</span> <span class="params">(name, locals)</span> {</span>
    <span class="keyword">if</span> (<span class="keyword">this</span>._cache[name]) {
      <span class="keyword">return</span> <span class="keyword">this</span>._cache[name];
    }
    <span class="keyword">var</span> provider = <span class="keyword">this</span>._providers[name];
    <span class="keyword">if</span> (!provider || <span class="keyword">typeof</span> provider !== <span class="string">'function'</span>) {
      <span class="keyword">return</span> <span class="literal">null</span>;
    }
    <span class="keyword">return</span> (<span class="keyword">this</span>._cache[name] = <span class="keyword">this</span>.invoke(provider, locals));
  },
  annotate: <span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> {</span>
    <span class="keyword">var</span> res = fn.toString()
        .replace(<span class="regexp">/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg</span>, <span class="string">''</span>)
        .match(<span class="regexp">/\((.*?)\)/</span>);
    <span class="keyword">if</span> (res && res[<span class="number">1</span>]) {
      <span class="keyword">return</span> res[<span class="number">1</span>].split(<span class="string">','</span>).map(<span class="function"><span class="keyword">function</span> <span class="params">(d)</span> {</span>
        <span class="keyword">return</span> d.trim();
      });
    }
    <span class="keyword">return</span> [];
  },
  invoke: <span class="function"><span class="keyword">function</span> <span class="params">(fn, locals)</span> {</span>
    locals = locals || {};
    <span class="keyword">var</span> deps = <span class="keyword">this</span>.annotate(fn).map(<span class="function"><span class="keyword">function</span> <span class="params">(s)</span> {</span>
      <span class="keyword">return</span> locals[s] || <span class="keyword">this</span>.get(s, locals);
    }, <span class="keyword">this</span>);
    <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, deps);
  },
  _cache: { $rootScope: <span class="keyword">new</span> Scope() }
};
</pre></td></tr></table></figure>

<p>我们写了更多的逻辑，下面我们看看get的实现。</p>
<p>在get方法中我们先检测下一个组件是不是已经缓存在了私有属性_cache里面。</p>
<ul>
<li>如果缓存了就直接返回（译者注：这边其实就是个单列模式，只会调用注册的工厂函数一次，以后直接调用缓存的生成好的对象）。$rootScope默认就会被缓存，，因为我们需要一个单独的全局的并且唯一的超级scope。一旦整个应用启动了，他就会被实例化。</li>
<li>如果不在缓存里，就从私有属性_providers里面拿到它的工厂函数，并且调用invoke去执行工厂函数实例化它。</li>
</ul>
<p>在invoke函数里，我们做的第一件事就是判断如果没有locals对象就赋值一个空的值。</p>
<p>这些locals对象 叫做局部依赖，什么是局部依赖呢？</p>
<p>在angularjs里面我们可以想到两种依赖：</p>
<ul>
<li>局部依赖</li>
<li>全局依赖</li>
</ul>
<p>全局依赖是我们使用factory，service，filter等等注册的组件。他们可以被所有应用里的其他组件依赖使用。但是$scope呢？对于每一个controller（具有相同执行函数的controller）我们希望拥有不同的scope，$scope对象不像$http,$resource，它不是全局的依赖对象，而是跟$delegate对象一样是局部依赖，针对当前的组件。</p>
<p>让我们呢回到invoke的实现上。通过合理的规避null，undefined这些值，我们可以获取到当前组件的依赖项的名字。注意我们的实现仅仅支持解析那种作为参数属性的依赖写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>
<span class="function"><span class="keyword">function</span> <span class="title">Controller</span><span class="params">($scope, $http)</span> {</span>
  <span class="comment">// ...</span>
}
angular.controller(<span class="string">'Controller'</span>, Controller);
</pre></td></tr></table></figure>

<p>一旦把controller的定义转换成字符串，我们就可以很简单的通过annotate里面的正则匹配出它的依赖项。但是万一controller的定义里面有注释呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>
<span class="function"><span class="keyword">function</span> <span class="title">Controller</span><span class="params">($scope <span class="comment">/* only local scope, for the component */</span>, $http)</span> {</span>
  <span class="comment">// ...</span>
}
angular.controller(<span class="string">'Controller'</span>, Controller);
</pre></td></tr></table></figure>

<p>这边简单的正则就不起作用了，因为执行Controller.toString()也会返回注释，所以这就是我们为什么最开始要使用下面的正则先去掉注释：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>.replace(/((<span class="command">\/</span><span class="command">\/</span>.*<span class="formula">$)|(<span class="command">\/</span><span class="command">\*</span><span class="special">[</span><span class="command">\s</span><span class="command">\S</span><span class="special">]</span>*?<span class="command">\*</span><span class="command">\/</span>))/mg, '').</span>
</pre></td></tr></table></figure>

<p>当我们拿到依赖项的名称后，我们需要去实例化他们。所以我们使用map来循环遍历，挨个的调用get来获取实例。你注意到这边的问题了吗？</p>
<p>如果我们有个组件A，A依赖B和C。并且假设C依赖A？在这种情况下我们就会发生无止境的循环，也就是循环依赖。在这个实现里面我们不会处理这种问题，但是你应该小心点，尽量避免。</p>
<p>所以上面就是我们的provider的实现，现在我们可以这样注册组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>Provider.service(<span class="string">'RESTfulService'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(url)</span> {</span>
    <span class="comment">// make restful call & return promise</span>
  };
});

Provider.controller(<span class="string">'MainCtrl'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(RESTfulService)</span> {</span>
  RESTfulService(url)
  .then(<span class="function"><span class="keyword">function</span> <span class="params">(data)</span> {</span>
    alert(data);
  });
});
</pre></td></tr></table></figure>

<p>然后我们可以这样执行MainCtrl：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">var</span> ctrl = Provider.get(<span class="string">'MainCtrl'</span> + Provider.CONTROLLERS_SUFFIX);
Provider.invoke(ctrl);
</pre></td></tr></table></figure>

<p>译者注：</p>
<p>这边可以开始解释下上面的Provider里面controller方法里为啥要包装一层了。</p>
<p>首先我们注意到controller的调用方式是特殊的，Provider.get内部已经调用了一次invoke，但是我们还要再调用一次invoke才能执行MainCtrl的真正执行函数。这是因为我们包装了一层，导致_cache里面单列存储的是MainCtrl的执行函数。而不是执行函数的结果。</p>
<p>想想这才是合理的，因为MainCtrl可能会有多个调用，这些调用只有执行函数是一致的，但是执行函数的执行结果根据不同的scope环境是不一样的。换句话说对于controller来说 执行函数才是单列的，执行结果是差异的。如果我们不包装一层，就会导致第一次的执行结果会直接缓存，这样下次再使用MainCtrl的时候得到的值就是上一次的。</p>
<p>当然带来的问题就是我们需要get到执行函数后，再次调用invoke来获取结果。</p>
<p>这边的controller初始化，需要看下面的ngl-controller的实现，可以到时再回过头来看这边会理解的更清楚。</p>
<h3 id="DOMCompiler-1">DOMCompiler</h3>
<p>DOMCompiler的主要职责是：</p>
<p>编译dom</p>
<ul>
<li>遍历dom树的所有节点</li>
<li>找到注册的属性类型的directives指令</li>
<li>调用对应的directive对应的link逻辑</li>
<li>管理scope</li>
</ul>
<p>下面的这些接口就够了：</p>
<ul>
<li>bootstrap() - 启动整个项目（类似angularjs里面的angular。bootstrap，不过一直使用html根节点作为启动的节点）</li>
<li>compile(el, scope) - 执行所有依附在当前html节点上的directives的代码，并且递归执行子元素的组件逻辑。我们需要一个scope对象关联当前的html节点，这样才能实现双向绑定。因为每个directive可能都会生成一个不同的scope，所以我们需要在递归调用的时候传入当前的scope对象。</li>
</ul>
<p>下面是对应的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="keyword">var</span> DOMCompiler = {
  bootstrap: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">this</span>.compile(document.children[<span class="number">0</span>],
      Provider.get(<span class="string">'$rootScope'</span>));
  },
  compile: <span class="function"><span class="keyword">function</span> <span class="params">(el, scope)</span> {</span>
    <span class="comment">//获取某个元素上的所有指令</span>
    <span class="keyword">var</span> dirs = <span class="keyword">this</span>._getElDirectives(el);
    <span class="keyword">var</span> dir;
    <span class="keyword">var</span> scopeCreated;
    dirs.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(d)</span> {</span>
      dir = Provider.get(d.name + Provider.DIRECTIVES_SUFFIX);
      <span class="comment">//dir.scope代表当前 directive是否需要生成新的scope</span>
      <span class="comment">//这边的情况是只要有一个指令需要单独的scope，其他的directive也会变成具有新的scope对象，这边是不是不太好</span>
      <span class="keyword">if</span> (dir.scope && !scopeCreated) {
        scope = scope.$<span class="keyword">new</span>();
        scopeCreated = <span class="literal">true</span>;
      }
      dir.link(el, scope, d.value);
    });
    <span class="built_in">Array</span>.prototype.slice.call(el.children).forEach(<span class="function"><span class="keyword">function</span> <span class="params">(c)</span> {</span>
      <span class="keyword">this</span>.compile(c, scope);
    }, <span class="keyword">this</span>);
  },
  <span class="comment">// ...</span>
};
</pre></td></tr></table></figure>

<p>bootstrap的实现很简单。就是调用了一下compile，传递的是html的根节点，以及全局的$rootScope。<br>在compile里面的代码就很有趣了，最开始我们使用了一个辅助方法来获取某个节点上面的所有指令。我们后面再来看这个_getElDirectives的实现。<br>当我们获取到当前节点的所有指令后，我们循环遍历下并且使用Provider.get获取到对应的directive的工厂函数的执行返回对象。然后我们检查当前的directive是否需要一个新的scope，如果需要并且我们还没有为当前的节点初始化过新的scope对象，我们就执行scope.$new()来生成一个新的scope对象。这个对象会原型继承当前的scope对象。然后我们执行当前directive的link方法。最后我们递归执行子节点。因为el.children是一个nodelist对象，所以我们使用Array.prototype.slice.call将它转换成数组，之后对它递归调用compile。</p>
<p>再让我们看看_getElDirectives：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>
<span class="comment">// ...</span>
_getElDirectives: <span class="function"><span class="keyword">function</span> <span class="params">(el)</span> {</span>
  <span class="keyword">var</span> attrs = el.attributes;
  <span class="keyword">var</span> result = [];
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; attrs.length; i += <span class="number">1</span>) {
    <span class="keyword">if</span> (Provider.get(attrs[i].name + Provider.DIRECTIVES_SUFFIX)) {
      result.push({
        name: attrs[i].name,
        value: attrs[i].value
      });
    }
  }
  <span class="keyword">return</span> result;
}
<span class="comment">// ...</span>
</pre></td></tr></table></figure>

<p>主要就是遍历当前节点el的所有属性，发现一个注册过的指令就把它的名字和值加入到返回的数组里。</p>
<p>好了，到这里我们的DOMCompiler就完成了，下面我们看看最后一个重要的组件：</p>
<h3 id="Scope-1">Scope</h3>
<p>为了实现脏检测的功能，于是scope可能是整个实现里面最复杂的部分了。在angularjs里面我们称为$digest循环。笼统的讲双向绑定的最主要原理，就是在$digest循环里面执行监控表达式。一旦这个循环开始调用，就会执行所有监控的表达式并且检测最后的执行结果是不是更当前的执行结果不同，如果angularjs发现他们不同，它就会执行这个表达式对应的回调函数。一个监控者就是一个对象像这样{ expr, fn, last }。expr是对应的监控表达试，fn是对应的回调函数会在值变化后执行，last是上一次的表达式的执行结果。</p>
<p>scope对象有下面这些方法：</p>
<ul>
<li>$watch(expr, fn) - 监控表达式 expr。一旦发现expr的值有变化就只行回调函数fn，并且传入新的值</li>
<li>$destroy() - 销毁当前的scope对象</li>
<li>$eval(expr) - 根据上下文执行当前的表达式</li>
<li>$new() - 原型继承当前的scope对象，生成一个新的scope对象，</li>
<li>$digest() - 运营脏检测</li>
</ul>
<p>让我们来深入的看看scope的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Scope</span><span class="params">(parent, id)</span> {</span>
  <span class="keyword">this</span>.$$watchers = [];
  <span class="keyword">this</span>.$$children = [];
  <span class="keyword">this</span>.$parent = parent;
  <span class="keyword">this</span>.$id = id || <span class="number">0</span>;
}
Scope.counter = <span class="number">0</span>;
</pre></td></tr></table></figure>

<p>我们大幅度的简化了angularjs的scope。我们仅仅有一个监控者的列表，一个子scope对象的列表，一个父scope对象，还有个当前scope的id。我们添加了一个静态属性counter用来跟踪最后一个scope，并且为下一个scope对象提供一个唯一的标识。</p>
<p>我们来实现$watch方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>Scope.prototype.$watch = <span class="function"><span class="keyword">function</span> <span class="params">(exp, fn)</span> {</span>
  <span class="keyword">this</span>.$$watchers.push({
    exp: exp,
    fn: fn,
    last: Utils.clone(<span class="keyword">this</span>.$<span class="built_in">eval</span>(exp))
  });
};
</pre></td></tr></table></figure>

<p>在$watch方法中，我们添加了一个新对象到this.$$watchers监控者列表里。这个对象包括一个表达式，一个执行的回调还有最后一次表达式执行的结果last。因为我们使用this.$eval执行表达式得到的结果有可能是个引用，所以我们需要克隆一份新的。</p>
<p>下面我们看看如何新建scope，和销毁scope。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>
Scope.prototype.$<span class="keyword">new</span> = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  Scope.counter += <span class="number">1</span>;
  <span class="keyword">var</span> obj = <span class="keyword">new</span> Scope(<span class="keyword">this</span>, Scope.counter);
  <span class="comment">//设置原型链，把当前的scope对象作为新scope的原型，这样新的scope对象可以访问到父scope的属性方法</span>
  <span class="built_in">Object</span>.setPrototypeOf(obj, <span class="keyword">this</span>);
  <span class="keyword">this</span>.$$children.push(obj);
  <span class="keyword">return</span> obj;
};

Scope.prototype.$destroy = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> pc = <span class="keyword">this</span>.$parent.$$children;
  pc.splice(pc.indexOf(<span class="keyword">this</span>), <span class="number">1</span>);
};
</pre></td></tr></table></figure>

<p>$new用来创建一个新的scope对象，并且具有独一无二的标识，原型被设置为当前scope对象。然后我们把新生成的scope对象放到子scope对象列表（this.$$children）里。</p>
<p>在destroy方法里，我们把当前scope对象从父级scope对象里的子scope对象列表（this.$$children）移除掉。</p>
<p>下面我们看看传说中的脏检测$digest的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>Scope.prototype.$digest = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> dirty, watcher, current, i;
  <span class="keyword">do</span> {
    dirty = <span class="literal">false</span>;
    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.$$watchers.length; i += <span class="number">1</span>) {
      watcher = <span class="keyword">this</span>.$$watchers[i];
      current = <span class="keyword">this</span>.$<span class="built_in">eval</span>(watcher.exp);
      <span class="keyword">if</span> (!Utils.equals(watcher.last, current)) {
        watcher.last = Utils.clone(current);
        dirty = <span class="literal">true</span>;
        watcher.fn(current);
      }
    }
  } <span class="keyword">while</span> (dirty);
  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.$$children.length; i += <span class="number">1</span>) {
    <span class="keyword">this</span>.$$children[i].$digest();
  }
};
</pre></td></tr></table></figure>

<p>基本上我们一直循环运行检测一直到没有脏数据，默认情况下就是没有脏数据的。一旦我们发现当前表达式的执行结果跟上一次的结果不一样我们就任务有了脏数据，一旦我们发现一个脏数据我们就要重新执行一次所有的监控表达式。为什么呢？因为我们可能会有一些内部表达式依赖，所以一个表达式的结果可能会影响到另外一个的结果。这就是为什么我们需要一遍一遍的运行脏检测一直到所有的表达式都没有变化也就是稳定了。一旦我们发现数据改变了，我们就立即执行对应的回调并且更新对应的last值，并且标识当前有脏数据，这样就会再次调用脏检测。</p>
<p>然后我们会继续递归调用子scope对象的脏数据检测，一个需要注意的情况就是这边也会发生循环依赖：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Controller</span><span class="params">($scope)</span> {</span>
  $scope.i = $scope.j = <span class="number">0</span>;
  $scope.$watch(<span class="string">'i'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(val)</span> {</span>
    $scope.j += <span class="number">1</span>;
  });
  $scope.$watch(<span class="string">'j'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(val)</span> {</span>
    $scope.i += <span class="number">1</span>;
  });
  $scope.i += <span class="number">1</span>;
  $scope.$digest();
}
</pre></td></tr></table></figure>

<p>这种情况下我们就会看到：</p>
<p><img src="http://blog.mgechev.com/images/lightweight-ng/snap.png" alt="snap"></p>
<p>最后一个方法是$eval.最好不要在生产环境里使用这个，这个是一个hack手段用来避免我们还需要自己做个表达式解析引擎。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="comment">// In the complete implementation there're</span>
<span class="comment">// lexer, parser and interpreter.</span>
<span class="comment">// Note that this implementation is pretty evil!</span>
<span class="comment">// It uses two dangerouse features:</span>
<span class="comment">// - eval</span>
<span class="comment">// - with</span>
<span class="comment">// The reason the 'use strict' statement is</span>
<span class="comment">// omitted is because of `with`</span>
Scope.prototype.$<span class="built_in">eval</span> = <span class="function"><span class="keyword">function</span> <span class="params">(exp)</span> {</span>
  <span class="keyword">var</span> val;
  <span class="keyword">if</span> (<span class="keyword">typeof</span> exp === <span class="string">'function'</span>) {
    val = exp.call(<span class="keyword">this</span>);
  } <span class="keyword">else</span> {
    <span class="keyword">try</span> {
      <span class="keyword">with</span> (<span class="keyword">this</span>) {
        val = <span class="built_in">eval</span>(exp);
      }
    } <span class="keyword">catch</span> (e) {
      val = <span class="literal">undefined</span>;
    }
  }
  <span class="keyword">return</span> val;
};
</pre></td></tr></table></figure>

<p>我们检测监控的表达式是不是一个函数，如果是的话我们就使用当前的上下文执行它。否则我们就通过with把当前的执行环境改成当前scope的上下文并且使用eval来得到结果。这个可以允许我们执行类似<code>foo + bar * baz()</code>的表达式，甚至是更复杂的。当然我们不会支持filters，因为他们是angularjs扩展的功能。</p>
<h3 id="Directive">Directive</h3>
<p>到目前为止使用已有的元素我们做不了什么。为了让它跑起来我们需要添加一些指令（directive）还有服务（service）。让我们来实现ngl-bind (ng-bind ), ngl-model (ng-model), ngl-controller (ng-controller) and ngl-click (ng-click)。括号里代表在angularjs里面的对应directive</p>
<p><strong>ngl-bind</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>
Provider.directive(<span class="string">'ngl-bind'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> {
    scope: <span class="literal">false</span>,
    link: <span class="function"><span class="keyword">function</span> <span class="params">(el, scope, exp)</span> {</span>
      el.innerHTML = scope.$<span class="built_in">eval</span>(exp);
      scope.$watch(exp, <span class="function"><span class="keyword">function</span> <span class="params">(val)</span> {</span>
        el.innerHTML = val;
      });
    }
  };
});
</pre></td></tr></table></figure>

<p>ngl-bind并不需要一个新的scope，它仅仅对当前节点添加了一个监控。当脏检测发现有了改变，回调函数就会把新的值赋值到innerHTML更新dom</p>
<p><strong>ngl-model</strong></p>
<p>我们的ng-model只会支持input框的改变检测，所以它的实现是这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>Provider.directive(<span class="string">'ngl-model'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> {
    link:  <span class="function"><span class="keyword">function</span> <span class="params">(el, scope, exp)</span> {</span>
      el.onkeyup = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        scope[exp] = el.value;
        scope.$digest();
      };
      scope.$watch(exp, <span class="function"><span class="keyword">function</span> <span class="params">(val)</span> {</span>
        el.value = val;
      });
    }
  };
});
</pre></td></tr></table></figure>

<p>我们对当前的input框添加了一个onkeyup的监听，一旦当前input的值变化了，我们就调用当前scope对象的$digest脏检测循环。这样就可以保证这个改变会应用到所有scope的监控表达式。当值改变了我们就改变对应的节点的值。</p>
<p><strong>ngl-controller</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>Provider.directive(<span class="string">'ngl-controller'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> {
    scope: <span class="literal">true</span>,
    link: <span class="function"><span class="keyword">function</span> <span class="params">(el, scope, exp)</span> {</span>
      <span class="keyword">var</span> ctrl = Provider.get(exp + Provider.CONTROLLERS_SUFFIX);
      Provider.invoke(ctrl, { $scope: scope });
    }
  };
});
</pre></td></tr></table></figure>

<p>我们需要针对每个controller生成一个新的scope对象，所以它的scope的值是true。我们使用Provide.get来获取到需要的controller执行函数，然后使用当前的scope来执行它。在controller里面我们可以给scope对象添加属性，我们可以使用ngl-bind/ngl-model绑定这些属性。一旦我们改变了属性值我们需要确保我们执行$digest脏检测来保证监控这些属性的表达式会执行。</p>
<p><strong>ngl-click</strong></p>
<p>在我们可以做一个有用的todo应用之前，这是我们最后要看的指令。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>Provider.directive(<span class="string">'ngl-click'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> {
    scope: <span class="literal">false</span>,
    link: <span class="function"><span class="keyword">function</span> <span class="params">(el, scope, exp)</span> {</span>
      el.onclick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        scope.$<span class="built_in">eval</span>(exp);
        scope.$digest();
      };
    }
  };
});
</pre></td></tr></table></figure>

<p>这里我们不需要新建个scope对象。我们需要的就是当用户点击按钮时执行当前ngl-click后面跟着的表达式并且调用脏检测。</p>
<h2 id="一个完整的例子">一个完整的例子</h2>
<p>为了保证我们可以理解双向绑定是怎么工作的，我们来看个下面的例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="doctype">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;<span class="title">html</span> <span class="attribute">lang</span>=<span class="value">"en"</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span> <span class="attribute">ngl-controller</span>=<span class="value">"MainCtrl"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">span</span> <span class="attribute">ngl-bind</span>=<span class="value">"bar"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>
  <span class="tag">&lt;<span class="title">button</span> <span class="attribute">ngl-click</span>=<span class="value">"foo()"</span>&gt;</span>Increment<span class="tag">&lt;/<span class="title">button</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>Provider.controller(<span class="string">'MainCtrl'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($scope)</span> {</span>
  $scope.bar = <span class="number">0</span>;
  $scope.foo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    $scope.bar += <span class="number">1</span>;
  };
});
</pre></td></tr></table></figure>

<p>让我们看看使用这些会发生什么：</p>
<p><img src="http://blog.mgechev.com/images/lightweight-ng/lifecycle-overview.png" alt="lifecycle-overview"></p>
<p>首先DOMCompiler会先发现我们的ngl-controller指令。然后会调用这个指令的link函数生成一个新的scope对象传递给controller的执行函数。我们增加了一个值为0的bar属性，还有一个叫做foo的方法，foo方法会不断增加bar。DOMCompiler会发现ngl-bind然后为bar添加监控。并且还发现了ngl-click同时添加click事件到按钮上。</p>
<p>一旦用户点击了按钮，foo函数就会通过$scope.$eval执行。使用的scope对象就是传递给MainCtrl的scope对象。这之后ngl-click会执行脏检测$scope.$digest。脏检测循环会遍历所有的监控表达式，发现bar的值变化了。因为我们添加了对应的回调函数，所以就执行它更新span的内容。</p>
<h2 id="结论">结论</h2>
<p>这个框架离实际的生产环境应用还有很大差距，但是它还是实现了不少功能：</p>
<ul>
<li>双向绑定</li>
<li>依赖注入</li>
<li>作用域分离</li>
</ul>
<p>跟在angular里面的运行方式差不多。这些可以帮助我们更容易理解angularjs。</p>
<p>但是你还是要记住的是不要把这些代码用在生产环境，最好还是直接使用bower install angular使用最新的anguar。</p>
<p><img src="http://blog.mgechev.com/images/no-production.gif" alt="no-production"></p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/angularjs/">angularjs</a><a href="/tags/javascript/">javascript</a><a href="/tags/翻译/">翻译</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/angularjs记录/">angularjs记录</a>►<a class="article-category-link" href="/categories/angularjs记录/翻译/">翻译</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://purplebamboo.github.com/2015/05/27/use-200-line-code-to-implementation-a-simple-angular/" data-title="(翻译)使用200行代码创建属于你自己的精简版angular | blog of purplebamboo" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/06/21/how-to-make-a-barrage/" title="弹幕实现">
  <strong>PREVIOUS:</strong><br/>
  <span>
  弹幕实现</span>
</a>
</div>


<div class="next">
<a href="/2015/03/16/javascript-component/"  title="javascript组件化">
 <strong>NEXT:</strong><br/> 
 <span>javascript组件化
</span>
</a>
</div>

</nav>

	
<section class="comment">
	<div class="ds-thread"></div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#主要的组件："><span class="toc-number">1.</span> <span class="toc-text">主要的组件：</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Provider"><span class="toc-number">1.1.</span> <span class="toc-text">Provider</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOMCompiler"><span class="toc-number">1.2.</span> <span class="toc-text">DOMCompiler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scope"><span class="toc-number">1.3.</span> <span class="toc-text">Scope</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#开始实现"><span class="toc-number">2.</span> <span class="toc-text">开始实现</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Provider-1"><span class="toc-number">2.1.</span> <span class="toc-text">Provider</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOMCompiler-1"><span class="toc-number">2.2.</span> <span class="toc-text">DOMCompiler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scope-1"><span class="toc-number">2.3.</span> <span class="toc-text">Scope</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Directive"><span class="toc-number">2.4.</span> <span class="toc-text">Directive</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#一个完整的例子"><span class="toc-number">3.</span> <span class="toc-text">一个完整的例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结论"><span class="toc-number">4.</span> <span class="toc-text">结论</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/angularjs记录/" title="angularjs记录">angularjs记录<sup>9</sup></a></li>
		
			<li><a href="/categories/css/" title="css">css<sup>1</sup></a></li>
		
			<li><a href="/categories/iconfont技术/" title="iconfont技术">iconfont技术<sup>2</sup></a></li>
		
			<li><a href="/categories/javascript/" title="javascript">javascript<sup>18</sup></a></li>
		
			<li><a href="/categories/javascript/nodejs/" title="nodejs">nodejs<sup>2</sup></a></li>
		
			<li><a href="/categories/从零单排/" title="从零单排">从零单排<sup>1</sup></a></li>
		
			<li><a href="/categories/各种知识点记录/" title="各种知识点记录">各种知识点记录<sup>1</sup></a></li>
		
			<li><a href="/categories/javascript/源码分析/" title="源码分析">源码分析<sup>7</sup></a></li>
		
			<li><a href="/categories/系统环境/" title="系统环境">系统环境<sup>1</sup></a></li>
		
			<li><a href="/categories/angularjs记录/翻译/" title="翻译">翻译<sup>1</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/Filters/" title="Filters">Filters<sup>1</sup></a></li>
		
			<li><a href="/tags/analyze/" title="analyze">analyze<sup>1</sup></a></li>
		
			<li><a href="/tags/angular/" title="angular">angular<sup>2</sup></a></li>
		
			<li><a href="/tags/angularjs/" title="angularjs">angularjs<sup>7</sup></a></li>
		
			<li><a href="/tags/ast/" title="ast">ast<sup>1</sup></a></li>
		
			<li><a href="/tags/async/" title="async">async<sup>1</sup></a></li>
		
			<li><a href="/tags/border-shadow/" title="border-shadow">border-shadow<sup>1</sup></a></li>
		
			<li><a href="/tags/chunked/" title="chunked">chunked<sup>1</sup></a></li>
		
			<li><a href="/tags/class/" title="class">class<sup>1</sup></a></li>
		
			<li><a href="/tags/co/" title="co">co<sup>2</sup></a></li>
		
			<li><a href="/tags/comet/" title="comet">comet<sup>1</sup></a></li>
		
			<li><a href="/tags/controllers/" title="controllers">controllers<sup>1</sup></a></li>
		
			<li><a href="/tags/css3/" title="css3">css3<sup>1</sup></a></li>
		
			<li><a href="/tags/generator/" title="generator">generator<sup>1</sup></a></li>
		
			<li><a href="/tags/git/" title="git">git<sup>1</sup></a></li>
		
			<li><a href="/tags/gulp/" title="gulp">gulp<sup>1</sup></a></li>
		
			<li><a href="/tags/html/" title="html">html<sup>1</sup></a></li>
		
			<li><a href="/tags/iconfont/" title="iconfont">iconfont<sup>2</sup></a></li>
		
			<li><a href="/tags/javascript/" title="javascript">javascript<sup>15</sup></a></li>
		
			<li><a href="/tags/koa/" title="koa">koa<sup>2</sup></a></li>
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
      <li><a href="http://ued.taobao.com/" target="_blank">淘宝UED</a> </li>            <li><a href="http://www.aliued.com/" target="_blank">Alibaba国际站UED</a> </li>            <li><a href="http://china.aliued.com/" target="_blank">Alibaba中文站UED</a> </li>            <li><a href="http://ued.alipay.com/" target="_blank"> 支付宝UED</a> </li>            <li><a href="http://ued.tmall.com/" target="_blank">天猫UED</a> </li><li><a href="http://ur.alibaba-inc.com">阿里用户体验中心</a> </li>	 <li><a href="http://www.uisdc.com" target="_blank">优秀网页设计</a> </li>
      
    </ul>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
		<p class="copyright">Powered by <a href="http://zespia.tw/hexo/" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2016 
		
		<a href="http://purplebamboo.github.com" target="_blank" title="purplebamboo">purplebamboo</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"cherishpeace"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 






<script type="text/javascript">
  $(function(){
    window.onscroll = function(){
      //console.log($(document).scrollTop()+"px")
      $('.background-container .bg-dy2').css('backgroundPosition','0 '+$(document).scrollTop()+"px");
    }

  })
</script>
<div class="background-container">
  <div class="bg-dy1">

  </div>
  <div class="bg-dy2">

  </div>

</div

  </body>
</html>
