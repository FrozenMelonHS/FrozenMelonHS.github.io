
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>reactjs源码分析-上篇（首次渲染实现原理） | blog of purplebamboo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="purplebamboo">
    
    <meta name="description" content="reactjs是目前比较火的前端框架，但是目前并没有很好的解释原理的项目。reactjs源码比较复杂不适合初学者去学习。所以本文通过实现一套简易版的reactjs，使得理解原理更加容易。包括：

reactjs源码分析-上篇（首次渲染实现原理）
reactjs源码分析-下篇（更新机制实现原理）

声">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="blog of purplebamboo" title="blog of purplebamboo"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="blog of purplebamboo">blog of purplebamboo</a></h1>
				<h2 class="blog-motto">dota诚可贵，coding价更高，若为女朋友，二者皆可抛。</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/categories">分类</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:purplebamboo.github.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/09/15/reactjs_source_analyze_part_one/" title="reactjs源码分析-上篇（首次渲染实现原理）" itemprop="url">reactjs源码分析-上篇（首次渲染实现原理）</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://purplebamboo.github.com" title="purplebamboo">purplebamboo</a>
    </p>
  <p class="article-time">
    <time datetime="2015-09-15T05:23:08.000Z" itemprop="datePublished">9月 15 2015</time>
    更新日期:<time datetime="2015-09-15T05:38:09.000Z" itemprop="dateModified">9月 15 2015</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#先从最简单的开始"><span class="toc-number">2.</span> <span class="toc-text">先从最简单的开始</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#引入基本elemetnt"><span class="toc-number">3.</span> <span class="toc-text">引入基本elemetnt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义元素"><span class="toc-number">4.</span> <span class="toc-text">自定义元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结语"><span class="toc-number">5.</span> <span class="toc-text">结语</span></a></li></ol>
		</div>
		
		<p>reactjs是目前比较火的前端框架，但是目前并没有很好的解释原理的项目。reactjs源码比较复杂不适合初学者去学习。所以本文通过实现一套简易版的reactjs，使得理解原理更加容易。包括：</p>
<ul>
<li><a href="http://purplebamboo.github.io/2015/09/15/reactjs_source_analyze_part_one" target="_blank">reactjs源码分析-上篇（首次渲染实现原理）</a></li>
<li><a href="http://purplebamboo.github.io/2015/09/15/reactjs_source_analyze_part_two" target="_blank">reactjs源码分析-下篇（更新机制实现原理）</a></li>
</ul>
<p>声明：</p>
<ul>
<li>本文假定你已经对reactjs有了一定的了解，如果没有至少看下ruanyifeng老师的<a href="http://www.ruanyifeng.com/blog/2015/03/react.html" target="_blank">入门demo</a>。</li>
<li>jsx不在本文的讨论范围，所有的例子原理都是使用原生的javascript。</li>
<li>篇幅限制，服务器端的reactjs也不在本文讨论范围内。</li>
<li>为了演示方便，本文以jQuery作为基本工具库。</li>
<li>为了更清晰的演示原理，本文会忽略很多细节的东西，千万不要用于生产环境。</li>
</ul>
<p>所有实例源码都托管在github。<a href="https://github.com/purplebamboo/little-reactjs" target="_blank">点这里</a>里面有分步骤的例子，可以一边看一边运行例子。</p>
<h2 id="前言">前言</h2>
<p>前端的发展特别快，经历过jQuery一统天下的工具库时代后，现在各种框架又开始百家争鸣了。angular，ember，backbone，vue，avalon，ploymer还有reactjs，作为一个前端真是稍不留神就感觉要被淘汰了，就在去年大家还都是angularjs的粉丝，到了今年又开始各种狂追reactjs了。前端都是喜新厌旧的，不知道最后这些框架由谁来一统天下，用句很俗的话说，这是最好的时代也是最坏的时代。作为一个前端，只能多学点，尽量多的了解他们的原理。</p>
<p>reactjs的代码非常绕，对于没有后台开发经验的前端来说看起来会比较吃力。其实reactjs的核心内容并不多，主要是下面这些：</p>
<ul>
<li>虚拟dom对象(Virtual DOM)</li>
<li>虚拟dom差异化算法（diff algorithm）</li>
<li>单向数据流渲染（Data Flow）</li>
<li>组件生命周期</li>
<li>事件处理</li>
</ul>
<p>下面我们将一点点的来实现一个简易版的reactjs，实现上面的那些功能，最后用这个reactjs做一个todolist的小应用，看完这个，或者跟着敲一遍代码。希望让大家能够更好的理解reactjs的运行原理。</p>
<h2 id="先从最简单的开始">先从最简单的开始</h2>
<p>我们先从渲染hello world开始吧。</p>
<p>我们看下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>
&lt;script type="text/javascript"&gt;
React.render('hello world',document.getElementById("container"))
&lt;/script&gt;

/**
对应的html为

&lt;div id="container"&gt;&lt;/div&gt;


生成后的html为：

&lt;div id="container"&gt;
    &lt;span data-reactid="0"&gt;hello world&lt;/span&gt;
&lt;/div&gt;

*/
</pre></td></tr></table></figure>

<p>假定这一行代码,就可以把<code>hello world</code>渲染到对应的div里面。</p>
<p>我们来看看我们需要为此做些什么：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre>
<span class="comment">//component类，用来表示文本在渲染，更新，删除时应该做些什么事情</span>
<span class="function"><span class="keyword">function</span> <span class="title">ReactDOMTextComponent</span><span class="params">(text)</span> {</span>
    <span class="comment">//存下当前的字符串</span>
    <span class="keyword">this</span>._currentElement = <span class="string">''</span> + text;
    <span class="comment">//用来标识当前component</span>
    <span class="keyword">this</span>._rootNodeID = <span class="literal">null</span>;
}

<span class="comment">//component渲染时生成的dom结构</span>
ReactDOMTextComponent.prototype.mountComponent = <span class="function"><span class="keyword">function</span><span class="params">(rootID)</span> {</span>
    <span class="keyword">this</span>._rootNodeID = rootID;
    <span class="keyword">return</span> <span class="string">'&lt;span data-reactid="'</span> + rootID + <span class="string">'"&gt;'</span> + <span class="keyword">this</span>._currentElement + <span class="string">'&lt;/span&gt;'</span>;
}


<span class="comment">//component工厂  用来返回一个component实例</span>
<span class="function"><span class="keyword">function</span> <span class="title">instantiateReactComponent</span><span class="params">(node)</span>{</span>
    <span class="keyword">if</span>(<span class="keyword">typeof</span> node === <span class="string">'string'</span> || <span class="keyword">typeof</span> node === <span class="string">'number'</span>){
        <span class="keyword">return</span> <span class="keyword">new</span> ReactDOMTextComponent(node)
    }
}


React = {
    nextReactRootIndex:<span class="number">0</span>,
    render:<span class="function"><span class="keyword">function</span><span class="params">(element,container)</span>{</span>

        <span class="keyword">var</span> componentInstance = instantiateReactComponent(element);
        <span class="keyword">var</span> markup = componentInstance.mountComponent(React.nextReactRootIndex++);
        $(container).html(markup);
        <span class="comment">//触发完成mount的事件</span>
        $(document).trigger(<span class="string">'mountReady'</span>);    }
}
</pre></td></tr></table></figure>

<p>代码分为三个部分：</p>
<ol>
<li>React.render 作为入口负责调用渲染</li>
<li>我们引入了component类的概念，ReactDOMTextComponent是一个component类定义，定义对于这种<code>文本类型</code>的节点，在渲染，更新，删除时应该做什么操作，这边暂时只用到渲染，另外两个可以先忽略</li>
<li>instantiateReactComponent用来根据element的类型（现在只有一种string类型），返回一个component的实例。其实就是个类工厂。</li>
</ol>
<p>nextReactRootIndex作为每个component的标识id，不断加1，确保唯一性。这样我们以后可以通过这个标识找到这个元素。</p>
<p>可以看到我们把逻辑分为几个部分，主要的渲染逻辑放在了具体的componet类去定义。React.render负责调度整个流程，这里是调用instantiateReactComponent生成一个对应component类型的实例对象，然后调用此对象的mountComponent获取生成的内容。最后写到对应的container节点中。</p>
<p>可能有人问，这么p大点功能，有必要这么复杂嘛，别急。往下看才能体会这种分层的好处。</p>
<h2 id="引入基本elemetnt">引入基本elemetnt</h2>
<p>我们知道reactjs最大的卖点就是它的虚拟dom概念，我们一般使用<code>React.createElement</code>来创建一个虚拟dom元素。</p>
<p>虚拟dom元素分为两种，一种是浏览器自带的基本元素比如 div p input form 这种，一种是自定义的元素。</p>
<blockquote>
<p>这边需要说一下我们上节提到的文本节点，它不算虚拟dom，但是reacjs为了保持渲染的一致性。文本节点是在外面包了一层span标记，也给它配了个简化版component（ReactDOMTextComponent）。</p>
</blockquote>
<p>这节我们先讨论浏览器的基本元素。</p>
<p>在reactjs里，当我们希望在hello world外面包一层div,并且带上一些属性，甚至事件时我们可以这么写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre>
<span class="comment">//演示事件监听怎么用</span>
<span class="function"><span class="keyword">function</span> <span class="title">hello</span><span class="params">()</span>{</span>
    alert(<span class="string">'hello'</span>)
}


<span class="keyword">var</span> element = React.createElement(<span class="string">'div'</span>,{id:<span class="string">'test'</span>,onclick:hello},<span class="string">'click me'</span>)

React.render(element,document.getElementById(<span class="string">"container"</span>))


<span class="comment">/**

//生成的html为：

&lt;div data-reactid="0" id="test"&gt;
    &lt;span data-reactid="0.0"&gt;click me&lt;/span&gt;
&lt;/div&gt;


//点击文字，会弹出hello的对话框

*/</span>
</pre></td></tr></table></figure>

<p>上面使用<code>React.createElement</code>创建了一个基本元素，我们来看看简易版本<code>React.createElement</code>的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre></td><td class="code"><pre>
<span class="comment">//ReactElement就是虚拟dom的概念，具有一个type属性代表当前的节点类型，还有节点的属性props</span>
<span class="comment">//比如对于div这样的节点type就是div，props就是那些attributes</span>
<span class="comment">//另外这里的key,可以用来标识这个element，用于优化以后的更新，这里可以先不管，知道有这么个东西就好了</span>
<span class="function"><span class="keyword">function</span> <span class="title">ReactElement</span><span class="params">(type,key,props)</span>{</span>
  <span class="keyword">this</span>.type = type;
  <span class="keyword">this</span>.key = key;
  <span class="keyword">this</span>.props = props;
}


React = {
    nextReactRootIndex:<span class="number">0</span>,
    createElement:<span class="function"><span class="keyword">function</span><span class="params">(type,config,children)</span>{</span>
        <span class="keyword">var</span> props = {},propName;
        config = config || {}
        <span class="comment">//看有没有key，用来标识element的类型，方便以后高效的更新，这里可以先不管</span>
        <span class="keyword">var</span> key = config.key || <span class="literal">null</span>;

        <span class="comment">//复制config里的内容到props</span>
        <span class="keyword">for</span> (propName <span class="keyword">in</span> config) {
            <span class="keyword">if</span> (config.hasOwnProperty(propName) && propName !== <span class="string">'key'</span>) {
                props[propName] = config[propName];
            }
        }

        <span class="comment">//处理children,全部挂载到props的children属性上</span>
        <span class="comment">//支持两种写法，如果只有一个参数，直接赋值给children，否则做合并处理</span>
        <span class="keyword">var</span> childrenLength = <span class="built_in">arguments</span>.length - <span class="number">2</span>;
        <span class="keyword">if</span> (childrenLength === <span class="number">1</span>) {
            props.children = $.isArray(children) ? children : [children] ;
        } <span class="keyword">else</span> <span class="keyword">if</span> (childrenLength &gt; <span class="number">1</span>) {
            <span class="keyword">var</span> childArray = <span class="built_in">Array</span>(childrenLength);
            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; childrenLength; i++) {
                childArray[i] = <span class="built_in">arguments</span>[i + <span class="number">2</span>];
            }
            props.children = childArray;
        }

        <span class="keyword">return</span> <span class="keyword">new</span> ReactElement(type, key,props);

    },
    render:<span class="function"><span class="keyword">function</span><span class="params">(element,container)</span>{</span>
        <span class="keyword">var</span> componentInstance = instantiateReactComponent(element);
        <span class="keyword">var</span> markup = componentInstance.mountComponent(React.nextReactRootIndex++);
        $(container).html(markup);
        <span class="comment">//触发完成mount的事件</span>
        $(document).trigger(<span class="string">'mountReady'</span>);
    }
}
</pre></td></tr></table></figure>

<p>createElement只是做了简单的参数修正，最终返回一个ReactElement实例对象也就是我们说的虚拟元素的实例。</p>
<blockquote>
<p>这里注意key的定义，主要是为了以后更新时优化效率，这边可以先不管忽略。</p>
</blockquote>
<p>好了有了元素实例，我们得把他渲染出来，此时render接受的是一个ReactElement而不是文本，我们先改造下instantiateReactComponent：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>
<span class="function"><span class="keyword">function</span> <span class="title">instantiateReactComponent</span><span class="params">(node)</span>{</span>
    <span class="comment">//文本节点的情况</span>
    <span class="keyword">if</span>(<span class="keyword">typeof</span> node === <span class="string">'string'</span> || <span class="keyword">typeof</span> node === <span class="string">'number'</span>){
        <span class="keyword">return</span> <span class="keyword">new</span> ReactDOMTextComponent(node);
    }
    <span class="comment">//浏览器默认节点的情况</span>
    <span class="keyword">if</span>(<span class="keyword">typeof</span> node === <span class="string">'object'</span> && <span class="keyword">typeof</span> node.type === <span class="string">'string'</span>){
        <span class="comment">//注意这里，使用了一种新的component</span>
        <span class="keyword">return</span> <span class="keyword">new</span> ReactDOMComponent(node);

    }
}
</pre></td></tr></table></figure>

<p>我们增加了一个判断，这样当render的不是文本而是浏览器的基本元素时。我们使用另外一种component来处理它渲染时应该返回的内容。这里就体现了工厂方法instantiateReactComponent的好处了，不管来了什么类型的node，都可以负责生产出一个负责渲染的component实例。这样render完全不需要做任何修改，只需要再做一种对应的component类型（这里是ReactDOMComponent）就行了。</p>
<p>所以重点我们来看看<code>ReactDOMComponent</code>的具体实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
</pre></td><td class="code"><pre>
<span class="comment">//component类，用来表示文本在渲染，更新，删除时应该做些什么事情</span>
<span class="function"><span class="keyword">function</span> <span class="title">ReactDOMComponent</span><span class="params">(element)</span>{</span>
    <span class="comment">//存下当前的element对象引用</span>
    <span class="keyword">this</span>._currentElement = element;
    <span class="keyword">this</span>._rootNodeID = <span class="literal">null</span>;
}

<span class="comment">//component渲染时生成的dom结构</span>
ReactDOMComponent.prototype.mountComponent = <span class="function"><span class="keyword">function</span><span class="params">(rootID)</span>{</span>
    <span class="comment">//赋值标识</span>
    <span class="keyword">this</span>._rootNodeID = rootID;
    <span class="keyword">var</span> props = <span class="keyword">this</span>._currentElement.props;
    <span class="keyword">var</span> tagOpen = <span class="string">'&lt;'</span> + <span class="keyword">this</span>._currentElement.type;
    <span class="keyword">var</span> tagClose = <span class="string">'&lt;/'</span> + <span class="keyword">this</span>._currentElement.type + <span class="string">'&gt;'</span>;

    <span class="comment">//加上reactid标识</span>
    tagOpen += <span class="string">' data-reactid='</span> + <span class="keyword">this</span>._rootNodeID;

    <span class="comment">//拼凑出属性</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> propKey <span class="keyword">in</span> props) {

        <span class="comment">//这里要做一下事件的监听，就是从属性props里面解析拿出on开头的事件属性的对应事件监听</span>
        <span class="keyword">if</span> (<span class="regexp">/^on[A-Za-z]/</span>.test(propKey)) {
            <span class="keyword">var</span> eventType = propKey.replace(<span class="string">'on'</span>, <span class="string">''</span>);
            <span class="comment">//针对当前的节点添加事件代理,以_rootNodeID为命名空间</span>
            $(document).delegate(<span class="string">'[data-reactid="'</span> + <span class="keyword">this</span>._rootNodeID + <span class="string">'"]'</span>, eventType + <span class="string">'.'</span> + <span class="keyword">this</span>._rootNodeID, props[propKey]);
        }

        <span class="comment">//对于children属性以及事件监听的属性不需要进行字符串拼接</span>
        <span class="comment">//事件会代理到全局。这边不能拼到dom上不然会产生原生的事件监听</span>
        <span class="keyword">if</span> (props[propKey] && propKey != <span class="string">'children'</span> && !<span class="regexp">/^on[A-Za-z]/</span>.test(propKey)) {
            tagOpen += <span class="string">' '</span> + propKey + <span class="string">'='</span> + props[propKey];
        }
    }
    <span class="comment">//获取子节点渲染出的内容</span>
    <span class="keyword">var</span> content = <span class="string">''</span>;
    <span class="keyword">var</span> children = props.children || [];

    <span class="keyword">var</span> childrenInstances = []; <span class="comment">//用于保存所有的子节点的componet实例，以后会用到</span>
    <span class="keyword">var</span> that = <span class="keyword">this</span>;
    $.each(children, <span class="function"><span class="keyword">function</span><span class="params">(key, child)</span> {</span>
        <span class="comment">//这里再次调用了instantiateReactComponent实例化子节点component类，拼接好返回</span>
        <span class="keyword">var</span> childComponentInstance = instantiateReactComponent(child);
        childComponentInstance._mountIndex = key;

        childrenInstances.push(childComponentInstance);
        <span class="comment">//子节点的rootId是父节点的rootId加上新的key也就是顺序的值拼成的新值</span>
        <span class="keyword">var</span> curRootId = that._rootNodeID + <span class="string">'.'</span> + key;
        <span class="comment">//得到子节点的渲染内容</span>
        <span class="keyword">var</span> childMarkup = childComponentInstance.mountComponent(curRootId);
        <span class="comment">//拼接在一起</span>
        content += <span class="string">' '</span> + childMarkup;

    })

    <span class="comment">//留给以后更新时用的这边先不用管</span>
    <span class="keyword">this</span>._renderedChildren = childrenInstances;

    <span class="comment">//拼出整个html内容</span>
    <span class="keyword">return</span> tagOpen + <span class="string">'&gt;'</span> + content + tagClose;
}
</pre></td></tr></table></figure>

<p>我们增加了虚拟dom reactElement的定义，增加了一个新的componet类ReactDOMComponent。<br>这样我们就实现了渲染浏览器基本元素的功能了。</p>
<p>对于虚拟dom的渲染逻辑，本质上还是个递归渲染的东西，reactElement会递归渲染自己的子节点。可以看到我们通过instantiateReactComponent屏蔽了子节点的差异，只需要使用不同的componet类，这样都能保证通过mountComponent最终拿到渲染后的内容。</p>
<p>另外这边的事件也要说下，可以在传递props的时候传入{onClick:function(){}}这样的参数，这样就会在当前元素上添加事件，代理到document。由于reactjs本身全是在写js，所以监听的函数的传递变得特别简单。</p>
<blockquote>
<p>这里很多东西没有考虑，比如一些特殊的类型input select等等，再比如img不需要有对应的tagClose等。这里为了保持简单就不再扩展了。另外reactjs的事件处理其实很复杂，实现了一套标准的w3c事件。这里偷懒直接使用jQuery的事件代理到document上了。</p>
</blockquote>
<h2 id="自定义元素">自定义元素</h2>
<p>上面实现了基本的元素内容，我们下面实现自定义元素的功能。</p>
<p>随着前端技术的发展浏览器的那些基本元素已经满足不了我们的需求了，如果你对<a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components" target="_blank">webcomponents</a>有一定的了解，就会知道人们一直在尝试扩展一些自己的标记。</p>
<p>reactjs通过虚拟dom做到了类似的功能，还记得我们上面element.type只是个简单的字符串，如果是个类呢？如果这个类恰好还有自己的生命周期管理，那扩展性就很高了。</p>
<blockquote>
<p>如果对生命周期等概念不是很理解的，可以看看我以前的另一片文章：<a href="http://www.html-js.com/article/2760" target="_blank">javascript组件化</a></p>
</blockquote>
<p>我们看下reactjs怎么使用自定义元素：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre>
<span class="keyword">var</span> HelloMessage = React.createClass({
  getInitialState: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> {type: <span class="string">'say:'</span>};
  },
  componentWillMount: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    console.log(<span class="string">'我就要开始渲染了。。。'</span>)
  },
  componentDidMount: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    console.log(<span class="string">'我已经渲染好了。。。'</span>)
  },
  render: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> React.createElement(<span class="string">"div"</span>, <span class="literal">null</span>,<span class="keyword">this</span>.state.type, <span class="string">"Hello "</span>, <span class="keyword">this</span>.props.name);
  }
});


React.render(React.createElement(HelloMessage, {name: <span class="string">"John"</span>}), document.getElementById(<span class="string">"container"</span>));

<span class="comment">/**
结果为：

html:
&lt;div data-reactid="0"&gt;
    &lt;span data-reactid="0.0"&gt;say:&lt;/span&gt;
    &lt;span data-reactid="0.1"&gt;Hello &lt;/span&gt;
    &lt;span data-reactid="0.2"&gt;John&lt;/span&gt;
&lt;/div&gt;

console:
我就要开始渲染了。。。
我已经渲染好了。。。

*/</span>
</pre></td></tr></table></figure>

<p><code>React.createElement</code>接受的不再是字符串，而是一个class。</p>
<p><code>React.createClass</code>生成一个自定义标记类，带有基本的生命周期：</p>
<ul>
<li>getInitialState 获取最初的属性值this.state</li>
<li>componentWillmount 在组件准备渲染时调用</li>
<li>componentDidMount 在组件渲染完成后调用</li>
</ul>
<p>对reactjs稍微有点了解的应该都可以明白上面的用法。</p>
<p>我们先来看看React.createClass的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre>
<span class="comment">//定义ReactClass类,所有自定义的超级父类</span>
<span class="keyword">var</span> ReactClass = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
}
<span class="comment">//留给子类去继承覆盖</span>
ReactClass.prototype.render = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>}



React = {
    nextReactRootIndex:<span class="number">0</span>,
    createClass:<span class="function"><span class="keyword">function</span><span class="params">(spec)</span>{</span>
        <span class="comment">//生成一个子类</span>
        <span class="keyword">var</span> Constructor = <span class="function"><span class="keyword">function</span> <span class="params">(props)</span> {</span>
            <span class="keyword">this</span>.props = props;
            <span class="keyword">this</span>.state = <span class="keyword">this</span>.getInitialState ? <span class="keyword">this</span>.getInitialState() : <span class="literal">null</span>;
        }
        <span class="comment">//原型继承，继承超级父类</span>
        Constructor.prototype = <span class="keyword">new</span> ReactClass();
        Constructor.prototype.constructor = Constructor;
        <span class="comment">//混入spec到原型</span>
        $.extend(Constructor.prototype,spec);
        <span class="keyword">return</span> Constructor;

    },
    createElement:<span class="function"><span class="keyword">function</span><span class="params">(type,config,children)</span>{</span>
        ...
    },
    render:<span class="function"><span class="keyword">function</span><span class="params">(element,container)</span>{</span>
        ...
    }
}
</pre></td></tr></table></figure>

<p>可以看到createClass生成了一个继承ReactClass的子类，在构造函数里调用this.getInitialState获得最初的state。</p>
<blockquote>
<p>为了演示方便,我们这边的ReactClass相当简单，实际上原始的代码处理了很多东西，比如类的mixin的组合继承支持,比如componentDidMount等可以定义多次，需要合并调用等等，有兴趣的去翻源码吧，不是本文的主要目的，这里就不详细展开了。</p>
</blockquote>
<p>我们这里只是返回了一个继承类的定义，那么具体的componentWillmount，这些生命周期函数在哪里调用呢。</p>
<p>看看我们上面的两种类型就知道，我们是时候为自定义元素也提供一个componet类了，在那个类里我们会实例化ReactClass，并且管理生命周期，还有父子组件依赖。</p>
<p>好，我们老规矩先改造instantiateReactComponent</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">instantiateReactComponent</span><span class="params">(node)</span>{</span>
    <span class="comment">//文本节点的情况</span>
    <span class="keyword">if</span>(<span class="keyword">typeof</span> node === <span class="string">'string'</span> || <span class="keyword">typeof</span> node === <span class="string">'number'</span>){
        <span class="keyword">return</span> <span class="keyword">new</span> ReactDOMTextComponent(node);
    }
    <span class="comment">//浏览器默认节点的情况</span>
    <span class="keyword">if</span>(<span class="keyword">typeof</span> node === <span class="string">'object'</span> && <span class="keyword">typeof</span> node.type === <span class="string">'string'</span>){
        <span class="comment">//注意这里，使用了一种新的component</span>
        <span class="keyword">return</span> <span class="keyword">new</span> ReactDOMComponent(node);

    }
    <span class="comment">//自定义的元素节点</span>
    <span class="keyword">if</span>(<span class="keyword">typeof</span> node === <span class="string">'object'</span> && <span class="keyword">typeof</span> node.type === <span class="string">'function'</span>){
        <span class="comment">//注意这里，使用新的component,专门针对自定义元素</span>
        <span class="keyword">return</span> <span class="keyword">new</span> ReactCompositeComponent(node);

    }
}
</pre></td></tr></table></figure>

<p>很简单我们增加了一个判断，使用新的component类形来处理自定义的节点。我们看下<br>ReactCompositeComponent的具体实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre>
<span class="function"><span class="keyword">function</span> <span class="title">ReactCompositeComponent</span><span class="params">(element)</span>{</span>
    <span class="comment">//存放元素element对象</span>
    <span class="keyword">this</span>._currentElement = element;
    <span class="comment">//存放唯一标识</span>
    <span class="keyword">this</span>._rootNodeID = <span class="literal">null</span>;
    <span class="comment">//存放对应的ReactClass的实例</span>
    <span class="keyword">this</span>._instance = <span class="literal">null</span>;
}

<span class="comment">//用于返回当前自定义元素渲染时应该返回的内容</span>
ReactCompositeComponent.prototype.mountComponent = <span class="function"><span class="keyword">function</span><span class="params">(rootID)</span>{</span>
    <span class="keyword">this</span>._rootNodeID = rootID;
    <span class="comment">//拿到当前元素对应的属性值</span>
    <span class="keyword">var</span> publicProps = <span class="keyword">this</span>._currentElement.props;
    <span class="comment">//拿到对应的ReactClass</span>
    <span class="keyword">var</span> ReactClass = <span class="keyword">this</span>._currentElement.type;
    <span class="comment">// Initialize the public class</span>
    <span class="keyword">var</span> inst = <span class="keyword">new</span> ReactClass(publicProps);
    <span class="keyword">this</span>._instance = inst;
    <span class="comment">//保留对当前comonent的引用，下面更新会用到</span>
    inst._reactInternalInstance = <span class="keyword">this</span>;

    <span class="keyword">if</span> (inst.componentWillMount) {
        inst.componentWillMount();
        <span class="comment">//这里在原始的reactjs其实还有一层处理，就是  componentWillMount调用setstate，不会触发rerender而是自动提前合并，这里为了保持简单，就略去了</span>
    }
    <span class="comment">//调用ReactClass的实例的render方法,返回一个element或者一个文本节点</span>
    <span class="keyword">var</span> renderedElement = <span class="keyword">this</span>._instance.render();
    <span class="comment">//得到renderedElement对应的component类实例</span>
    <span class="keyword">var</span> renderedComponentInstance = instantiateReactComponent(renderedElement);
    <span class="keyword">this</span>._renderedComponent = renderedComponentInstance; <span class="comment">//存起来留作后用</span>

    <span class="comment">//拿到渲染之后的字符串内容，将当前的_rootNodeID传给render出的节点</span>
    <span class="keyword">var</span> renderedMarkup = renderedComponentInstance.mountComponent(<span class="keyword">this</span>._rootNodeID);

    <span class="comment">//之前我们在React.render方法最后触发了mountReady事件，所以这里可以监听，在渲染完成后会触发。</span>
    $(document).on(<span class="string">'mountReady'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="comment">//调用inst.componentDidMount</span>
        inst.componentDidMount && inst.componentDidMount();
    });

    <span class="keyword">return</span> renderedMarkup;
}
</pre></td></tr></table></figure>

<p>实现并不难，ReactClass的render一定是返回一个虚拟节点(包括element和text)，这个时候我们使用instantiateReactComponent去得到实例，再使用mountComponent拿到结果作为当前自定义元素的结果。</p>
<p>应该说本身自定义元素不负责具体的内容，他更多的是负责生命周期。具体的内容是由它的render方法返回的虚拟节点来负责渲染的。</p>
<p>本质上也是递归的去渲染内容的过程。同时因为这种递归的特性，父组件的componentWillMount一定在某个子组件的componentWillMount之前调用，而父组件的componentDidMount肯定在子组件之后，因为监听mountReady事件，肯定是子组件先监听的。</p>
<blockquote>
<p>需要注意的是自定义元素并不会处理我们createElement时传入的子节点，它只会处理自己render返回的节点作为自己的子节点。不过我们在render时可以使用this.props.children拿到那些传入的子节点，可以自己处理。其实有点类似webcomponents里面的shadow dom的作用。</p>
</blockquote>
<p>上面实现了三种类型的元素，其实我们发现本质上没有太大的区别，都是有自己对应component类来处理自己的渲染过程。</p>
<p>大概的关系是下面这样。</p>
<p><img src="https://img.alicdn.com/tps/TB1NPA_JpXXXXcVXXXXXXXXXXXX-1024-768.jpg" alt="结构图"></p>
<p>于是我们发现初始化的渲染流程都已经完成了。</p>
<h2 id="结语">结语</h2>
<p>整个初次渲染的流程基本就分析完毕了。看看我们目前的进展，事件监听做了，虚拟dom有了。基本的组件生命周期也有了。我们这个小玩具已经可以简单跑跑了。下篇文章我们将一起去实现reactjs的更新机制，看看它最核心的diff算法是怎么回事。</p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/reactjs/">reactjs</a><a href="/tags/源码分析/">源码分析</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/javascript/">javascript</a>►<a class="article-category-link" href="/categories/javascript/源码分析/">源码分析</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://purplebamboo.github.com/2015/09/15/reactjs_source_analyze_part_one/" data-title="reactjs源码分析-上篇（首次渲染实现原理） | blog of purplebamboo" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/09/15/reactjs_source_analyze_part_two/" title="reactjs源码分析-下篇（更新机制实现原理）">
  <strong>PREVIOUS:</strong><br/>
  <span>
  reactjs源码分析-下篇（更新机制实现原理）</span>
</a>
</div>


<div class="next">
<a href="/2015/06/21/how-to-make-a-barrage/"  title="弹幕实现">
 <strong>NEXT:</strong><br/> 
 <span>弹幕实现
</span>
</a>
</div>

</nav>

	
<section class="comment">
	<div class="ds-thread"></div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#先从最简单的开始"><span class="toc-number">2.</span> <span class="toc-text">先从最简单的开始</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#引入基本elemetnt"><span class="toc-number">3.</span> <span class="toc-text">引入基本elemetnt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义元素"><span class="toc-number">4.</span> <span class="toc-text">自定义元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结语"><span class="toc-number">5.</span> <span class="toc-text">结语</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/angularjs记录/" title="angularjs记录">angularjs记录<sup>9</sup></a></li>
		
			<li><a href="/categories/css/" title="css">css<sup>1</sup></a></li>
		
			<li><a href="/categories/iconfont技术/" title="iconfont技术">iconfont技术<sup>2</sup></a></li>
		
			<li><a href="/categories/javascript/" title="javascript">javascript<sup>18</sup></a></li>
		
			<li><a href="/categories/javascript/nodejs/" title="nodejs">nodejs<sup>2</sup></a></li>
		
			<li><a href="/categories/从零单排/" title="从零单排">从零单排<sup>1</sup></a></li>
		
			<li><a href="/categories/各种知识点记录/" title="各种知识点记录">各种知识点记录<sup>1</sup></a></li>
		
			<li><a href="/categories/javascript/源码分析/" title="源码分析">源码分析<sup>7</sup></a></li>
		
			<li><a href="/categories/系统环境/" title="系统环境">系统环境<sup>1</sup></a></li>
		
			<li><a href="/categories/angularjs记录/翻译/" title="翻译">翻译<sup>1</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/Filters/" title="Filters">Filters<sup>1</sup></a></li>
		
			<li><a href="/tags/analyze/" title="analyze">analyze<sup>1</sup></a></li>
		
			<li><a href="/tags/angular/" title="angular">angular<sup>2</sup></a></li>
		
			<li><a href="/tags/angularjs/" title="angularjs">angularjs<sup>7</sup></a></li>
		
			<li><a href="/tags/ast/" title="ast">ast<sup>1</sup></a></li>
		
			<li><a href="/tags/async/" title="async">async<sup>1</sup></a></li>
		
			<li><a href="/tags/border-shadow/" title="border-shadow">border-shadow<sup>1</sup></a></li>
		
			<li><a href="/tags/chunked/" title="chunked">chunked<sup>1</sup></a></li>
		
			<li><a href="/tags/class/" title="class">class<sup>1</sup></a></li>
		
			<li><a href="/tags/co/" title="co">co<sup>2</sup></a></li>
		
			<li><a href="/tags/comet/" title="comet">comet<sup>1</sup></a></li>
		
			<li><a href="/tags/controllers/" title="controllers">controllers<sup>1</sup></a></li>
		
			<li><a href="/tags/css3/" title="css3">css3<sup>1</sup></a></li>
		
			<li><a href="/tags/generator/" title="generator">generator<sup>1</sup></a></li>
		
			<li><a href="/tags/git/" title="git">git<sup>1</sup></a></li>
		
			<li><a href="/tags/gulp/" title="gulp">gulp<sup>1</sup></a></li>
		
			<li><a href="/tags/html/" title="html">html<sup>1</sup></a></li>
		
			<li><a href="/tags/iconfont/" title="iconfont">iconfont<sup>2</sup></a></li>
		
			<li><a href="/tags/javascript/" title="javascript">javascript<sup>15</sup></a></li>
		
			<li><a href="/tags/koa/" title="koa">koa<sup>2</sup></a></li>
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
      <li><a href="http://ued.taobao.com/" target="_blank">淘宝UED</a> </li>            <li><a href="http://www.aliued.com/" target="_blank">Alibaba国际站UED</a> </li>            <li><a href="http://china.aliued.com/" target="_blank">Alibaba中文站UED</a> </li>            <li><a href="http://ued.alipay.com/" target="_blank"> 支付宝UED</a> </li>            <li><a href="http://ued.tmall.com/" target="_blank">天猫UED</a> </li><li><a href="http://ur.alibaba-inc.com">阿里用户体验中心</a> </li>	 <li><a href="http://www.uisdc.com" target="_blank">优秀网页设计</a> </li>
      
    </ul>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
		<p class="copyright">Powered by <a href="http://zespia.tw/hexo/" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2016 
		
		<a href="http://purplebamboo.github.com" target="_blank" title="purplebamboo">purplebamboo</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"cherishpeace"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 






<script type="text/javascript">
  $(function(){
    window.onscroll = function(){
      //console.log($(document).scrollTop()+"px")
      $('.background-container .bg-dy2').css('backgroundPosition','0 '+$(document).scrollTop()+"px");
    }

  })
</script>
<div class="background-container">
  <div class="bg-dy1">

  </div>
  <div class="bg-dy2">

  </div>

</div

  </body>
</html>
