
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>reactjs源码分析-下篇（更新机制实现原理） | blog of purplebamboo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="purplebamboo">
    
    <meta name="description" content="reactjs是目前比较火的前端框架，但是目前并没有很好的解释原理的项目。reactjs源码比较复杂不适合初学者去学习。所以本文通过实现一套简易版的reactjs，使得理解原理更加容易。包括：

reactjs源码分析-上篇（首次渲染实现原理）
reactjs源码分析-下篇（更新机制实现原理）

声">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="blog of purplebamboo" title="blog of purplebamboo"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="blog of purplebamboo">blog of purplebamboo</a></h1>
				<h2 class="blog-motto">dota诚可贵，coding价更高，若为女朋友，二者皆可抛。</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/categories">分类</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:purplebamboo.github.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/09/15/reactjs_source_analyze_part_two/" title="reactjs源码分析-下篇（更新机制实现原理）" itemprop="url">reactjs源码分析-下篇（更新机制实现原理）</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://purplebamboo.github.com" title="purplebamboo">purplebamboo</a>
    </p>
  <p class="article-time">
    <time datetime="2015-09-15T05:23:13.000Z" itemprop="datePublished">9月 15 2015</time>
    更新日期:<time datetime="2015-09-15T05:39:52.000Z" itemprop="dateModified">9月 15 2015</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现更新机制"><span class="toc-number">2.</span> <span class="toc-text">实现更新机制</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义元素的receiveComponent"><span class="toc-number">2.1.</span> <span class="toc-text">自定义元素的receiveComponent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文本节点的receiveComponent"><span class="toc-number">2.2.</span> <span class="toc-text">文本节点的receiveComponent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本元素element的receiveComponent"><span class="toc-number">2.3.</span> <span class="toc-text">基本元素element的receiveComponent</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#小试牛刀"><span class="toc-number">3.</span> <span class="toc-text">小试牛刀</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#结语"><span class="toc-number"></span> <span class="toc-text">结语</span></a></li></ol>
		</div>
		
		<p>reactjs是目前比较火的前端框架，但是目前并没有很好的解释原理的项目。reactjs源码比较复杂不适合初学者去学习。所以本文通过实现一套简易版的reactjs，使得理解原理更加容易。包括：</p>
<ul>
<li><a href="http://purplebamboo.github.io/2015/09/15/reactjs_source_analyze_part_one" target="_blank">reactjs源码分析-上篇（首次渲染实现原理）</a></li>
<li><a href="http://purplebamboo.github.io/2015/09/15/reactjs_source_analyze_part_two" target="_blank">reactjs源码分析-下篇（更新机制实现原理）</a></li>
</ul>
<p>声明：</p>
<ul>
<li>本文假定你已经对reactjs有了一定的了解，如果没有至少看下ruanyifeng老师的<a href="http://www.ruanyifeng.com/blog/2015/03/react.html" target="_blank">入门demo</a>。</li>
<li>jsx不在本文的讨论范围，所有的例子原理都是使用原生的javascript。</li>
<li>篇幅限制，服务器端的reactjs也不在本文讨论范围内。</li>
<li>为了演示方便，本文以jQuery作为基本工具库。</li>
<li>为了更清晰的演示原理，本文会忽略很多细节的东西，千万不要用于生产环境。</li>
</ul>
<p>所有实例源码都托管在github。<a href="https://github.com/purplebamboo/little-reactjs" target="_blank">点这里</a>里面有分步骤的例子，可以一边看一边运行例子。</p>
<h2 id="前言">前言</h2>
<p>紧接上文，虚拟dom差异化算法（diff algorithm）是reactjs最核心的东西，按照官方的说法。他非常快，非常高效。目前已经有一些分析此算法的文章，但是仅仅停留在表面。大部分小白看完并不能了解（博主就是 ＝ ＝）。所以我们下面自己动手实现一遍，等你完全实现了，再去看那些文字图片流的介绍文章，就会发现容易理解多了。</p>
<h2 id="实现更新机制">实现更新机制</h2>
<p>下面我们探讨下更新的机制。</p>
<p>一般在reactjs中我们需要更新时都是调用的setState。看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre>
<span class="keyword">var</span> HelloMessage = React.createClass({
  getInitialState: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> {type: <span class="string">'say:'</span>};
  },
  changeType:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">this</span>.setState({type:<span class="string">'shout:'</span>})
  },
  render: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> React.createElement(<span class="string">"div"</span>, {onclick:<span class="keyword">this</span>.changeType},<span class="keyword">this</span>.state.type, <span class="string">"Hello "</span>, <span class="keyword">this</span>.props.name);
  }
});


React.render(React.createElement(HelloMessage, {name: <span class="string">"John"</span>}), document.getElementById(<span class="string">"container"</span>));



<span class="comment">/**

//生成的html为：

&lt;div data-reactid="0" id="test"&gt;
    &lt;span data-reactid="0.0"&gt;hello world&lt;/span&gt;
&lt;/div&gt;

点击文字，say会变成shout

*/</span>
</pre></td></tr></table></figure>

<p>点击文字，调用setState就会更新，所以我们扩展下ReactClass，看下setState的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>
<span class="comment">//定义ReactClass类</span>
<span class="keyword">var</span> ReactClass = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
}

ReactClass.prototype.render = <span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>}

<span class="comment">//setState</span>
ReactClass.prototype.setState = <span class="function"><span class="keyword">function</span><span class="params">(newState)</span> {</span>

    <span class="comment">//还记得我们在ReactCompositeComponent里面mount的时候 做了赋值</span>
    <span class="comment">//所以这里可以拿到 对应的ReactCompositeComponent的实例_reactInternalInstance</span>
    <span class="keyword">this</span>._reactInternalInstance.receiveComponent(<span class="literal">null</span>, newState);
}
</pre></td></tr></table></figure>

<p>可以看到setState主要调用了对应的component的receiveComponent来实现更新。所有的挂载，更新都应该交给对应的component来管理。</p>
<p>就像所有的component都实现了mountComponent来处理第一次渲染，所有的componet类都应该实现receiveComponent用来处理自己的更新。</p>
<h3 id="自定义元素的receiveComponent">自定义元素的receiveComponent</h3>
<p>所以我们照葫芦画瓢来给自定义元素的对应component类（ReactCompositeComponent）实现一个receiveComponent方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
</pre></td><td class="code"><pre>
<span class="comment">//更新</span>
ReactCompositeComponent.prototype.receiveComponent = <span class="function"><span class="keyword">function</span><span class="params">(nextElement, newState)</span> {</span>

    <span class="comment">//如果接受了新的，就使用最新的element</span>
    <span class="keyword">this</span>._currentElement = nextElement || <span class="keyword">this</span>._currentElement

    <span class="keyword">var</span> inst = <span class="keyword">this</span>._instance;
    <span class="comment">//合并state</span>
    <span class="keyword">var</span> nextState = $.extend(inst.state, newState);
    <span class="keyword">var</span> nextProps = <span class="keyword">this</span>._currentElement.props;


    <span class="comment">//改写state</span>
    inst.state = nextState;


    <span class="comment">//如果inst有shouldComponentUpdate并且返回false。说明组件本身判断不要更新，就直接返回。</span>
    <span class="keyword">if</span> (inst.shouldComponentUpdate && (inst.shouldComponentUpdate(nextProps, nextState) === <span class="literal">false</span>)) <span class="keyword">return</span>;

    <span class="comment">//生命周期管理，如果有componentWillUpdate，就调用，表示开始要更新了。</span>
    <span class="keyword">if</span> (inst.componentWillUpdate) inst.componentWillUpdate(nextProps, nextState);


    <span class="keyword">var</span> prevComponentInstance = <span class="keyword">this</span>._renderedComponent;
    <span class="keyword">var</span> prevRenderedElement = prevComponentInstance._currentElement;
    <span class="comment">//重新执行render拿到对应的新element;</span>
    <span class="keyword">var</span> nextRenderedElement = <span class="keyword">this</span>._instance.render();


    <span class="comment">//判断是需要更新还是直接就重新渲染</span>
    <span class="comment">//注意这里的_shouldUpdateReactComponent跟上面的不同哦 这个是全局的方法</span>
    <span class="keyword">if</span> (_shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
        <span class="comment">//如果需要更新，就继续调用子节点的receiveComponent的方法，传入新的element更新子节点。</span>
        prevComponentInstance.receiveComponent(nextRenderedElement);
        <span class="comment">//调用componentDidUpdate表示更新完成了</span>
        inst.componentDidUpdate && inst.componentDidUpdate();

    } <span class="keyword">else</span> {
        <span class="comment">//如果发现完全是不同的两种element，那就干脆重新渲染了</span>
        <span class="keyword">var</span> thisID = <span class="keyword">this</span>._rootNodeID;
        <span class="comment">//重新new一个对应的component，</span>
        <span class="keyword">this</span>._renderedComponent = <span class="keyword">this</span>._instantiateReactComponent(nextRenderedElement);
        <span class="comment">//重新生成对应的元素内容</span>
        <span class="keyword">var</span> nextMarkup = _renderedComponent.mountComponent(thisID);
        <span class="comment">//替换整个节点</span>
        $(<span class="string">'[data-reactid="'</span> + <span class="keyword">this</span>._rootNodeID + <span class="string">'"]'</span>).replaceWith(nextMarkup);

    }

}

<span class="comment">//用来判定两个element需不需要更新</span>
<span class="comment">//这里的key是我们createElement的时候可以选择性的传入的。用来标识这个element，当发现key不同时，我们就可以直接重新渲染，不需要去更新了。</span>
<span class="keyword">var</span> _shouldUpdateReactComponent ＝ <span class="function"><span class="keyword">function</span><span class="params">(prevElement, nextElement)</span>{</span>
    <span class="keyword">if</span> (prevElement != <span class="literal">null</span> && nextElement != <span class="literal">null</span>) {
    <span class="keyword">var</span> prevType = <span class="keyword">typeof</span> prevElement;
    <span class="keyword">var</span> nextType = <span class="keyword">typeof</span> nextElement;
    <span class="keyword">if</span> (prevType === <span class="string">'string'</span> || prevType === <span class="string">'number'</span>) {
      <span class="keyword">return</span> nextType === <span class="string">'string'</span> || nextType === <span class="string">'number'</span>;
    } <span class="keyword">else</span> {
      <span class="keyword">return</span> nextType === <span class="string">'object'</span> && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
    }
  }
  <span class="keyword">return</span> <span class="literal">false</span>;
}
</pre></td></tr></table></figure>

<p>不要被这么多代码吓到，其实流程很简单。<br>它主要做了什么事呢？首先会合并改动，生成最新的state,props然后拿以前的render返回的element跟现在最新调用render生成的element进行对比（_shouldUpdateReactComponent），看看需不需要更新，如果要更新就继续调用对应的component类对应的receiveComponent就好啦，其实就是直接当甩手掌柜，事情直接丢给手下去办了。当然还有种情况是，两次生成的element差别太大，就不是一个类型的，那好办直接重新生成一份新的代码重新渲染一次就o了。</p>
<p>本质上还是递归调用receiveComponent的过程。</p>
<p>这里注意两个函数：</p>
<ul>
<li>inst.shouldComponentUpdate是实例方法，当我们不希望某次setState后更新，我们就可以重写这个方法，返回false就好了。</li>
<li>_shouldUpdateReactComponent是一个全局方法，这个是一种reactjs的优化机制。用来决定是直接全部替换，还是使用很细微的改动。当两次render出来的子节点key不同，直接全部重新渲染一遍，替换就好了。否则，我们就得来个递归的更新，保证最小化的更新机制，这样可以不会有太大的闪烁。</li>
</ul>
<p>另外可以看到这里还处理了一套更新的生命周期调用机制。</p>
<h3 id="文本节点的receiveComponent">文本节点的receiveComponent</h3>
<p>我们再看看文本节点的，比较简单：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>
ReactDOMTextComponent.prototype.receiveComponent = <span class="function"><span class="keyword">function</span><span class="params">(nextText)</span> {</span>
    <span class="keyword">var</span> nextStringText = <span class="string">''</span> + nextText;
    <span class="comment">//跟以前保存的字符串比较</span>
    <span class="keyword">if</span> (nextStringText !== <span class="keyword">this</span>._currentElement) {
        <span class="keyword">this</span>._currentElement = nextStringText;
        <span class="comment">//替换整个节点</span>
        $(<span class="string">'[data-reactid="'</span> + <span class="keyword">this</span>._rootNodeID + <span class="string">'"]'</span>).html(<span class="keyword">this</span>._currentElement);

    }
}
</pre></td></tr></table></figure>

<p>没什么好说的，如果不同的话，直接找到对应的节点，更新就好了。</p>
<h3 id="基本元素element的receiveComponent">基本元素element的receiveComponent</h3>
<p>最后我们开始看比较复杂的浏览器基本元素的更新机制。<br>比如我们看看下面的html:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>
<span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"test"</span> <span class="attribute">name</span>=<span class="value">"hello"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">span</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>
    <span class="tag">&lt;<span class="title">span</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>

<p>想一下我们怎么以最小代价去更新这段html呢。不难发现其实主要包括两个部分：</p>
<ol>
<li>属性的更新，包括对特殊属性比如事件的处理</li>
<li>子节点的更新,这个比较复杂，为了得到最好的效率，我们需要处理下面这些问题：<ul>
<li>拿新的子节点树跟以前老的子节点树对比，找出他们之间的差别。我们称之为diff</li>
<li>所有差别找出后，再一次性的去更新。我们称之为patch</li>
</ul>
</li>
</ol>
<p>所以更新代码结构如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>
ReactDOMComponent.prototype.receiveComponent = <span class="function"><span class="keyword">function</span><span class="params">(nextElement)</span> {</span>
    <span class="keyword">var</span> lastProps = <span class="keyword">this</span>._currentElement.props;
    <span class="keyword">var</span> nextProps = nextElement.props;

    <span class="keyword">this</span>._currentElement = nextElement;
    <span class="comment">//需要单独的更新属性</span>
    <span class="keyword">this</span>._updateDOMProperties(lastProps, nextProps);
    <span class="comment">//再更新子节点</span>
    <span class="keyword">this</span>._updateDOMChildren(nextElement.props.children);
}
</pre></td></tr></table></figure>

<p>整体上也不复杂，先是处理当前节点属性的变动，后面再去处理子节点的变动</p>
<p>我们一步步来，先看看，更新属性怎么变更：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="code"><pre>
ReactDOMComponent.prototype._updateDOMProperties = <span class="function"><span class="keyword">function</span><span class="params">(lastProps, nextProps)</span> {</span>
    <span class="keyword">var</span> propKey;
    <span class="comment">//遍历，当一个老的属性不在新的属性集合里时，需要删除掉。</span>

    <span class="keyword">for</span> (propKey <span class="keyword">in</span> lastProps) {
        <span class="comment">//新的属性里有，或者propKey是在原型上的直接跳过。这样剩下的都是不在新属性集合里的。需要删除</span>
        <span class="keyword">if</span> (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
            <span class="keyword">continue</span>;
        }
        <span class="comment">//对于那种特殊的，比如这里的事件监听的属性我们需要去掉监听</span>
        <span class="keyword">if</span> (<span class="regexp">/^on[A-Za-z]/</span>.test(propKey)) {
            <span class="keyword">var</span> eventType = propKey.replace(<span class="string">'on'</span>, <span class="string">''</span>);
            <span class="comment">//针对当前的节点取消事件代理</span>
            $(document).undelegate(<span class="string">'[data-reactid="'</span> + <span class="keyword">this</span>._rootNodeID + <span class="string">'"]'</span>, eventType, lastProps[propKey]);
            <span class="keyword">continue</span>;
        }

        <span class="comment">//从dom上删除不需要的属性</span>
        $(<span class="string">'[data-reactid="'</span> + <span class="keyword">this</span>._rootNodeID + <span class="string">'"]'</span>).removeAttr(propKey)
    }

    <span class="comment">//对于新的属性，需要写到dom节点上</span>
    <span class="keyword">for</span> (propKey <span class="keyword">in</span> nextProps) {
        <span class="comment">//对于事件监听的属性我们需要特殊处理</span>
        <span class="keyword">if</span> (<span class="regexp">/^on[A-Za-z]/</span>.test(propKey)) {
            <span class="keyword">var</span> eventType = propKey.replace(<span class="string">'on'</span>, <span class="string">''</span>);
            <span class="comment">//以前如果已经有，说明有了监听，需要先去掉</span>
            lastProps[propKey] && $(document).undelegate(<span class="string">'[data-reactid="'</span> + <span class="keyword">this</span>._rootNodeID + <span class="string">'"]'</span>, eventType, lastProps[propKey]);
            <span class="comment">//针对当前的节点添加事件代理,以_rootNodeID为命名空间</span>
            $(document).delegate(<span class="string">'[data-reactid="'</span> + <span class="keyword">this</span>._rootNodeID + <span class="string">'"]'</span>, eventType + <span class="string">'.'</span> + <span class="keyword">this</span>._rootNodeID, nextProps[propKey]);
            <span class="keyword">continue</span>;
        }

        <span class="keyword">if</span> (propKey == <span class="string">'children'</span>) <span class="keyword">continue</span>;

        <span class="comment">//添加新的属性，或者是更新老的同名属性</span>
        $(<span class="string">'[data-reactid="'</span> + <span class="keyword">this</span>._rootNodeID + <span class="string">'"]'</span>).prop(propKey, nextProps[propKey])
    }

}
</pre></td></tr></table></figure>

<p>属性的变更并不是特别复杂，主要就是找到以前老的不用的属性直接去掉，新的属性赋值，并且注意其中特殊的事件属性做出特殊处理就行了。</p>
<p>下面我们看子节点的更新，也是最复杂的部分。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre>
ReactDOMComponent.prototype.receiveComponent = <span class="function"><span class="keyword">function</span><span class="params">(nextElement)</span>{</span>
    <span class="keyword">var</span> lastProps = <span class="keyword">this</span>._currentElement.props;
    <span class="keyword">var</span> nextProps = nextElement.props;

    <span class="keyword">this</span>._currentElement = nextElement;
    <span class="comment">//需要单独的更新属性</span>
    <span class="keyword">this</span>._updateDOMProperties(lastProps,nextProps);
    <span class="comment">//再更新子节点</span>
    <span class="keyword">this</span>._updateDOMChildren(nextProps.children);
}

<span class="comment">//全局的更新深度标识</span>
<span class="keyword">var</span> updateDepth = <span class="number">0</span>;
<span class="comment">//全局的更新队列，所有的差异都存在这里</span>
<span class="keyword">var</span> diffQueue = [];

ReactDOMComponent.prototype._updateDOMChildren = <span class="function"><span class="keyword">function</span><span class="params">(nextChildrenElements)</span>{</span>
    updateDepth++
    <span class="comment">//_diff用来递归找出差别,组装差异对象,添加到更新队列diffQueue。</span>
    <span class="keyword">this</span>._diff(diffQueue,nextChildrenElements);
    updateDepth--
    <span class="keyword">if</span>(updateDepth == <span class="number">0</span>){
        <span class="comment">//在需要的时候调用patch，执行具体的dom操作</span>
        <span class="keyword">this</span>._patch(diffQueue);
        diffQueue = [];
    }
}
</pre></td></tr></table></figure>

<p>就像我们之前说的一样，更新子节点包含两个部分，一个是递归的分析差异，把差异添加到队列中。然后在合适的时机调用<code>_patch</code>把差异应用到dom上。</p>
<p>那么什么是合适的时机，updateDepth又是干嘛的？</p>
<p>这里需要注意的是，<code>_diff</code>内部也会递归调用子节点的receiveComponent于是当某个子节点也是浏览器普通节点，就也会走_updateDOMChildren这一步。所以这里使用了updateDepth来记录递归的过程，只有等递归回来updateDepth为0时，代表整个差异已经分析完毕，可以开始使用patch来处理差异队列了。</p>
<p>所以我们关键是实现<code>_diff</code>与<code>_patch</code>两个方法。</p>
<p>我们先看_diff的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
</pre></td><td class="code"><pre><span class="comment">//差异更新的几种类型</span>
<span class="keyword">var</span> UPATE_TYPES = {
    MOVE_EXISTING: <span class="number">1</span>,
    REMOVE_NODE: <span class="number">2</span>,
    INSERT_MARKUP: <span class="number">3</span>
}


<span class="comment">//普通的children是一个数组，此方法把它转换成一个map,key就是element的key,如果是text节点或者element创建时并没有传入key,就直接用在数组里的index标识</span>
<span class="function"><span class="keyword">function</span> <span class="title">flattenChildren</span><span class="params">(componentChildren)</span> {</span>
    <span class="keyword">var</span> child;
    <span class="keyword">var</span> name;
    <span class="keyword">var</span> childrenMap = {};
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; componentChildren.length; i++) {
        child = componentChildren[i];
        name = child && child._currentelement && child._currentelement.key ? child._currentelement.key : i.toString(<span class="number">36</span>);
        childrenMap[name] = child;
    }
    <span class="keyword">return</span> childrenMap;
}


<span class="comment">//主要用来生成子节点elements的component集合</span>
<span class="comment">//这边注意，有个判断逻辑，如果发现是更新，就会继续使用以前的componentInstance,调用对应的receiveComponent。</span>
<span class="comment">//如果是新的节点，就会重新生成一个新的componentInstance，</span>
<span class="function"><span class="keyword">function</span> <span class="title">generateComponentChildren</span><span class="params">(prevChildren, nextChildrenElements)</span> {</span>
    <span class="keyword">var</span> nextChildren = {};
    nextChildrenElements = nextChildrenElements || [];
    $.each(nextChildrenElements, <span class="function"><span class="keyword">function</span><span class="params">(index, element)</span> {</span>
        <span class="keyword">var</span> name = element.key ? element.key : index;
        <span class="keyword">var</span> prevChild = prevChildren && prevChildren[name];
        <span class="keyword">var</span> prevElement = prevChild && prevChild._currentElement;
        <span class="keyword">var</span> nextElement = element;

        <span class="comment">//调用_shouldUpdateReactComponent判断是否是更新</span>
        <span class="keyword">if</span> (_shouldUpdateReactComponent(prevElement, nextElement)) {
            <span class="comment">//更新的话直接递归调用子节点的receiveComponent就好了</span>
            prevChild.receiveComponent(nextElement);
            <span class="comment">//然后继续使用老的component</span>
            nextChildren[name] = prevChild;
        } <span class="keyword">else</span> {
            <span class="comment">//对于没有老的，那就重新新增一个，重新生成一个component</span>
            <span class="keyword">var</span> nextChildInstance = instantiateReactComponent(nextElement, <span class="literal">null</span>);
            <span class="comment">//使用新的component</span>
            nextChildren[name] = nextChildInstance;
        }
    })

    <span class="keyword">return</span> nextChildren;
}



<span class="comment">//_diff用来递归找出差别,组装差异对象,添加到更新队列diffQueue。</span>
ReactDOMComponent.prototype._diff = <span class="function"><span class="keyword">function</span><span class="params">(diffQueue, nextChildrenElements)</span> {</span>
  <span class="keyword">var</span> self = <span class="keyword">this</span>;
  <span class="comment">//拿到之前的子节点的 component类型对象的集合,这个是在刚开始渲染时赋值的，记不得的可以翻上面</span>
  <span class="comment">//_renderedChildren 本来是数组，我们搞成map</span>
  <span class="keyword">var</span> prevChildren = flattenChildren(self._renderedChildren);
  <span class="comment">//生成新的子节点的component对象集合，这里注意，会复用老的component对象</span>
  <span class="keyword">var</span> nextChildren = generateComponentChildren(prevChildren, nextChildrenElements);
  <span class="comment">//重新赋值_renderedChildren，使用最新的。</span>
  self._renderedChildren = []
  $.each(nextChildren, <span class="function"><span class="keyword">function</span><span class="params">(key, instance)</span> {</span>
    self._renderedChildren.push(instance);
  })


  <span class="keyword">var</span> nextIndex = <span class="number">0</span>; <span class="comment">//代表到达的新的节点的index</span>
  <span class="comment">//通过对比两个集合的差异，组装差异节点添加到队列中</span>
  <span class="keyword">for</span> (name <span class="keyword">in</span> nextChildren) {
    <span class="keyword">if</span> (!nextChildren.hasOwnProperty(name)) {
      <span class="keyword">continue</span>;
    }
    <span class="keyword">var</span> prevChild = prevChildren && prevChildren[name];
    <span class="keyword">var</span> nextChild = nextChildren[name];
    <span class="comment">//相同的话，说明是使用的同一个component,所以我们需要做移动的操作</span>
    <span class="keyword">if</span> (prevChild === nextChild) {
      <span class="comment">//添加差异对象，类型：MOVE_EXISTING</span>
      diffQueue.push({
        parentId: self._rootNodeID,
        parentNode: $(<span class="string">'[data-reactid='</span> + self._rootNodeID + <span class="string">']'</span>),
        type: UPATE_TYPES.MOVE_EXISTING,
        fromIndex: prevChild._mountIndex,
        toIndex: nextIndex
      })
    } <span class="keyword">else</span> { <span class="comment">//如果不相同，说明是新增加的节点</span>
      <span class="comment">//但是如果老的还存在，就是element不同，但是component一样。我们需要把它对应的老的element删除。</span>
      <span class="keyword">if</span> (prevChild) {
        <span class="comment">//添加差异对象，类型：REMOVE_NODE</span>
        diffQueue.push({
          parentId: self._rootNodeID,
          parentNode: $(<span class="string">'[data-reactid='</span> + self._rootNodeID + <span class="string">']'</span>),
          type: UPATE_TYPES.REMOVE_NODE,
          fromIndex: prevChild._mountIndex,
          toIndex: <span class="literal">null</span>
        })

        <span class="comment">//如果以前已经渲染过了，记得先去掉以前所有的事件监听，通过命名空间全部清空</span>
        <span class="keyword">if</span> (prevChild._rootNodeID) {
            $(document).undelegate(<span class="string">'.'</span> + prevChild._rootNodeID);
        }

      }
      <span class="comment">//新增加的节点，也组装差异对象放到队列里</span>
      <span class="comment">//添加差异对象，类型：INSERT_MARKUP</span>
      diffQueue.push({
        parentId: self._rootNodeID,
        parentNode: $(<span class="string">'[data-reactid='</span> + self._rootNodeID + <span class="string">']'</span>),
        type: UPATE_TYPES.INSERT_MARKUP,
        fromIndex: <span class="literal">null</span>,
        toIndex: nextIndex,
        markup: nextChild.mountComponent() <span class="comment">//新增的节点，多一个此属性，表示新节点的dom内容</span>
      })
    }
    <span class="comment">//更新mount的index</span>
    nextChild._mountIndex = nextIndex;
    nextIndex++;
  }



  <span class="comment">//对于老的节点里有，新的节点里没有的那些，也全都删除掉</span>
  <span class="keyword">for</span> (name <span class="keyword">in</span> prevChildren) {
    <span class="keyword">if</span> (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
      <span class="comment">//添加差异对象，类型：REMOVE_NODE</span>
      diffQueue.push({
        parentId: self._rootNodeID,
        parentNode: $(<span class="string">'[data-reactid='</span> + self._rootNodeID + <span class="string">']'</span>),
        type: UPATE_TYPES.REMOVE_NODE,
        fromIndex: prevChild._mountIndex,
        toIndex: <span class="literal">null</span>
      })
      <span class="comment">//如果以前已经渲染过了，记得先去掉以前所有的事件监听</span>
      <span class="keyword">if</span> (prevChildren[name]._rootNodeID) {
        $(document).undelegate(<span class="string">'.'</span> + prevChildren[name]._rootNodeID);
      }
    }
  }
}
</pre></td></tr></table></figure>

<p>我们分析下上面的代码，咋一看好多，好复杂，不急我们从入口开始看。</p>
<p>首先我们拿到之前的component的集合，如果是第一次更新的话，这个值是我们在渲染时赋值的。然后我们调用generateComponentChildren生成最新的component集合。我们知道component是用来放element的，一个萝卜一个坑。</p>
<p>注意flattenChildren我们这里把数组集合转成了对象map,以element的key作为标识，当然对于text文本或者没有传入key的element,直接用index作为标识。通过这些标识，我们可以从类型的角度来判断两个component是否是一样的。</p>
<p>generateComponentChildren会尽量的复用以前的component，也就是那些坑，当发现可以复用component（也就是key一致）时，就还用以前的，只需要调用他对应的更新方法receiveComponent就行了，这样就会递归的去获取子节点的差异对象然后放到队列了。如果发现不能复用那就是新的节点，我们就需要instantiateReactComponent重新生成一个新的component。</p>
<blockquote>
<p>这里的flattenChildren需要给予很大的关注，比如对于一个表格列表，我们在最前面插入了一条数据，想一下如果我们创建element时没有传入key，所有的key都是null,这样reactjs在generateComponentChildren时就会默认通过顺序（index）来一一对应改变前跟改变后的子节点，这样变更前与变更后的对应节点判断（_shouldUpdateReactComponent）其实是不合适的。也就是说对于这种列表的情况，我们最好给予唯一的标识key，这样reactjs找对应关系时会更方便一点。</p>
</blockquote>
<p>当我们生成好新的component集合以后，我们需要做出对比。组装差异对象。</p>
<p>对比老的集合和新的集合。我们需要找出涵盖四种情况，包括三种类型（UPATE_TYPES）的变动：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>MOVE_EXISTING</td>
<td>新的component类型在老的集合里也有，并且element是可以更新的类型，在generateComponentChildren我们已经调用了receiveComponent，这种情况下prevChild=nextChild,那我们就需要做出移动的操作，可以复用以前的dom节点。</td>
</tr>
<tr>
<td>INSERT_MARKUP</td>
<td>新的component类型不在老的集合里，那么就是全新的节点，我们需要插入新的节点</td>
</tr>
<tr>
<td>REMOVE_NODE</td>
<td>老的component类型，在新的集合里也有，但是对应的element不同了不能直接复用直接更新，那我们也得删除。</td>
</tr>
<tr>
<td>REMOVE_NODE</td>
<td>老的component不在新的集合里的，我们需要删除</td>
</tr>
</tbody>
</table>
<p>所以我们找出了这三种类型的差异，组装成具体的差异对象，然后加到了差异队列里面。</p>
<p>比如我们看下面这个例子，假设下面这些是某个父元素的子元素集合，上面到下面代表了变动流程：</p>
<p><img src="https://img.alicdn.com/tps/TB1oUcQJpXXXXawXVXXXXXXXXXX-1024-768.jpg" alt="变动"></p>
<p>数字我们可以理解为给element的key。</p>
<p>正方形代表element。圆形代表了component。当然也是实际上的dom节点的位置。</p>
<p>从上到下，我们的4 2 1里 2 ，1可以复用之前的component,让他们通知自己的子节点更新后，再告诉2和1，他们在新的集合里需要移动的位置（在我们这里就是组装差异对象加到队列）。3需要删除，4需要新增。</p>
<p>好了，整个的diff就完成了，这个时候当递归完成，我们就需要开始做patch的动作了，把这些差异对象实打实的反映到具体的dom节点上。</p>
<p>我们看下_patch的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></td><td class="code"><pre>

<span class="comment">//用于将childNode插入到指定位置</span>
<span class="function"><span class="keyword">function</span> <span class="title">insertChildAt</span><span class="params">(parentNode, childNode, index)</span> {</span>
    <span class="keyword">var</span> beforeChild = parentNode.children().get(index);
    beforeChild ? childNode.insertBefore(beforeChild) : childNode.appendTo(parentNode);
}

ReactDOMComponent.prototype._patch = <span class="function"><span class="keyword">function</span><span class="params">(updates)</span> {</span>
    <span class="keyword">var</span> update;
    <span class="keyword">var</span> initialChildren = {};
    <span class="keyword">var</span> deleteChildren = [];
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; updates.length; i++) {
        update = updates[i];
        <span class="keyword">if</span> (update.type === UPATE_TYPES.MOVE_EXISTING || update.type === UPATE_TYPES.REMOVE_NODE) {
            <span class="keyword">var</span> updatedIndex = update.fromIndex;
            <span class="keyword">var</span> updatedChild = $(update.parentNode.children().get(updatedIndex));
            <span class="keyword">var</span> parentID = update.parentID;

            <span class="comment">//所有需要更新的节点都保存下来，方便后面使用</span>
            initialChildren[parentID] = initialChildren[parentID] || [];
            <span class="comment">//使用parentID作为简易命名空间</span>
            initialChildren[parentID][updatedIndex] = updatedChild;


            <span class="comment">//所有需要修改的节点先删除,对于move的，后面再重新插入到正确的位置即可</span>
            deleteChildren.push(updatedChild)
        }

    }

    <span class="comment">//删除所有需要先删除的</span>
    $.each(deleteChildren, <span class="function"><span class="keyword">function</span><span class="params">(index, child)</span> {</span>
        $(child).remove();
    })


    <span class="comment">//再遍历一次，这次处理新增的节点，还有修改的节点这里也要重新插入</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; updates.length; k++) {
        update = updates[k];
        <span class="keyword">switch</span> (update.type) {
            <span class="keyword">case</span> UPATE_TYPES.INSERT_MARKUP:
                insertChildAt(update.parentNode, $(update.markup), update.toIndex);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> UPATE_TYPES.MOVE_EXISTING:
                insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);
                <span class="keyword">break</span>;
            <span class="keyword">case</span> UPATE_TYPES.REMOVE_NODE:
                <span class="comment">// 什么都不需要做，因为上面已经帮忙删除掉了</span>
                <span class="keyword">break</span>;
        }
    }
}
</pre></td></tr></table></figure>

<p><code>_patch</code>主要就是挨个遍历差异队列，遍历两次，第一次删除掉所有需要变动的节点，然后第二次插入新的节点还有修改的节点。这里为什么可以直接挨个的插入呢？原因就是我们在diff阶段添加差异节点到差异队列时，本身就是有序的，也就是说对于新增节点（包括move和insert的）在队列里的顺序就是最终dom的顺序，所以我们才可以挨个的直接根据index去塞入节点。</p>
<p>但是其实你会发现这里有个问题，就是所有的节点都会被删除，包括复用以前的component类型为<code>UPATE_TYPES.MOVE_EXISTING</code>的，所以闪烁会很严重。其实我们再看看上面的例子，其实2是不需要记录到差异队列的。这样后面patch也是ok的。想想是为什么呢？</p>
<p>我们来改造下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td><td class="code"><pre>
<span class="comment">//_diff用来递归找出差别,组装差异对象,添加到更新队列diffQueue。</span>
ReactDOMComponent.prototype._diff = <span class="function"><span class="keyword">function</span><span class="params">(diffQueue, nextChildrenElements)</span>{</span>
    。。。
    <span class="comment">/**注意新增代码**/</span>
    <span class="keyword">var</span> lastIndex = <span class="number">0</span>;<span class="comment">//代表访问的最后一次的老的集合的位置</span>
    <span class="keyword">var</span> nextIndex = <span class="number">0</span>;<span class="comment">//代表到达的新的节点的index</span>
    <span class="comment">//通过对比两个集合的差异，组装差异节点添加到队列中</span>
    <span class="keyword">for</span> (name <span class="keyword">in</span> nextChildren) {
        <span class="keyword">if</span> (!nextChildren.hasOwnProperty(name)) {
          <span class="keyword">continue</span>;
        }
        <span class="keyword">var</span> prevChild = prevChildren && prevChildren[name];
        <span class="keyword">var</span> nextChild = nextChildren[name];
        <span class="comment">//相同的话，说明是使用的同一个component,所以我们需要做移动的操作</span>
        <span class="keyword">if</span> (prevChild === nextChild) {
          <span class="comment">//添加差异对象，类型：MOVE_EXISTING</span>
          。。。。
          <span class="comment">/**注意新增代码**/</span>
          prevChild._mountIndex &lt; lastIndex && diffQueue.push({
                parentId:<span class="keyword">this</span>._rootNodeID,
                parentNode:$(<span class="string">'[data-reactid='</span>+<span class="keyword">this</span>._rootNodeID+<span class="string">']'</span>),
                type: UPATE_TYPES.REMOVE_NODE,
                fromIndex: prevChild._mountIndex,
                toIndex:<span class="literal">null</span>
          })
          lastIndex = <span class="built_in">Math</span>.max(prevChild._mountIndex, lastIndex);
        } <span class="keyword">else</span> {
          <span class="comment">//如果不相同，说明是新增加的节点，</span>
          <span class="keyword">if</span> (prevChild) {
            <span class="comment">//但是如果老的还存在，就是element不同，但是component一样。我们需要把它对应的老的element删除。</span>
            <span class="comment">//添加差异对象，类型：REMOVE_NODE</span>
            。。。。。
            <span class="comment">/**注意新增代码**/</span>
            lastIndex = <span class="built_in">Math</span>.max(prevChild._mountIndex, lastIndex);
          }
          。。。
        }
        <span class="comment">//更新mount的inddex</span>
        nextChild._mountIndex = nextIndex;
        nextIndex++;
      }

      <span class="comment">//对于老的节点里有，新的节点里没有的那些，也全都删除掉</span>
      。。。
}
</pre></td></tr></table></figure>

<p>可以看到我们多加了个lastIndex，这个代表最后一次访问的老集合节点的最大的位置。<br>而我们加了个判断，只有_mountIndex小于这个lastIndex的才会需要加入差异队列。有了这个判断上面的例子2就不需要move。而程序也可以好好的运行，实际上大部分都是2这种情况。</p>
<p>这是一种顺序优化，lastIndex一直在更新，代表了当前访问的最右的老的集合的元素。<br>我们假设上一个元素是A,添加后更新了lastIndex。<br>如果我们这时候来个新元素B，比lastIndex还大说明当前元素在老的集合里面就比上一个A靠后。所以这个元素就算不加入差异队列，也不会影响到其他人，不会影响到后面的path插入节点。因为我们从patch里面知道，新的集合都是按顺序从头开始插入元素的，只有当新元素比lastIndex小时才需要变更。其实只要仔细推敲下上面那个例子，就可以理解这种优化手段了。</p>
<p>这样整个的更新机制就完成了。我们再来简单回顾下reactjs的差异算法：</p>
<p>首先是所有的component都实现了receiveComponent来负责自己的更新，而浏览器默认元素的更新最为复杂，也就是经常说的 diff algorithm。</p>
<p>react有一个全局_shouldUpdateReactComponent用来根据element的key来判断是更新还是重新渲染，这是第一个差异判断。比如自定义元素里，就使用这个判断，通过这种标识判断，会变得特别高效。</p>
<p>每个类型的元素都要处理好自己的更新：</p>
<ol>
<li><p>自定义元素的更新，主要是更新render出的节点，做甩手掌柜交给render出的节点的对应component去管理更新。</p>
</li>
<li><p>text节点的更新很简单，直接更新文案。</p>
</li>
<li><p>浏览器基本元素的更新，分为两块：</p>
<ul>
<li>先是更新属性，对比出前后属性的不同，局部更新。并且处理特殊属性，比如事件绑定。</li>
<li>然后是子节点的更新，子节点更新主要是找出差异对象，找差异对象的时候也会使用上面的_shouldUpdateReactComponent来判断，如果是可以直接更新的就会递归调用子节点的更新，这样也会递归查找差异对象，这里还会使用lastIndex这种做一种优化，使一些节点保留位置，之后根据差异对象操作dom元素（位置变动，删除，添加等）。</li>
</ul>
</li>
</ol>
<p>整个reactjs的差异算法就是这个样子。最核心的两个_shouldUpdateReactComponent以及diff,patch算法。</p>
<h2 id="小试牛刀">小试牛刀</h2>
<p>有了上面简易版的reaactjs，我们来实现一个简单的todolist吧。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre>
<span class="keyword">var</span> TodoList = React.createClass({
  getInitialState: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> {items: []};
  },
  add:<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    <span class="keyword">var</span> nextItems = <span class="keyword">this</span>.state.items.concat([<span class="keyword">this</span>.state.text]);
    <span class="keyword">this</span>.setState({items: nextItems, text: <span class="string">''</span>});
  },
  onChange: <span class="function"><span class="keyword">function</span><span class="params">(e)</span> {</span>
    <span class="keyword">this</span>.setState({text: e.target.value});
  },
  render: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> createItem = <span class="function"><span class="keyword">function</span><span class="params">(itemText)</span> {</span>
      <span class="keyword">return</span> React.createElement(<span class="string">"div"</span>, <span class="literal">null</span>, itemText);
    };

    <span class="keyword">var</span> lists = <span class="keyword">this</span>.state.items.map(createItem);
    <span class="keyword">var</span> input = React.createElement(<span class="string">"input"</span>, {onkeyup: <span class="keyword">this</span>.onChange.bind(<span class="keyword">this</span>),value: <span class="keyword">this</span>.state.text});
    <span class="keyword">var</span> button = React.createElement(<span class="string">"p"</span>, {onclick: <span class="keyword">this</span>.add.bind(<span class="keyword">this</span>)}, <span class="string">'Add#'</span> + (<span class="keyword">this</span>.state.items.length + <span class="number">1</span>))
    <span class="keyword">var</span> children = lists.concat([input,button])

    <span class="keyword">return</span> React.createElement(<span class="string">"div"</span>, <span class="literal">null</span>,children);
  }
});


React.render(React.createElement(TodoList), document.getElementById(<span class="string">"container"</span>));
</pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="https://img.alicdn.com/tps/TB1bPcWJpXXXXcwXFXXXXXXXXXX-537-228.gif" alt="todolist"></p>
<p>整个的流程是这样：</p>
<ul>
<li>初次渲染时先使用<code>ReactCompositeComponent</code>渲染自定义元素TodoList，调用getInitialState拿到初始值，然后使用<code>ReactDOMComponent</code>渲染render返回的div基本元素节点。div基本元素再一层层的使用<code>ReactDOMComponent</code>去渲染各个子节点,包括input,还有p。</li>
<li>在input框输入文字触发onchange事件，开始调用setState做出变更，直接变更render出来的节点，经过差异算法，一层层的往下。最后改变value值。</li>
<li>点击按钮，触发add然后开始更新，经过差异算法，添加一个节点。同时更新按钮上面的文案。</li>
</ul>
<p>基本上，整个流程都梳理清楚了</p>
<h1 id="结语">结语</h1>
<p>这只是个玩具，但实现了reactjs最核心的功能，虚拟节点，差异算法，单向数据更新都在这里了。还有很多reactjs优秀的东西没有实现，比如对象生成时内存的线程池管理，批量更新机制，事件的优化，服务端的渲染，immutable data等等。这些东西受限于篇幅就不具体展开了。</p>
<p>reactjs作为一种解决方案，虚拟节点的想法比较新奇，不过个人还是不能接受这种别扭的写法。使用reactjs，就要使用他那一整套的开发方式，而他核心的功能其实只是一个差异算法，而这种其实已经有相关的库实现了。</p>
<p>最后再吐槽下前端真是苦命，各种新技术，各种新知识脑细胞不够用了。也难怪前端永远都缺人。</p>
<p>相关资料：</p>
<ol>
<li><a href="http://freestyle21.cn/2015/06/21/react-diff-%E7%AE%97%E6%B3%95/" target="_blank">http://freestyle21.cn/2015/06/21/react-diff-%E7%AE%97%E6%B3%95/</a></li>
<li><a href="https://github.com/Matt-Esch/virtual-dom" target="_blank">https://github.com/Matt-Esch/virtual-dom</a></li>
<li><a href="http://zjumty.iteye.com/blog/2207030" target="_blank">http://zjumty.iteye.com/blog/2207030</a></li>
<li><a href="http://hao.jser.com/archive/7871/" target="_blank">http://hao.jser.com/archive/7871/</a></li>
<li><a href="https://github.com/miniflycn/qvd/issues/1" target="_blank">https://github.com/miniflycn/qvd/issues/1</a></li>
<li><a href="http://fluentconf.com/fluent2014/public/schedule/detail/32395" target="_blank">http://fluentconf.com/fluent2014/public/schedule/detail/32395</a></li>
<li><a href="http://calendar.perfplanet.com/2013/diff/" target="_blank">http://calendar.perfplanet.com/2013/diff/</a></li>
<li><a href="http://segmentfault.com/a/1190000000606216" target="_blank">http://segmentfault.com/a/1190000000606216</a></li>
<li><a href="http://hulufei.gitbooks.io/react-tutorial/content/introduction.html" target="_blank">http://hulufei.gitbooks.io/react-tutorial/content/introduction.html</a></li>
<li><a href="http://reactjs.cn/react/docs/multiple-components.html" target="_blank">http://reactjs.cn/react/docs/multiple-components.html</a></li>
<li><a href="http://facebook.github.io/react/docs/multiple-components.html" target="_blank">http://facebook.github.io/react/docs/multiple-components.html</a></li>
</ol>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/reactjs/">reactjs</a><a href="/tags/源码分析/">源码分析</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/javascript/">javascript</a>►<a class="article-category-link" href="/categories/javascript/源码分析/">源码分析</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://purplebamboo.github.com/2015/09/15/reactjs_source_analyze_part_two/" data-title="reactjs源码分析-下篇（更新机制实现原理） | blog of purplebamboo" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2016/04/21/about-partial-refresh/" title="局部刷新模板那些事">
  <strong>PREVIOUS:</strong><br/>
  <span>
  局部刷新模板那些事</span>
</a>
</div>


<div class="next">
<a href="/2015/09/15/reactjs_source_analyze_part_one/"  title="reactjs源码分析-上篇（首次渲染实现原理）">
 <strong>NEXT:</strong><br/> 
 <span>reactjs源码分析-上篇（首次渲染实现原理）
</span>
</a>
</div>

</nav>

	
<section class="comment">
	<div class="ds-thread"></div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现更新机制"><span class="toc-number">2.</span> <span class="toc-text">实现更新机制</span></a></li><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义元素的receiveComponent"><span class="toc-number">2.1.</span> <span class="toc-text">自定义元素的receiveComponent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文本节点的receiveComponent"><span class="toc-number">2.2.</span> <span class="toc-text">文本节点的receiveComponent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本元素element的receiveComponent"><span class="toc-number">2.3.</span> <span class="toc-text">基本元素element的receiveComponent</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#小试牛刀"><span class="toc-number">3.</span> <span class="toc-text">小试牛刀</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#结语"><span class="toc-number"></span> <span class="toc-text">结语</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/angularjs记录/" title="angularjs记录">angularjs记录<sup>9</sup></a></li>
		
			<li><a href="/categories/css/" title="css">css<sup>1</sup></a></li>
		
			<li><a href="/categories/iconfont技术/" title="iconfont技术">iconfont技术<sup>2</sup></a></li>
		
			<li><a href="/categories/javascript/" title="javascript">javascript<sup>18</sup></a></li>
		
			<li><a href="/categories/javascript/nodejs/" title="nodejs">nodejs<sup>2</sup></a></li>
		
			<li><a href="/categories/从零单排/" title="从零单排">从零单排<sup>1</sup></a></li>
		
			<li><a href="/categories/各种知识点记录/" title="各种知识点记录">各种知识点记录<sup>1</sup></a></li>
		
			<li><a href="/categories/javascript/源码分析/" title="源码分析">源码分析<sup>7</sup></a></li>
		
			<li><a href="/categories/系统环境/" title="系统环境">系统环境<sup>1</sup></a></li>
		
			<li><a href="/categories/angularjs记录/翻译/" title="翻译">翻译<sup>1</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/Filters/" title="Filters">Filters<sup>1</sup></a></li>
		
			<li><a href="/tags/analyze/" title="analyze">analyze<sup>1</sup></a></li>
		
			<li><a href="/tags/angular/" title="angular">angular<sup>2</sup></a></li>
		
			<li><a href="/tags/angularjs/" title="angularjs">angularjs<sup>7</sup></a></li>
		
			<li><a href="/tags/ast/" title="ast">ast<sup>1</sup></a></li>
		
			<li><a href="/tags/async/" title="async">async<sup>1</sup></a></li>
		
			<li><a href="/tags/border-shadow/" title="border-shadow">border-shadow<sup>1</sup></a></li>
		
			<li><a href="/tags/chunked/" title="chunked">chunked<sup>1</sup></a></li>
		
			<li><a href="/tags/class/" title="class">class<sup>1</sup></a></li>
		
			<li><a href="/tags/co/" title="co">co<sup>2</sup></a></li>
		
			<li><a href="/tags/comet/" title="comet">comet<sup>1</sup></a></li>
		
			<li><a href="/tags/controllers/" title="controllers">controllers<sup>1</sup></a></li>
		
			<li><a href="/tags/css3/" title="css3">css3<sup>1</sup></a></li>
		
			<li><a href="/tags/generator/" title="generator">generator<sup>1</sup></a></li>
		
			<li><a href="/tags/git/" title="git">git<sup>1</sup></a></li>
		
			<li><a href="/tags/gulp/" title="gulp">gulp<sup>1</sup></a></li>
		
			<li><a href="/tags/html/" title="html">html<sup>1</sup></a></li>
		
			<li><a href="/tags/iconfont/" title="iconfont">iconfont<sup>2</sup></a></li>
		
			<li><a href="/tags/javascript/" title="javascript">javascript<sup>15</sup></a></li>
		
			<li><a href="/tags/koa/" title="koa">koa<sup>2</sup></a></li>
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
      <li><a href="http://ued.taobao.com/" target="_blank">淘宝UED</a> </li>            <li><a href="http://www.aliued.com/" target="_blank">Alibaba国际站UED</a> </li>            <li><a href="http://china.aliued.com/" target="_blank">Alibaba中文站UED</a> </li>            <li><a href="http://ued.alipay.com/" target="_blank"> 支付宝UED</a> </li>            <li><a href="http://ued.tmall.com/" target="_blank">天猫UED</a> </li><li><a href="http://ur.alibaba-inc.com">阿里用户体验中心</a> </li>	 <li><a href="http://www.uisdc.com" target="_blank">优秀网页设计</a> </li>
      
    </ul>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
		<p class="copyright">Powered by <a href="http://zespia.tw/hexo/" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2016 
		
		<a href="http://purplebamboo.github.com" target="_blank" title="purplebamboo">purplebamboo</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"cherishpeace"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 






<script type="text/javascript">
  $(function(){
    window.onscroll = function(){
      //console.log($(document).scrollTop()+"px")
      $('.background-container .bg-dy2').css('backgroundPosition','0 '+$(document).scrollTop()+"px");
    }

  })
</script>
<div class="background-container">
  <div class="bg-dy1">

  </div>
  <div class="bg-dy2">

  </div>

</div

  </body>
</html>
